import {
  require_typescript
} from "./chunk-3WMFFSVM.js";
import {
  EncodedTokenMetadata,
  FontStyle,
  INITIAL,
  Registry,
  Theme
} from "./chunk-X3DTH3TQ.js";
import {
  __commonJS,
  __esm,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@vue/shared/dist/shared.esm-bundler.js
var shared_esm_bundler_exports = {};
__export(shared_esm_bundler_exports, {
  EMPTY_ARR: () => EMPTY_ARR,
  EMPTY_OBJ: () => EMPTY_OBJ,
  NO: () => NO,
  NOOP: () => NOOP,
  PatchFlagNames: () => PatchFlagNames,
  PatchFlags: () => PatchFlags,
  ShapeFlags: () => ShapeFlags,
  SlotFlags: () => SlotFlags,
  camelize: () => camelize,
  capitalize: () => capitalize,
  cssVarNameEscapeSymbolsRE: () => cssVarNameEscapeSymbolsRE,
  def: () => def,
  escapeHtml: () => escapeHtml,
  escapeHtmlComment: () => escapeHtmlComment,
  extend: () => extend2,
  genCacheKey: () => genCacheKey,
  genPropsAccessExp: () => genPropsAccessExp,
  generateCodeFrame: () => generateCodeFrame,
  getEscapedCssVarName: () => getEscapedCssVarName,
  getGlobalThis: () => getGlobalThis,
  hasChanged: () => hasChanged,
  hasOwn: () => hasOwn,
  hyphenate: () => hyphenate,
  includeBooleanAttr: () => includeBooleanAttr,
  invokeArrayFns: () => invokeArrayFns,
  isArray: () => isArray,
  isBooleanAttr: () => isBooleanAttr,
  isBuiltInDirective: () => isBuiltInDirective,
  isDate: () => isDate,
  isFunction: () => isFunction,
  isGloballyAllowed: () => isGloballyAllowed,
  isGloballyWhitelisted: () => isGloballyWhitelisted,
  isHTMLTag: () => isHTMLTag,
  isIntegerKey: () => isIntegerKey,
  isKnownHtmlAttr: () => isKnownHtmlAttr,
  isKnownMathMLAttr: () => isKnownMathMLAttr,
  isKnownSvgAttr: () => isKnownSvgAttr,
  isMap: () => isMap,
  isMathMLTag: () => isMathMLTag,
  isModelListener: () => isModelListener,
  isObject: () => isObject,
  isOn: () => isOn,
  isPlainObject: () => isPlainObject,
  isPromise: () => isPromise,
  isRegExp: () => isRegExp,
  isRenderableAttrValue: () => isRenderableAttrValue,
  isReservedProp: () => isReservedProp,
  isSSRSafeAttrName: () => isSSRSafeAttrName,
  isSVGTag: () => isSVGTag,
  isSet: () => isSet,
  isSpecialBooleanAttr: () => isSpecialBooleanAttr,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isVoidTag: () => isVoidTag,
  looseEqual: () => looseEqual,
  looseIndexOf: () => looseIndexOf,
  looseToNumber: () => looseToNumber,
  makeMap: () => makeMap,
  normalizeClass: () => normalizeClass,
  normalizeProps: () => normalizeProps,
  normalizeStyle: () => normalizeStyle,
  objectToString: () => objectToString,
  parseStringStyle: () => parseStringStyle,
  propsToAttrMap: () => propsToAttrMap,
  remove: () => remove,
  slotFlagsText: () => slotFlagsText,
  stringifyStyle: () => stringifyStyle,
  toDisplayString: () => toDisplayString,
  toHandlerKey: () => toHandlerKey,
  toNumber: () => toNumber,
  toRawType: () => toRawType,
  toTypeString: () => toTypeString
});
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key2 of str.split(",")) map[key2] = 1;
  return (val) => val in map;
}
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
function genCacheKey(source, options) {
  return source + JSON.stringify(
    options,
    (_, val) => typeof val === "function" ? val.toString() : val
  );
}
function generateCodeFrame(source, start = 0, end = source.length) {
  start = Math.max(0, Math.min(start, source.length));
  end = Math.max(0, Math.min(end, source.length));
  if (start > end) return "";
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range2; j <= i + range2 || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start
          );
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key2 in normalized) {
          res[key2] = normalized[key2];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject(value)) {
    return value;
  }
}
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  if (!styles) return "";
  if (isString(styles)) return styles;
  let ret = "";
  for (const key2 in styles) {
    const value = styles[key2];
    if (isString(value) || typeof value === "number") {
      const normalizedKey = key2.startsWith(`--`) ? key2 : hyphenate(key2);
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
function isRenderableAttrValue(value) {
  if (value == null) {
    return false;
  }
  const type = typeof value;
  return type === "string" || type === "number" || type === "boolean";
}
function escapeHtml(string4) {
  const str = "" + string4;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html7 = "";
  let escaped;
  let index2;
  let lastIndex = 0;
  for (index2 = match.index; index2 < str.length; index2++) {
    switch (str.charCodeAt(index2)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html7 += str.slice(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html7 += escaped;
  }
  return lastIndex !== index2 ? html7 + str.slice(lastIndex, index2) : html7;
}
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
function getEscapedCssVarName(key2, doubleEscape) {
  return key2.replace(
    cssVarNameEscapeSymbolsRE,
    (s) => doubleEscape ? s === '"' ? '\\\\\\"' : `\\\\${s}` : `\\${s}`
  );
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key2 in a) {
      const aHasKey = a.hasOwnProperty(key2);
      const bHasKey = b.hasOwnProperty(key2);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key2], b[key2])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
var EMPTY_OBJ, EMPTY_ARR, NOOP, NO, isOn, isModelListener, extend2, remove, hasOwnProperty, hasOwn, isArray, isMap, isSet, isDate, isRegExp, isFunction, isString, isSymbol, isObject, isPromise, objectToString, toTypeString, toRawType, isPlainObject, isIntegerKey, isReservedProp, isBuiltInDirective, cacheStringFunction, camelizeRE, camelize, hyphenateRE, hyphenate, capitalize, toHandlerKey, hasChanged, invokeArrayFns, def, looseToNumber, toNumber, _globalThis, getGlobalThis, identRE, PatchFlags, PatchFlagNames, ShapeFlags, SlotFlags, slotFlagsText, GLOBALS_ALLOWED, isGloballyAllowed, isGloballyWhitelisted, range2, listDelimiterRE, propertyDelimiterRE, styleCommentRE, HTML_TAGS, SVG_TAGS, MATH_TAGS, VOID_TAGS, isHTMLTag, isSVGTag, isMathMLTag, isVoidTag, specialBooleanAttrs, isSpecialBooleanAttr, isBooleanAttr, unsafeAttrCharRE, attrValidationCache, propsToAttrMap, isKnownHtmlAttr, isKnownSvgAttr, isKnownMathMLAttr, escapeRE, commentStripRE, cssVarNameEscapeSymbolsRE, isRef, toDisplayString, replacer, stringifySymbol;
var init_shared_esm_bundler = __esm({
  "node_modules/@vue/shared/dist/shared.esm-bundler.js"() {
    EMPTY_OBJ = true ? Object.freeze({}) : {};
    EMPTY_ARR = true ? Object.freeze([]) : [];
    NOOP = () => {
    };
    NO = () => false;
    isOn = (key2) => key2.charCodeAt(0) === 111 && key2.charCodeAt(1) === 110 && // uppercase letter
    (key2.charCodeAt(2) > 122 || key2.charCodeAt(2) < 97);
    isModelListener = (key2) => key2.startsWith("onUpdate:");
    extend2 = Object.assign;
    remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    hasOwnProperty = Object.prototype.hasOwnProperty;
    hasOwn = (val, key2) => hasOwnProperty.call(val, key2);
    isArray = Array.isArray;
    isMap = (val) => toTypeString(val) === "[object Map]";
    isSet = (val) => toTypeString(val) === "[object Set]";
    isDate = (val) => toTypeString(val) === "[object Date]";
    isRegExp = (val) => toTypeString(val) === "[object RegExp]";
    isFunction = (val) => typeof val === "function";
    isString = (val) => typeof val === "string";
    isSymbol = (val) => typeof val === "symbol";
    isObject = (val) => val !== null && typeof val === "object";
    isPromise = (val) => {
      return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
    };
    objectToString = Object.prototype.toString;
    toTypeString = (value) => objectToString.call(value);
    toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    isPlainObject = (val) => toTypeString(val) === "[object Object]";
    isIntegerKey = (key2) => isString(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
    isReservedProp = makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    isBuiltInDirective = makeMap(
      "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
    );
    cacheStringFunction = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    camelizeRE = /-(\w)/g;
    camelize = cacheStringFunction(
      (str) => {
        return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
      }
    );
    hyphenateRE = /\B([A-Z])/g;
    hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    toHandlerKey = cacheStringFunction(
      (str) => {
        const s = str ? `on${capitalize(str)}` : ``;
        return s;
      }
    );
    hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    invokeArrayFns = (fns, ...arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](...arg);
      }
    };
    def = (obj, key2, value, writable = false) => {
      Object.defineProperty(obj, key2, {
        configurable: true,
        enumerable: false,
        writable,
        value
      });
    };
    looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    toNumber = (val) => {
      const n = isString(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
    PatchFlags = {
      "TEXT": 1,
      "1": "TEXT",
      "CLASS": 2,
      "2": "CLASS",
      "STYLE": 4,
      "4": "STYLE",
      "PROPS": 8,
      "8": "PROPS",
      "FULL_PROPS": 16,
      "16": "FULL_PROPS",
      "NEED_HYDRATION": 32,
      "32": "NEED_HYDRATION",
      "STABLE_FRAGMENT": 64,
      "64": "STABLE_FRAGMENT",
      "KEYED_FRAGMENT": 128,
      "128": "KEYED_FRAGMENT",
      "UNKEYED_FRAGMENT": 256,
      "256": "UNKEYED_FRAGMENT",
      "NEED_PATCH": 512,
      "512": "NEED_PATCH",
      "DYNAMIC_SLOTS": 1024,
      "1024": "DYNAMIC_SLOTS",
      "DEV_ROOT_FRAGMENT": 2048,
      "2048": "DEV_ROOT_FRAGMENT",
      "CACHED": -1,
      "-1": "CACHED",
      "BAIL": -2,
      "-2": "BAIL"
    };
    PatchFlagNames = {
      [1]: `TEXT`,
      [2]: `CLASS`,
      [4]: `STYLE`,
      [8]: `PROPS`,
      [16]: `FULL_PROPS`,
      [32]: `NEED_HYDRATION`,
      [64]: `STABLE_FRAGMENT`,
      [128]: `KEYED_FRAGMENT`,
      [256]: `UNKEYED_FRAGMENT`,
      [512]: `NEED_PATCH`,
      [1024]: `DYNAMIC_SLOTS`,
      [2048]: `DEV_ROOT_FRAGMENT`,
      [-1]: `HOISTED`,
      [-2]: `BAIL`
    };
    ShapeFlags = {
      "ELEMENT": 1,
      "1": "ELEMENT",
      "FUNCTIONAL_COMPONENT": 2,
      "2": "FUNCTIONAL_COMPONENT",
      "STATEFUL_COMPONENT": 4,
      "4": "STATEFUL_COMPONENT",
      "TEXT_CHILDREN": 8,
      "8": "TEXT_CHILDREN",
      "ARRAY_CHILDREN": 16,
      "16": "ARRAY_CHILDREN",
      "SLOTS_CHILDREN": 32,
      "32": "SLOTS_CHILDREN",
      "TELEPORT": 64,
      "64": "TELEPORT",
      "SUSPENSE": 128,
      "128": "SUSPENSE",
      "COMPONENT_SHOULD_KEEP_ALIVE": 256,
      "256": "COMPONENT_SHOULD_KEEP_ALIVE",
      "COMPONENT_KEPT_ALIVE": 512,
      "512": "COMPONENT_KEPT_ALIVE",
      "COMPONENT": 6,
      "6": "COMPONENT"
    };
    SlotFlags = {
      "STABLE": 1,
      "1": "STABLE",
      "DYNAMIC": 2,
      "2": "DYNAMIC",
      "FORWARDED": 3,
      "3": "FORWARDED"
    };
    slotFlagsText = {
      [1]: "STABLE",
      [2]: "DYNAMIC",
      [3]: "FORWARDED"
    };
    GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
    isGloballyAllowed = makeMap(GLOBALS_ALLOWED);
    isGloballyWhitelisted = isGloballyAllowed;
    range2 = 2;
    listDelimiterRE = /;(?![^(]*\))/g;
    propertyDelimiterRE = /:([^]+)/;
    styleCommentRE = /\/\*[^]*?\*\//g;
    HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
    SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
    MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
    VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
    isHTMLTag = makeMap(HTML_TAGS);
    isSVGTag = makeMap(SVG_TAGS);
    isMathMLTag = makeMap(MATH_TAGS);
    isVoidTag = makeMap(VOID_TAGS);
    specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
    isBooleanAttr = makeMap(
      specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
    );
    unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
    attrValidationCache = {};
    propsToAttrMap = {
      acceptCharset: "accept-charset",
      className: "class",
      htmlFor: "for",
      httpEquiv: "http-equiv"
    };
    isKnownHtmlAttr = makeMap(
      `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
    );
    isKnownSvgAttr = makeMap(
      `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
    );
    isKnownMathMLAttr = makeMap(
      `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
    );
    escapeRE = /["'&<>]/;
    commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
    cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
    isRef = (val) => {
      return !!(val && val["__v_isRef"] === true);
    };
    toDisplayString = (val) => {
      return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
    };
    replacer = (_key, val) => {
      if (isRef(val)) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key2, val2], i) => {
              entries[stringifySymbol(key2, i) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
        };
      } else if (isSymbol(val)) {
        return stringifySymbol(val);
      } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
      }
      return val;
    };
    stringifySymbol = (v, i = "") => {
      var _a;
      return (
        // Symbol.description in es2019+ so we need to cast here to pass
        // the lib: es2016 check
        isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
      );
    };
  }
});

// node_modules/@vue/language-core/lib/utils/shared.js
var require_shared = __commonJS({
  "node_modules/@vue/language-core/lib/utils/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hyphenateTag = void 0;
    exports.getSlotsPropertyName = getSlotsPropertyName;
    exports.hyphenateAttr = hyphenateAttr;
    var shared_1 = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    function getSlotsPropertyName(vueVersion) {
      return vueVersion < 3 ? "$scopedSlots" : "$slots";
    }
    var shared_2 = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    Object.defineProperty(exports, "hyphenateTag", { enumerable: true, get: function() {
      return shared_2.hyphenate;
    } });
    function hyphenateAttr(str) {
      let hyphencase = (0, shared_1.hyphenate)(str);
      if (str.length && str[0] !== str[0].toLowerCase()) {
        hyphencase = "-" + hyphencase;
      }
      return hyphencase;
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/globalTypes.js
var require_globalTypes = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/globalTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateGlobalTypes = generateGlobalTypes;
    var shared_1 = require_shared();
    function generateGlobalTypes(lib, target, strictTemplates) {
      const fnPropsType = `(K extends { $props: infer Props } ? Props : any)${strictTemplates ? "" : " & Record<string, unknown>"}`;
      let text6 = ``;
      if (target < 3.5) {
        text6 += `
; declare module '${lib}' {
	export interface GlobalComponents { }
	export interface GlobalDirectives { }
}`;
      }
      text6 += `
; declare global {
	const __VLS_intrinsicElements: __VLS_IntrinsicElements;
	const __VLS_directiveBindingRestFields: { instance: null, oldValue: null, modifiers: any, dir: any };
	const __VLS_unref: typeof import('${lib}').unref;

	const __VLS_nativeElements = {
		...{} as SVGElementTagNameMap,
		...{} as HTMLElementTagNameMap,
	};

	type __VLS_IntrinsicElements = ${target >= 3.3 ? `import('${lib}/jsx-runtime').JSX.IntrinsicElements;` : `globalThis.JSX.IntrinsicElements;`}
	type __VLS_Element = ${target >= 3.3 ? `import('${lib}/jsx-runtime').JSX.Element;` : `globalThis.JSX.Element;`}
	type __VLS_GlobalComponents = ${target >= 3.5 ? `import('${lib}').GlobalComponents;` : `import('${lib}').GlobalComponents & Pick<typeof import('${lib}'), 'Transition' | 'TransitionGroup' | 'KeepAlive' | 'Suspense' | 'Teleport'>;`}
	type __VLS_GlobalDirectives = import('${lib}').GlobalDirectives;
	type __VLS_IsAny<T> = 0 extends 1 & T ? true : false;
	type __VLS_PickNotAny<A, B> = __VLS_IsAny<A> extends true ? B : A;
	type __VLS_unknownDirective = (arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown) => void;
	type __VLS_WithComponent<N0 extends string, LocalComponents, N1 extends string, N2 extends string, N3 extends string> =
		N1 extends keyof LocalComponents ? N1 extends N0 ? Pick<LocalComponents, N0 extends keyof LocalComponents ? N0 : never> : { [K in N0]: LocalComponents[N1] } :
		N2 extends keyof LocalComponents ? N2 extends N0 ? Pick<LocalComponents, N0 extends keyof LocalComponents ? N0 : never> : { [K in N0]: LocalComponents[N2] } :
		N3 extends keyof LocalComponents ? N3 extends N0 ? Pick<LocalComponents, N0 extends keyof LocalComponents ? N0 : never> : { [K in N0]: LocalComponents[N3] } :
		N1 extends keyof __VLS_GlobalComponents ? N1 extends N0 ? Pick<__VLS_GlobalComponents, N0 extends keyof __VLS_GlobalComponents ? N0 : never> : { [K in N0]: __VLS_GlobalComponents[N1] } :
		N2 extends keyof __VLS_GlobalComponents ? N2 extends N0 ? Pick<__VLS_GlobalComponents, N0 extends keyof __VLS_GlobalComponents ? N0 : never> : { [K in N0]: __VLS_GlobalComponents[N2] } :
		N3 extends keyof __VLS_GlobalComponents ? N3 extends N0 ? Pick<__VLS_GlobalComponents, N0 extends keyof __VLS_GlobalComponents ? N0 : never> : { [K in N0]: __VLS_GlobalComponents[N3] } :
		${strictTemplates ? "{}" : "{ [K in N0]: unknown }"}
	type __VLS_FunctionalComponentProps<T, K> =
		'__ctx' extends keyof __VLS_PickNotAny<K, {}> ? K extends { __ctx?: { props?: infer P } } ? NonNullable<P> : never
		: T extends (props: infer P, ...args: any) => any ? P :
		{};
	type __VLS_IsFunction<T, K> = K extends keyof T
		? __VLS_IsAny<T[K]> extends false
		? unknown extends T[K]
		? false
		: true
		: false
		: false;
	// fix https://github.com/vuejs/language-tools/issues/926
	type __VLS_UnionToIntersection<U> = (U extends unknown ? (arg: U) => unknown : never) extends ((arg: infer P) => unknown) ? P : never;
	type __VLS_OverloadUnionInner<T, U = unknown> = U & T extends (...args: infer A) => infer R
		? U extends T
		? never
		: __VLS_OverloadUnionInner<T, Pick<T, keyof T> & U & ((...args: A) => R)> | ((...args: A) => R)
		: never;
	type __VLS_OverloadUnion<T> = Exclude<
		__VLS_OverloadUnionInner<(() => never) & T>,
		T extends () => never ? never : () => never
	>;
	type __VLS_ConstructorOverloads<T> = __VLS_OverloadUnion<T> extends infer F
		? F extends (event: infer E, ...args: infer A) => any
		? { [K in E & string]: (...args: A) => void; }
		: never
		: never;
	type __VLS_NormalizeEmits<T> = __VLS_PrettifyGlobal<
		__VLS_UnionToIntersection<
			__VLS_ConstructorOverloads<T> & {
				[K in keyof T]: T[K] extends any[] ? { (...args: T[K]): void } : never
			}
		>
	>;
	type __VLS_PrettifyGlobal<T> = { [K in keyof T]: T[K]; } & {};
	type __VLS_PickFunctionalComponentCtx<T, K> = NonNullable<__VLS_PickNotAny<
		'__ctx' extends keyof __VLS_PickNotAny<K, {}> ? K extends { __ctx?: infer Ctx } ? Ctx : never : any
		, T extends (props: any, ctx: infer Ctx) => any ? Ctx : any
	>>;
	type __VLS_UseTemplateRef<T> = Readonly<import('${lib}').ShallowRef<T | null>>;

	function __VLS_getVForSourceType(source: number): [number, number, number][];
	function __VLS_getVForSourceType(source: string): [string, number, number][];
	function __VLS_getVForSourceType<T extends any[]>(source: T): [
		item: T[number],
		key: number,
		index: number,
	][];
	function __VLS_getVForSourceType<T extends { [Symbol.iterator](): Iterator<any> }>(source: T): [
		item: T extends { [Symbol.iterator](): Iterator<infer T1> } ? T1 : never, 
		key: number,
		index: undefined,
	][];
	// #3845
	function __VLS_getVForSourceType<T extends number | { [Symbol.iterator](): Iterator<any> }>(source: T): [
		item: number | (Exclude<T, number> extends { [Symbol.iterator](): Iterator<infer T1> } ? T1 : never), 
		key: number,
		index: undefined,
	][];
	function __VLS_getVForSourceType<T>(source: T): [
		item: T[keyof T],
		key: keyof T,
		index: number,
	][];
	// @ts-ignore
	function __VLS_getSlotParams<T>(slot: T): Parameters<__VLS_PickNotAny<NonNullable<T>, (...args: any[]) => any>>;
	// @ts-ignore
	function __VLS_getSlotParam<T>(slot: T): Parameters<__VLS_PickNotAny<NonNullable<T>, (...args: any[]) => any>>[0];
	function __VLS_asFunctionalDirective<T>(dir: T): T extends import('${lib}').ObjectDirective
		? NonNullable<T['created' | 'beforeMount' | 'mounted' | 'beforeUpdate' | 'updated' | 'beforeUnmount' | 'unmounted']>
		: T extends (...args: any) => any
			? T
			: __VLS_unknownDirective;
	function __VLS_withScope<T, K>(ctx: T, scope: K): ctx is T & K;
	function __VLS_makeOptional<T>(t: T): { [K in keyof T]?: T[K] };
	function __VLS_nonNullable<T>(t: T): T extends null | undefined ? never : T;
	function __VLS_asFunctionalComponent<T, K = T extends new (...args: any) => any ? InstanceType<T> : unknown>(t: T, instance?: K):
		T extends new (...args: any) => any
		? (props: ${fnPropsType}, ctx?: any) => __VLS_Element & { __ctx?: {
			attrs?: any,
			slots?: K extends { ${(0, shared_1.getSlotsPropertyName)(target)}: infer Slots } ? Slots : any,
			emit?: K extends { $emit: infer Emit } ? Emit : any
		} & { props?: ${fnPropsType}; expose?(exposed: K): void; } }
		: T extends () => any ? (props: {}, ctx?: any) => ReturnType<T>
		: T extends (...args: any) => any ? T
		: (_: {}${strictTemplates ? "" : " & Record<string, unknown>"}, ctx?: any) => { __ctx?: { attrs?: any, expose?: any, slots?: any, emit?: any, props?: {}${strictTemplates ? "" : " & Record<string, unknown>"} } };
	function __VLS_elementAsFunction<T>(tag: T, endTag?: T): (_: T${strictTemplates ? "" : " & Record<string, unknown>"}) => void;
	function __VLS_functionalComponentArgsRest<T extends (...args: any) => any>(t: T): 2 extends Parameters<T>['length'] ? [any] : [];
	function __VLS_normalizeSlot<S>(s: S): S extends () => infer R ? (props: {}) => R : S;
	function __VLS_tryAsConstant<const T>(t: T): T;
}
`;
      return text6;
    }
  }
});

// node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
function createRoot(children, source = "") {
  return {
    type: 0,
    source,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: [],
    temps: 0,
    codegenNode: void 0,
    loc: locStub
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key2, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key2) ? createSimpleExpression(key2, true) : key2,
    value
  };
}
function createSimpleExpression(content3, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content: content3,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content3, loc) {
  return {
    type: 5,
    loc,
    content: isString(content3) ? createSimpleExpression(content3, false, loc) : content3
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index2, value, needPauseTracking = false, inVOnce = false) {
  return {
    type: 20,
    index: index2,
    value,
    needPauseTracking,
    inVOnce,
    needArraySpread: false,
    loc: locStub
  };
}
function createBlockStatement(body3) {
  return {
    type: 21,
    body: body3,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node2, { helper, removeHelper, inSSR }) {
  if (!node2.isBlock) {
    node2.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node2.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node2.isComponent));
  }
}
function isTagStartChar(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
  return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
  const ret = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
function getCompatValue(key2, { compatConfig }) {
  const value = compatConfig && compatConfig[key2];
  if (key2 === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key2, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key2, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key2, context, loc, ...args) {
  const enabled = isCompatEnabled(key2, context);
  if (enabled) {
    warnDeprecation(key2, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key2, context, loc, ...args) {
  const val = getCompatValue(key2, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link: link3 } = deprecationData[key2];
  const msg = `(deprecation ${key2}) ${typeof message === "function" ? message(...args) : message}${link3 ? `
  Details: ${link3}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key2;
  if (loc) err.loc = loc;
  context.onWarn(err);
}
function defaultOnError(error2) {
  throw error2;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code3, loc, messages, additionalMessage) {
  const msg = true ? (messages || errorMessages)[code3] + (additionalMessage || ``) : `https://vuejs.org/error-reference/#compiler-${code3}`;
  const error2 = new SyntaxError(String(msg));
  error2.code = code3;
  error2.loc = loc;
  return error2;
}
function walkIdentifiers(root4, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p2 = parentStack[i];
      if (p2.type === "AssignmentExpression") {
        return true;
      } else if (p2.type !== "ObjectProperty" && !p2.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function isInNewExpression(parentStack) {
  let i = parentStack.length;
  while (i--) {
    const p2 = parentStack[i];
    if (p2.type === "NewExpression") {
      return true;
    } else if (p2.type !== "MemberExpression") {
      break;
    }
  }
  return false;
}
function walkFunctionParams(node2, onIdent) {
  for (const p2 of node2.params) {
    for (const id of extractIdentifiers(p2)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare) continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id) continue;
      onIdent(stmt.id);
    } else if (isForStatement(stmt)) {
      walkForStatement(stmt, true, onIdent);
    }
  }
}
function isForStatement(stmt) {
  return stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement";
}
function walkForStatement(stmt, isVar, onIdent) {
  const variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
  if (variable && variable.type === "VariableDeclaration" && (variable.kind === "var" ? isVar : false)) {
    for (const decl of variable.declarations) {
      for (const id of extractIdentifiers(decl.id)) {
        onIdent(id);
      }
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element3) => {
        if (element3) extractIdentifiers(element3, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function unwrapTSNode(node2) {
  if (TS_NODE_TYPES.includes(node2.type)) {
    return unwrapTSNode(node2.expression);
  } else {
    return node2;
  }
}
function isCoreComponent(tag) {
  switch (tag) {
    case "Teleport":
    case "teleport":
      return TELEPORT;
    case "Suspense":
    case "suspense":
      return SUSPENSE;
    case "KeepAlive":
    case "keep-alive":
      return KEEP_ALIVE;
    case "BaseTransition":
    case "base-transition":
      return BASE_TRANSITION;
  }
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(
    {
      offset: pos.offset,
      line: pos.line,
      column: pos.column
    },
    source,
    numberOfCharacters
  );
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node2, name, allowEmpty = false) {
  for (let i = 0; i < node2.props.length; i++) {
    const p2 = node2.props[i];
    if (p2.type === 7 && (allowEmpty || p2.exp) && (isString(name) ? p2.name === name : name.test(p2.name))) {
      return p2;
    }
  }
}
function findProp(node2, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node2.props.length; i++) {
    const p2 = node2.props[i];
    if (p2.type === 6) {
      if (dynamicOnly) continue;
      if (p2.name === name && (p2.value || allowEmpty)) {
        return p2;
      }
    } else if (p2.name === "bind" && (p2.exp || allowEmpty) && isStaticArgOf(p2.arg, name)) {
      return p2;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node2) {
  return node2.props.some(
    (p2) => p2.type === 7 && p2.name === "bind" && (!p2.arg || // v-bind="obj"
    p2.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p2.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node2) {
  return node2.type === 5 || node2.type === 2;
}
function isVSlot(p2) {
  return p2.type === 7 && p2.name === "slot";
}
function isTemplateNode(node2) {
  return node2.type === 1 && node2.tagType === 3;
}
function isSlotOutlet(node2) {
  return node2.type === 1 && node2.tagType === 2;
}
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node2, prop, context) {
  let propsWithInjection;
  let props = node2.type === 13 ? node2.props : node2.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node2.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node2.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node2.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p2) => p2.key.type === 4 && p2.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node2, ids) {
  if (!node2 || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node2.type) {
    case 1:
      for (let i = 0; i < node2.props.length; i++) {
        const p2 = node2.props[i];
        if (p2.type === 7 && (hasScopeRef(p2.arg, ids) || hasScopeRef(p2.exp, ids))) {
          return true;
        }
      }
      return node2.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node2.source, ids)) {
        return true;
      }
      return node2.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node2.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node2.condition, ids)) {
        return true;
      }
      return node2.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node2.isStatic && isSimpleIdentifier(node2.content) && !!ids[node2.content];
    case 8:
      return node2.children.some((c) => isObject(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node2.content, ids);
    case 2:
    case 3:
    case 20:
      return false;
    default:
      if (true) ;
      return false;
  }
}
function getMemoedVNodeCall(node2) {
  if (node2.type === 14 && node2.callee === WITH_MEMO) {
    return node2.arguments[1].returns;
  } else {
    return node2;
  }
}
function parseForExpression(input) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch) return;
  const [, LHS, RHS] = inMatch;
  const createAliasExpression = (content3, offset, asParam = false) => {
    const start = loc.start.offset + offset;
    const end = start + content3.length;
    return createExp(
      content3,
      false,
      getLoc(start, end),
      0,
      asParam ? 1 : 0
      /* Normal */
    );
  };
  const result = {
    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(keyContent, keyOffset, true);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          ),
          true
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(valueContent, trimmedOffset, true);
  }
  return result;
}
function getSlice(start, end) {
  return currentInput.slice(start, end);
}
function endOpenTag(end) {
  if (tokenizer.inSFCRoot) {
    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
  }
  addNode(currentOpenTag);
  const { tag, ns } = currentOpenTag;
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre++;
  }
  if (currentOptions.isVoidTag(tag)) {
    onCloseTag(currentOpenTag, end);
  } else {
    stack.unshift(currentOpenTag);
    if (ns === 1 || ns === 2) {
      tokenizer.inXML = true;
    }
  }
  currentOpenTag = null;
}
function onText(content3, start, end) {
  {
    const tag = stack[0] && stack[0].tag;
    if (tag !== "script" && tag !== "style" && content3.includes("&")) {
      content3 = currentOptions.decodeEntities(content3, false);
    }
  }
  const parent = stack[0] || currentRoot;
  const lastNode = parent.children[parent.children.length - 1];
  if (lastNode && lastNode.type === 2) {
    lastNode.content += content3;
    setLocEnd(lastNode.loc, end);
  } else {
    parent.children.push({
      type: 2,
      content: content3,
      loc: getLoc(start, end)
    });
  }
}
function onCloseTag(el, end, isImplied = false) {
  if (isImplied) {
    setLocEnd(el.loc, backTrack(end, 60));
  } else {
    setLocEnd(el.loc, lookAhead(end, 62) + 1);
  }
  if (tokenizer.inSFCRoot) {
    if (el.children.length) {
      el.innerLoc.end = extend2({}, el.children[el.children.length - 1].loc.end);
    } else {
      el.innerLoc.end = extend2({}, el.innerLoc.start);
    }
    el.innerLoc.source = getSlice(
      el.innerLoc.start.offset,
      el.innerLoc.end.offset
    );
  }
  const { tag, ns, children } = el;
  if (!inVPre) {
    if (tag === "slot") {
      el.tagType = 2;
    } else if (isFragmentTemplate(el)) {
      el.tagType = 3;
    } else if (isComponent(el)) {
      el.tagType = 1;
    }
  }
  if (!tokenizer.inRCDATA) {
    el.children = condenseWhitespace(children);
  }
  if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
    const first = children[0];
    if (first && first.type === 2) {
      first.content = first.content.replace(/^\r?\n/, "");
    }
  }
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre--;
  }
  if (currentVPreBoundary === el) {
    inVPre = tokenizer.inVPre = false;
    currentVPreBoundary = null;
  }
  if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
    tokenizer.inXML = false;
  }
  {
    const props = el.props;
    if (isCompatEnabled(
      "COMPILER_V_IF_V_FOR_PRECEDENCE",
      currentOptions
    )) {
      let hasIf = false;
      let hasFor = false;
      for (let i = 0; i < props.length; i++) {
        const p2 = props[i];
        if (p2.type === 7) {
          if (p2.name === "if") {
            hasIf = true;
          } else if (p2.name === "for") {
            hasFor = true;
          }
        }
        if (hasIf && hasFor) {
          warnDeprecation(
            "COMPILER_V_IF_V_FOR_PRECEDENCE",
            currentOptions,
            el.loc
          );
          break;
        }
      }
    }
    if (!tokenizer.inSFCRoot && isCompatEnabled(
      "COMPILER_NATIVE_TEMPLATE",
      currentOptions
    ) && el.tag === "template" && !isFragmentTemplate(el)) {
      warnDeprecation(
        "COMPILER_NATIVE_TEMPLATE",
        currentOptions,
        el.loc
      );
      const parent = stack[0] || currentRoot;
      const index2 = parent.children.indexOf(el);
      parent.children.splice(index2, 1, ...el.children);
    }
    const inlineTemplateProp = props.find(
      (p2) => p2.type === 6 && p2.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      currentOptions,
      inlineTemplateProp.loc
    ) && el.children.length) {
      inlineTemplateProp.value = {
        type: 2,
        content: getSlice(
          el.children[0].loc.start.offset,
          el.children[el.children.length - 1].loc.end.offset
        ),
        loc: inlineTemplateProp.loc
      };
    }
  }
}
function lookAhead(index2, c) {
  let i = index2;
  while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1) i++;
  return i;
}
function backTrack(index2, c) {
  let i = index2;
  while (currentInput.charCodeAt(i) !== c && i >= 0) i--;
  return i;
}
function isFragmentTemplate({ tag, props }) {
  if (tag === "template") {
    for (let i = 0; i < props.length; i++) {
      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
        return true;
      }
    }
  }
  return false;
}
function isComponent({ tag, props }) {
  if (currentOptions.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p2 = props[i];
    if (p2.type === 6) {
      if (p2.name === "is" && p2.value) {
        if (p2.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p2.loc
        )) {
          return true;
        }
      }
    } else if (
      // :is on plain element - only treat as component in compat mode
      p2.name === "bind" && isStaticArgOf(p2.arg, "is") && checkCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        currentOptions,
        p2.loc
      )
    ) {
      return true;
    }
  }
  return false;
}
function isUpperCase(c) {
  return c > 64 && c < 91;
}
function condenseWhitespace(nodes, tag) {
  const shouldCondense = currentOptions.whitespace !== "preserve";
  let removedWhitespace = false;
  for (let i = 0; i < nodes.length; i++) {
    const node2 = nodes[i];
    if (node2.type === 2) {
      if (!inPre) {
        if (isAllWhitespace(node2.content)) {
          const prev = nodes[i - 1] && nodes[i - 1].type;
          const next = nodes[i + 1] && nodes[i + 1].type;
          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node2.content)))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node2.content = " ";
          }
        } else if (shouldCondense) {
          node2.content = condense(node2.content);
        }
      } else {
        node2.content = node2.content.replace(windowsNewlineRE, "\n");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function isAllWhitespace(str) {
  for (let i = 0; i < str.length; i++) {
    if (!isWhitespace(str.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function hasNewlineChar(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c === 10 || c === 13) {
      return true;
    }
  }
  return false;
}
function condense(str) {
  let ret = "";
  let prevCharIsWhitespace = false;
  for (let i = 0; i < str.length; i++) {
    if (isWhitespace(str.charCodeAt(i))) {
      if (!prevCharIsWhitespace) {
        ret += " ";
        prevCharIsWhitespace = true;
      }
    } else {
      ret += str[i];
      prevCharIsWhitespace = false;
    }
  }
  return ret;
}
function addNode(node2) {
  (stack[0] || currentRoot).children.push(node2);
}
function getLoc(start, end) {
  return {
    start: tokenizer.getPos(start),
    // @ts-expect-error allow late attachment
    end: end == null ? end : tokenizer.getPos(end),
    // @ts-expect-error allow late attachment
    source: end == null ? end : getSlice(start, end)
  };
}
function cloneLoc(loc) {
  return getLoc(loc.start.offset, loc.end.offset);
}
function setLocEnd(loc, end) {
  loc.end = tokenizer.getPos(end);
  loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
  const attr = {
    type: 6,
    name: dir.rawName,
    nameLoc: getLoc(
      dir.loc.start.offset,
      dir.loc.start.offset + dir.rawName.length
    ),
    value: void 0,
    loc: dir.loc
  };
  if (dir.exp) {
    const loc = dir.exp.loc;
    if (loc.end.offset < dir.loc.end.offset) {
      loc.start.offset--;
      loc.start.column--;
      loc.end.offset++;
      loc.end.column++;
    }
    attr.value = {
      type: 2,
      content: dir.exp.content,
      loc
    };
  }
  return attr;
}
function createExp(content3, isStatic = false, loc, constType = 0, parseMode = 0) {
  const exp = createSimpleExpression(content3, isStatic, loc, constType);
  return exp;
}
function emitError(code3, index2, message) {
  currentOptions.onError(
    createCompilerError(code3, getLoc(index2, index2), void 0, message)
  );
}
function reset() {
  tokenizer.reset();
  currentOpenTag = null;
  currentProp = null;
  currentAttrValue = "";
  currentAttrStartIndex = -1;
  currentAttrEndIndex = -1;
  stack.length = 0;
}
function baseParse(input, options) {
  reset();
  currentInput = input;
  currentOptions = extend2({}, defaultParserOptions);
  if (options) {
    let key2;
    for (key2 in options) {
      if (options[key2] != null) {
        currentOptions[key2] = options[key2];
      }
    }
  }
  if (true) {
    if (!currentOptions.decodeEntities) {
      throw new Error(
        `[@vue/compiler-core] decodeEntities option is required in browser builds.`
      );
    }
  }
  tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
  const delimiters = options && options.delimiters;
  if (delimiters) {
    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
  }
  const root4 = currentRoot = createRoot([], input);
  tokenizer.parse(currentInput);
  root4.loc = getLoc(0, input.length);
  root4.children = condenseWhitespace(root4.children);
  currentRoot = null;
  return root4;
}
function cacheStatic(root4, context) {
  walk(
    root4,
    void 0,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root4, root4.children[0])
  );
}
function isSingleElementRoot(root4, child) {
  const { children } = root4;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node2, parent, context, doNotHoistNode = false, inFor = false) {
  const { children } = node2;
  const toCache = [];
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1;
          toCache.push(child);
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = codegenNode.patchFlag;
          if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType >= 2) {
        toCache.push(child);
        continue;
      }
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, node2, context, false, inFor);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, node2, context, child.children.length === 1, true);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          node2,
          context,
          child.branches[i2].children.length === 1,
          inFor
        );
      }
    }
  }
  let cachedAsArray = false;
  const slotCacheKeys = [];
  if (toCache.length === children.length && node2.type === 1) {
    if (node2.tagType === 0 && node2.codegenNode && node2.codegenNode.type === 13 && isArray(node2.codegenNode.children)) {
      node2.codegenNode.children = getCacheExpression(
        createArrayExpression(node2.codegenNode.children)
      );
      cachedAsArray = true;
    } else if (node2.tagType === 1 && node2.codegenNode && node2.codegenNode.type === 13 && node2.codegenNode.children && !isArray(node2.codegenNode.children) && node2.codegenNode.children.type === 15) {
      const slot = getSlotNode(node2.codegenNode, "default");
      if (slot) {
        slotCacheKeys.push(context.cached.length);
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    } else if (node2.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
      const slotName = findDir(node2, "slot", true);
      const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
      if (slot) {
        slotCacheKeys.push(context.cached.length);
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    }
  }
  if (!cachedAsArray) {
    for (const child of toCache) {
      slotCacheKeys.push(context.cached.length);
      child.codegenNode = context.cache(child.codegenNode);
    }
  }
  if (slotCacheKeys.length && node2.type === 1 && node2.tagType === 1 && node2.codegenNode && node2.codegenNode.type === 13 && node2.codegenNode.children && !isArray(node2.codegenNode.children) && node2.codegenNode.children.type === 15) {
    node2.codegenNode.children.properties.push(
      createObjectProperty(
        `__`,
        createSimpleExpression(JSON.stringify(slotCacheKeys), false)
      )
    );
  }
  function getCacheExpression(value) {
    const exp = context.cache(value);
    if (inFor && context.hmr) {
      exp.needArraySpread = true;
    }
    return exp;
  }
  function getSlotNode(node22, name) {
    if (node22.children && !isArray(node22.children) && node22.children.type === 15) {
      const slot = node22.children.properties.find(
        (p2) => p2.key === name || p2.key.content === name
      );
      return slot && slot.value;
    }
  }
  if (toCache.length && context.transformHoist) {
    context.transformHoist(children, context, node2);
  }
}
function getConstantType(node2, context) {
  const { constantCache } = context;
  switch (node2.type) {
    case 1:
      if (node2.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node2);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node2.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node2.tag !== "svg" && node2.tag !== "foreignObject" && node2.tag !== "math") {
        return 0;
      }
      if (codegenNode.patchFlag === void 0) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node2, context);
        if (generatedPropsType === 0) {
          constantCache.set(node2, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node2.children.length; i++) {
          const childType = getConstantType(node2.children[i], context);
          if (childType === 0) {
            constantCache.set(node2, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node2.props.length; i++) {
            const p2 = node2.props[i];
            if (p2.type === 7 && p2.name === "bind" && p2.exp) {
              const expType = getConstantType(p2.exp, context);
              if (expType === 0) {
                constantCache.set(node2, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node2.props.length; i++) {
            const p2 = node2.props[i];
            if (p2.type === 7) {
              constantCache.set(node2, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node2, returnType2);
        return returnType2;
      } else {
        constantCache.set(node2, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node2.content, context);
    case 4:
      return node2.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node2.children.length; i++) {
        const child = node2.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    case 20:
      return 2;
    default:
      if (true) ;
      return 0;
  }
}
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node2, context) {
  let returnType = 3;
  const props = getNodeProps(node2);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key: key2, value } = properties[i];
      const keyType = getConstantType(key2, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node2) {
  const codegenNode = node2.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function createTransformContext(root4, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP,
  isCustomElement = NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    filename,
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root: root4,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    cached: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: root4,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node2) {
      if (true) {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node2;
    },
    removeNode(node2) {
      if (!context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list4 = context.parent.children;
      const removalIndex = node2 ? list4.indexOf(node2) : context.currentNode ? context.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node2 || node2 === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: NOOP,
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp)) exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false, inVOnce = false) {
      const cacheExp = createCacheExpression(
        context.cached.length,
        exp,
        isVNode,
        inVOnce
      );
      context.cached.push(cacheExp);
      return cacheExp;
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root4, options) {
  const context = createTransformContext(root4, options);
  traverseNode(root4, context);
  if (options.hoistStatic) {
    cacheStatic(root4, context);
  }
  if (!options.ssr) {
    createRootCodegen(root4, context);
  }
  root4.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root4.components = [...context.components];
  root4.directives = [...context.directives];
  root4.imports = context.imports;
  root4.hoists = context.hoists;
  root4.temps = context.temps;
  root4.cached = context.cached;
  root4.transformed = true;
  {
    root4.filters = [...context.filters];
  }
}
function createRootCodegen(root4, context) {
  const { helper } = context;
  const { children } = root4;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root4, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root4.codegenNode = codegenNode;
    } else {
      root4.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    if (children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
    }
    root4.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root4.children,
      patchFlag,
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  } else ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child)) continue;
    context.grandParent = context.parent;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node2, context) {
  context.currentNode = node2;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node2, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node2 = context.currentNode;
    }
  }
  switch (node2.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node2.branches.length; i2++) {
        traverseNode(node2.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node2, context);
      break;
  }
  context.currentNode = node2;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches2 = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node2, context) => {
    if (node2.type === 1) {
      const { props } = node2;
      if (node2.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches2(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node2, prop, context);
          if (onExit) exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key2) {
      return `_${helperNameMap[key2]}`;
    },
    push(code3, newlineIndex = -2, node2) {
      context.code += code3;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push(
      "\n" + `  `.repeat(n),
      0
      /* Start */
    );
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  const {
    mode,
    push: push2,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push2(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push2(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push2(
        `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
        -1
        /* End */
      );
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push2(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push2(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push2(
      `
`,
      0
      /* Start */
    );
    newline();
  }
  if (!ssr) {
    push2(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push2(`null`);
  }
  if (useWithBlock) {
    deindent();
    push2(`}`);
  }
  deindent();
  push2(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push: push2,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push2(
        `const _Vue = ${VueBinding}
`,
        -1
        /* End */
      );
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push2(
          `const { ${staticHelpers} } = _Vue
`,
          -1
          /* End */
        );
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push2(`return `);
}
function genAssets(assets, type, { helper, push: push2, newline, isTS }) {
  const resolver2 = helper(
    type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push2(
      `const ${toValidAssetId(id, type)} = ${resolver2}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push: push2, newline } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push2(`const _hoisted_${i + 1} = `);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText(n) {
  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || nodes.some((n) => isArray(n) || !isText(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push: push2, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node2 = nodes[i];
    if (isString(node2)) {
      push2(
        node2,
        -3
        /* Unknown */
      );
    } else if (isArray(node2)) {
      genNodeListAsArray(node2, context);
    } else {
      genNode(node2, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push2(",");
        newline();
      } else {
        comma && push2(", ");
      }
    }
  }
}
function genNode(node2, context) {
  if (isString(node2)) {
    context.push(
      node2,
      -3
      /* Unknown */
    );
    return;
  }
  if (isSymbol(node2)) {
    context.push(context.helper(node2));
    return;
  }
  switch (node2.type) {
    case 1:
    case 9:
    case 11:
      assert(
        node2.codegenNode != null,
        `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
      );
      genNode(node2.codegenNode, context);
      break;
    case 2:
      genText(node2, context);
      break;
    case 4:
      genExpression(node2, context);
      break;
    case 5:
      genInterpolation(node2, context);
      break;
    case 12:
      genNode(node2.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node2, context);
      break;
    case 3:
      genComment(node2, context);
      break;
    case 13:
      genVNodeCall(node2, context);
      break;
    case 14:
      genCallExpression(node2, context);
      break;
    case 15:
      genObjectExpression(node2, context);
      break;
    case 17:
      genArrayExpression(node2, context);
      break;
    case 18:
      genFunctionExpression(node2, context);
      break;
    case 19:
      genConditionalExpression(node2, context);
      break;
    case 20:
      genCacheExpression(node2, context);
      break;
    case 21:
      genNodeList(node2.body, context, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (true) {
        assert(false, `unhandled codegen node type: ${node2.type}`);
        const exhaustiveCheck = node2;
        return exhaustiveCheck;
      }
  }
}
function genText(node2, context) {
  context.push(JSON.stringify(node2.content), -3, node2);
}
function genExpression(node2, context) {
  const { content: content3, isStatic } = node2;
  context.push(
    isStatic ? JSON.stringify(content3) : content3,
    -3,
    node2
  );
}
function genInterpolation(node2, context) {
  const { push: push2, helper, pure } = context;
  if (pure) push2(PURE_ANNOTATION);
  push2(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node2.content, context);
  push2(`)`);
}
function genCompoundExpression(node2, context) {
  for (let i = 0; i < node2.children.length; i++) {
    const child = node2.children[i];
    if (isString(child)) {
      context.push(
        child,
        -3
        /* Unknown */
      );
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node2, context) {
  const { push: push2 } = context;
  if (node2.type === 8) {
    push2(`[`);
    genCompoundExpression(node2, context);
    push2(`]`);
  } else if (node2.isStatic) {
    const text6 = isSimpleIdentifier(node2.content) ? node2.content : JSON.stringify(node2.content);
    push2(text6, -2, node2);
  } else {
    push2(`[${node2.content}]`, -3, node2);
  }
}
function genComment(node2, context) {
  const { push: push2, helper, pure } = context;
  if (pure) {
    push2(PURE_ANNOTATION);
  }
  push2(
    `${helper(CREATE_COMMENT)}(${JSON.stringify(node2.content)})`,
    -3,
    node2
  );
}
function genVNodeCall(node2, context) {
  const { push: push2, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2
  } = node2;
  let patchFlagString;
  if (patchFlag) {
    if (true) {
      if (patchFlag < 0) {
        patchFlagString = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
      } else {
        const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
        patchFlagString = patchFlag + ` /* ${flagNames} */`;
      }
    } else {
      patchFlagString = String(patchFlag);
    }
  }
  if (directives) {
    push2(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push2(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push2(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push2(helper(callHelper) + `(`, -2, node2);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlagString, dynamicProps]),
    context
  );
  push2(`)`);
  if (isBlock) {
    push2(`)`);
  }
  if (directives) {
    push2(`, `);
    genNode(directives, context);
    push2(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null) break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node2, context) {
  const { push: push2, helper, pure } = context;
  const callee = isString(node2.callee) ? node2.callee : helper(node2.callee);
  if (pure) {
    push2(PURE_ANNOTATION);
  }
  push2(callee + `(`, -2, node2);
  genNodeList(node2.arguments, context);
  push2(`)`);
}
function genObjectExpression(node2, context) {
  const { push: push2, indent, deindent, newline } = context;
  const { properties } = node2;
  if (!properties.length) {
    push2(`{}`, -2, node2);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p2) => p2.value.type !== 4);
  push2(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key: key2, value } = properties[i];
    genExpressionAsPropertyKey(key2, context);
    push2(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push2(`,`);
      newline();
    }
  }
  multilines && deindent();
  push2(multilines ? `}` : ` }`);
}
function genArrayExpression(node2, context) {
  genNodeListAsArray(node2.elements, context);
}
function genFunctionExpression(node2, context) {
  const { push: push2, indent, deindent } = context;
  const { params, returns, body: body3, newline, isSlot } = node2;
  if (isSlot) {
    push2(`_${helperNameMap[WITH_CTX]}(`);
  }
  push2(`(`, -2, node2);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push2(`) => `);
  if (newline || body3) {
    push2(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push2(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body3) {
    genNode(body3, context);
  }
  if (newline || body3) {
    deindent();
    push2(`}`);
  }
  if (isSlot) {
    if (node2.isNonScopedSlot) {
      push2(`, undefined, true`);
    }
    push2(`)`);
  }
}
function genConditionalExpression(node2, context) {
  const { test, consequent, alternate, newline: needNewline } = node2;
  const { push: push2, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push2(`(`);
    genExpression(test, context);
    needsParens && push2(`)`);
  } else {
    push2(`(`);
    genNode(test, context);
    push2(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push2(` `);
  push2(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push2(` `);
  push2(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node2, context) {
  const { push: push2, helper, indent, deindent, newline } = context;
  const { needPauseTracking, needArraySpread } = node2;
  if (needArraySpread) {
    push2(`[...(`);
  }
  push2(`_cache[${node2.index}] || (`);
  if (needPauseTracking) {
    indent();
    push2(`${helper(SET_BLOCK_TRACKING)}(-1`);
    if (node2.inVOnce) push2(`, true`);
    push2(`),`);
    newline();
    push2(`(`);
  }
  push2(`_cache[${node2.index}] = `);
  genNode(node2.value, context);
  if (needPauseTracking) {
    push2(`).cacheIndex = ${node2.index},`);
    newline();
    push2(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push2(`_cache[${node2.index}]`);
    deindent();
  }
  push2(`)`);
  if (needArraySpread) {
    push2(`)]`);
  }
}
function validateBrowserExpression(node2, context, asParams = false, asRawStatements = false) {
  const exp = node2.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(
      asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`
    );
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(
      createCompilerError(
        45,
        node2.loc,
        void 0,
        message
      )
    );
  }
}
function processExpression(node2, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (true) {
      validateBrowserExpression(node2, context, asParams, asRawStatements);
    }
    return node2;
  }
}
function stringifyExpression(exp) {
  if (isString(exp)) {
    return exp;
  } else if (exp.type === 4) {
    return exp.content;
  } else {
    return exp.children.map(stringifyExpression).join("");
  }
}
function processIf(node2, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node2.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node2, dir);
    const ifNode = {
      type: 9,
      loc: cloneLoc(node2.loc),
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings2 = context.parent.children;
    const comments = [];
    let i = siblings2.indexOf(node2);
    while (i-- >= -1) {
      const sibling = siblings2[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node2.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch(node2, dir);
        if (comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(context.parent && context.parent.type === 1 && (context.parent.tag === "transition" || context.parent.tag === "Transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        if (true) {
          const key2 = branch.userKey;
          if (key2) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key2)) {
                context.onError(
                  createCompilerError(
                    29,
                    branch.userKey.loc
                  )
                );
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit) onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node2.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node2, dir) {
  const isTemplateIf = node2.tagType === 3;
  return {
    type: 10,
    loc: node2.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node2, "for") ? node2.children : [node2],
    userKey: findProp(node2, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
        true ? '"v-if"' : '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      if (!branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
      }
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag,
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node2) {
  while (true) {
    if (node2.type === 19) {
      if (node2.alternate.type === 19) {
        node2 = node2.alternate;
      } else {
        return node2;
      }
    } else if (node2.type === 20) {
      node2 = node2.value;
    }
  }
}
function processFor(node2, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  finalizeForParseResult(parseResult, context);
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key: key2, index: index2 } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key2,
    objectIndexAlias: index2,
    parseResult,
    children: isTemplateNode(node2) ? node2.children : [node2]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit) onExit();
  };
}
function finalizeForParseResult(result, context) {
  if (result.finalized) return;
  if (true) {
    validateBrowserExpression(result.source, context);
    if (result.key) {
      validateBrowserExpression(
        result.key,
        context,
        true
      );
    }
    if (result.index) {
      validateBrowserExpression(
        result.index,
        context,
        true
      );
    }
    if (result.value) {
      validateBrowserExpression(
        result.value,
        context,
        true
      );
    }
  }
  result.finalized = true;
}
function createForLoopParams({ value, key: key2, index: index2 }, memoArgs = []) {
  return createParamsList([value, key2, index2, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i]) break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
function buildSlots(node2, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node2;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node2, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, /^(else-)?if$/)) {
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.forParseResult;
      if (parseResult) {
        finalizeForParseResult(parseResult, context);
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(
            32,
            vFor.loc
          )
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, void 0, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some((node22) => isNonWhitespaceContent(node22))) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node2.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``),
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index2) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ];
  if (index2 != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index2), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches)) return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node2) {
  if (node2.type !== 2 && node2.type !== 12)
    return true;
  return node2.type === 2 ? !!node2.content.trim() : isNonWhitespaceContent(node2.content);
}
function resolveComponentType(node2, context, ssr = false) {
  let { tag } = node2;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(
    node2,
    "is",
    false,
    true
    /* allow empty */
  );
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context
    )) {
      let exp;
      if (isProp.type === 6) {
        exp = isProp.value && createSimpleExpression(isProp.value.content, true);
      } else {
        exp = isProp.exp;
        if (!exp) {
          exp = createSimpleExpression(`is`, false, isProp.arg.loc);
        }
      }
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr) context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node2, context, props = node2.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node2;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg) mergeArgs.push(arg);
  };
  const pushRefVForMarker = () => {
    if (context.scopes.vFor > 0) {
      properties.push(
        createObjectProperty(
          createSimpleExpression("ref_for", true),
          createSimpleExpression("true")
        )
      );
    }
  };
  const analyzePatchFlag = ({ key: key2, value }) => {
    if (isStaticExp(key2)) {
      const name = key2.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (isEventHandler && value.type === 14) {
        value = value.arguments[0];
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, nameLoc, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        pushRefVForMarker();
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(name, true, nameLoc),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc, modifiers } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref")) {
        pushRefVForMarker();
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            {
              pushMergeArg();
              if (true) {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key: key2 }) => {
                      if (key2.type !== 4 || !key2.isStatic) {
                        return true;
                      }
                      return key2.content !== "class" && key2.content !== "style" && !isOn(key2.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled(
                    "COMPILER_V_BIND_OBJECT_ORDER",
                    context,
                    loc
                  );
                }
              }
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            pushRefVForMarker();
            pushMergeArg();
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent2 ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      if (isVBind && modifiers.some((mod) => mod.content === "prop")) {
        patchFlag |= 32;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node2, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key2 = propsExpression.properties[i].key;
          if (isStaticExp(key2)) {
            if (key2.content === "class") {
              classKeyIndex = i;
            } else if (key2.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key2.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp) dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
function processSlotOutlet(node2, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node2.props.length; i++) {
    const p2 = node2.props[i];
    if (p2.type === 6) {
      if (p2.value) {
        if (p2.name === "name") {
          slotName = JSON.stringify(p2.value.content);
        } else {
          p2.name = camelize(p2.name);
          nonNameProps.push(p2);
        }
      }
    } else {
      if (p2.name === "bind" && isStaticArgOf(p2.arg, "name")) {
        if (p2.exp) {
          slotName = p2.exp;
        } else if (p2.arg && p2.arg.type === 4) {
          const name = camelize(p2.arg.content);
          slotName = p2.exp = createSimpleExpression(name, false, p2.arg.loc);
        }
      } else {
        if (p2.name === "bind" && p2.arg && isStaticExp(p2.arg)) {
          p2.arg.content = camelize(p2.arg.content);
        }
        nonNameProps.push(p2);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node2,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}
function createTransformProps(props = []) {
  return { props };
}
function rewriteFilter(node2, context) {
  if (node2.type === 4) {
    parseFilter(node2, context);
  } else {
    for (let i = 0; i < node2.children.length; i++) {
      const child = node2.children[i];
      if (typeof child !== "object") continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node2, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node2, context) {
  const exp = node2.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92) inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92) inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92) inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92) inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p2;
        for (; j >= 0; j--) {
          p2 = exp.charAt(j);
          if (p2 !== " ") break;
        }
        if (!p2 || !validDivisionCharRE.test(p2)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    warnDeprecation(
      "COMPILER_FILTERS",
      context,
      node2.loc
    );
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node2.content = expression;
    node2.ast = void 0;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...true ? [transformExpression] : [],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ];
}
function baseCompile(source, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const resolvedOptions = extend2({}, options, {
    prefixIdentifiers
  });
  const ast = isString(source) ? baseParse(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    extend2({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend2(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(ast, resolvedOptions);
}
var FRAGMENT, TELEPORT, SUSPENSE, KEEP_ALIVE, BASE_TRANSITION, OPEN_BLOCK, CREATE_BLOCK, CREATE_ELEMENT_BLOCK, CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC, RESOLVE_COMPONENT, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_FILTER, WITH_DIRECTIVES, RENDER_LIST, RENDER_SLOT, CREATE_SLOTS, TO_DISPLAY_STRING, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS, TO_HANDLERS, CAMELIZE, CAPITALIZE, TO_HANDLER_KEY, SET_BLOCK_TRACKING, PUSH_SCOPE_ID, POP_SCOPE_ID, WITH_CTX, UNREF, IS_REF, WITH_MEMO, IS_MEMO_SAME, helperNameMap, Namespaces, NodeTypes, ElementTypes, ConstantTypes, locStub, defaultDelimitersOpen, defaultDelimitersClose, Sequences, Tokenizer, CompilerDeprecationTypes, deprecationData, ErrorCodes, errorMessages, isFunctionType, isStaticProperty, isStaticPropertyKey, TS_NODE_TYPES, isStaticExp, nonIdentifierRE, isSimpleIdentifier, validFirstIdentCharRE, validIdentCharRE, whitespaceRE, getExpSource, isMemberExpressionBrowser, isMemberExpressionNode, isMemberExpression, fnExpRE, isFnExpressionBrowser, isFnExpressionNode, isFnExpression, propsHelperSet, forAliasRE, defaultParserOptions, currentOptions, currentRoot, currentInput, currentOpenTag, currentProp, currentAttrValue, currentAttrStartIndex, currentAttrEndIndex, inPre, inVPre, currentVPreBoundary, stack, tokenizer, forIteratorRE, stripParensRE, specialTemplateDir, windowsNewlineRE, allowHoistedHelperSet, PURE_ANNOTATION, aliasHelper, prohibitedKeywordRE, stripStringRE, transformExpression, transformIf, transformBind, transformBindShorthand, injectPrefix, transformFor, defaultFallback, trackSlotScopes, trackVForSlotScopes, buildClientSlotFn, directiveImportMap, transformElement, transformSlotOutlet, transformOn, transformText, seen$1, transformOnce, transformModel, validDivisionCharRE, transformFilter, seen, transformMemo, BindingTypes, noopDirectiveTransform;
var init_compiler_core_esm_bundler = __esm({
  "node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"() {
    init_shared_esm_bundler();
    init_shared_esm_bundler();
    FRAGMENT = Symbol(true ? `Fragment` : ``);
    TELEPORT = Symbol(true ? `Teleport` : ``);
    SUSPENSE = Symbol(true ? `Suspense` : ``);
    KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
    BASE_TRANSITION = Symbol(
      true ? `BaseTransition` : ``
    );
    OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
    CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
    CREATE_ELEMENT_BLOCK = Symbol(
      true ? `createElementBlock` : ``
    );
    CREATE_VNODE = Symbol(true ? `createVNode` : ``);
    CREATE_ELEMENT_VNODE = Symbol(
      true ? `createElementVNode` : ``
    );
    CREATE_COMMENT = Symbol(
      true ? `createCommentVNode` : ``
    );
    CREATE_TEXT = Symbol(
      true ? `createTextVNode` : ``
    );
    CREATE_STATIC = Symbol(
      true ? `createStaticVNode` : ``
    );
    RESOLVE_COMPONENT = Symbol(
      true ? `resolveComponent` : ``
    );
    RESOLVE_DYNAMIC_COMPONENT = Symbol(
      true ? `resolveDynamicComponent` : ``
    );
    RESOLVE_DIRECTIVE = Symbol(
      true ? `resolveDirective` : ``
    );
    RESOLVE_FILTER = Symbol(
      true ? `resolveFilter` : ``
    );
    WITH_DIRECTIVES = Symbol(
      true ? `withDirectives` : ``
    );
    RENDER_LIST = Symbol(true ? `renderList` : ``);
    RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
    CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
    TO_DISPLAY_STRING = Symbol(
      true ? `toDisplayString` : ``
    );
    MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
    NORMALIZE_CLASS = Symbol(
      true ? `normalizeClass` : ``
    );
    NORMALIZE_STYLE = Symbol(
      true ? `normalizeStyle` : ``
    );
    NORMALIZE_PROPS = Symbol(
      true ? `normalizeProps` : ``
    );
    GUARD_REACTIVE_PROPS = Symbol(
      true ? `guardReactiveProps` : ``
    );
    TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
    CAMELIZE = Symbol(true ? `camelize` : ``);
    CAPITALIZE = Symbol(true ? `capitalize` : ``);
    TO_HANDLER_KEY = Symbol(
      true ? `toHandlerKey` : ``
    );
    SET_BLOCK_TRACKING = Symbol(
      true ? `setBlockTracking` : ``
    );
    PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
    POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
    WITH_CTX = Symbol(true ? `withCtx` : ``);
    UNREF = Symbol(true ? `unref` : ``);
    IS_REF = Symbol(true ? `isRef` : ``);
    WITH_MEMO = Symbol(true ? `withMemo` : ``);
    IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
    helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    Namespaces = {
      "HTML": 0,
      "0": "HTML",
      "SVG": 1,
      "1": "SVG",
      "MATH_ML": 2,
      "2": "MATH_ML"
    };
    NodeTypes = {
      "ROOT": 0,
      "0": "ROOT",
      "ELEMENT": 1,
      "1": "ELEMENT",
      "TEXT": 2,
      "2": "TEXT",
      "COMMENT": 3,
      "3": "COMMENT",
      "SIMPLE_EXPRESSION": 4,
      "4": "SIMPLE_EXPRESSION",
      "INTERPOLATION": 5,
      "5": "INTERPOLATION",
      "ATTRIBUTE": 6,
      "6": "ATTRIBUTE",
      "DIRECTIVE": 7,
      "7": "DIRECTIVE",
      "COMPOUND_EXPRESSION": 8,
      "8": "COMPOUND_EXPRESSION",
      "IF": 9,
      "9": "IF",
      "IF_BRANCH": 10,
      "10": "IF_BRANCH",
      "FOR": 11,
      "11": "FOR",
      "TEXT_CALL": 12,
      "12": "TEXT_CALL",
      "VNODE_CALL": 13,
      "13": "VNODE_CALL",
      "JS_CALL_EXPRESSION": 14,
      "14": "JS_CALL_EXPRESSION",
      "JS_OBJECT_EXPRESSION": 15,
      "15": "JS_OBJECT_EXPRESSION",
      "JS_PROPERTY": 16,
      "16": "JS_PROPERTY",
      "JS_ARRAY_EXPRESSION": 17,
      "17": "JS_ARRAY_EXPRESSION",
      "JS_FUNCTION_EXPRESSION": 18,
      "18": "JS_FUNCTION_EXPRESSION",
      "JS_CONDITIONAL_EXPRESSION": 19,
      "19": "JS_CONDITIONAL_EXPRESSION",
      "JS_CACHE_EXPRESSION": 20,
      "20": "JS_CACHE_EXPRESSION",
      "JS_BLOCK_STATEMENT": 21,
      "21": "JS_BLOCK_STATEMENT",
      "JS_TEMPLATE_LITERAL": 22,
      "22": "JS_TEMPLATE_LITERAL",
      "JS_IF_STATEMENT": 23,
      "23": "JS_IF_STATEMENT",
      "JS_ASSIGNMENT_EXPRESSION": 24,
      "24": "JS_ASSIGNMENT_EXPRESSION",
      "JS_SEQUENCE_EXPRESSION": 25,
      "25": "JS_SEQUENCE_EXPRESSION",
      "JS_RETURN_STATEMENT": 26,
      "26": "JS_RETURN_STATEMENT"
    };
    ElementTypes = {
      "ELEMENT": 0,
      "0": "ELEMENT",
      "COMPONENT": 1,
      "1": "COMPONENT",
      "SLOT": 2,
      "2": "SLOT",
      "TEMPLATE": 3,
      "3": "TEMPLATE"
    };
    ConstantTypes = {
      "NOT_CONSTANT": 0,
      "0": "NOT_CONSTANT",
      "CAN_SKIP_PATCH": 1,
      "1": "CAN_SKIP_PATCH",
      "CAN_CACHE": 2,
      "2": "CAN_CACHE",
      "CAN_STRINGIFY": 3,
      "3": "CAN_STRINGIFY"
    };
    locStub = {
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 },
      source: ""
    };
    defaultDelimitersOpen = new Uint8Array([123, 123]);
    defaultDelimitersClose = new Uint8Array([125, 125]);
    Sequences = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      // CDATA[
      CdataEnd: new Uint8Array([93, 93, 62]),
      // ]]>
      CommentEnd: new Uint8Array([45, 45, 62]),
      // `-->`
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      // `<\/script`
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      // `</style`
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
      // `</title`
      TextareaEnd: new Uint8Array([
        60,
        47,
        116,
        101,
        120,
        116,
        97,
        114,
        101,
        97
      ])
      // `</textarea
    };
    Tokenizer = class {
      constructor(stack2, cbs) {
        this.stack = stack2;
        this.cbs = cbs;
        this.state = 1;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.entityStart = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.inXML = false;
        this.inVPre = false;
        this.newlines = [];
        this.mode = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
        this.delimiterIndex = -1;
        this.currentSequence = void 0;
        this.sequenceIndex = 0;
      }
      get inSFCRoot() {
        return this.mode === 2 && this.stack.length === 0;
      }
      reset() {
        this.state = 1;
        this.mode = 0;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.currentSequence = void 0;
        this.newlines.length = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
      }
      /**
       * Generate Position object with line / column information using recorded
       * newline positions. We know the index is always going to be an already
       * processed index, so all the newlines up to this index should have been
       * recorded.
       */
      getPos(index2) {
        let line = 1;
        let column = index2 + 1;
        for (let i = this.newlines.length - 1; i >= 0; i--) {
          const newlineIndex = this.newlines[i];
          if (index2 > newlineIndex) {
            line = i + 2;
            column = index2 - newlineIndex;
            break;
          }
        }
        return {
          column,
          line,
          offset: index2
        };
      }
      peek() {
        return this.buffer.charCodeAt(this.index + 1);
      }
      stateText(c) {
        if (c === 60) {
          if (this.index > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, this.index);
          }
          this.state = 5;
          this.sectionStart = this.index;
        } else if (!this.inVPre && c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      }
      stateInterpolationOpen(c) {
        if (c === this.delimiterOpen[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterOpen.length - 1) {
            const start = this.index + 1 - this.delimiterOpen.length;
            if (start > this.sectionStart) {
              this.cbs.ontext(this.sectionStart, start);
            }
            this.state = 3;
            this.sectionStart = start;
          } else {
            this.delimiterIndex++;
          }
        } else if (this.inRCDATA) {
          this.state = 32;
          this.stateInRCDATA(c);
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInterpolation(c) {
        if (c === this.delimiterClose[0]) {
          this.state = 4;
          this.delimiterIndex = 0;
          this.stateInterpolationClose(c);
        }
      }
      stateInterpolationClose(c) {
        if (c === this.delimiterClose[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterClose.length - 1) {
            this.cbs.oninterpolation(this.sectionStart, this.index + 1);
            if (this.inRCDATA) {
              this.state = 32;
            } else {
              this.state = 1;
            }
            this.sectionStart = this.index + 1;
          } else {
            this.delimiterIndex++;
          }
        } else {
          this.state = 3;
          this.stateInterpolation(c);
        }
      }
      stateSpecialStartSequence(c) {
        const isEnd = this.sequenceIndex === this.currentSequence.length;
        const isMatch = isEnd ? (
          // If we are at the end of the sequence, make sure the tag name has ended
          isEndOfTagSection(c)
        ) : (
          // Otherwise, do a case-insensitive comparison
          (c | 32) === this.currentSequence[this.sequenceIndex]
        );
        if (!isMatch) {
          this.inRCDATA = false;
        } else if (!isEnd) {
          this.sequenceIndex++;
          return;
        }
        this.sequenceIndex = 0;
        this.state = 6;
        this.stateInTagName(c);
      }
      /** Look for an end tag. For <title> and <textarea>, also decode entities. */
      stateInRCDATA(c) {
        if (this.sequenceIndex === this.currentSequence.length) {
          if (c === 62 || isWhitespace(c)) {
            const endOfText = this.index - this.currentSequence.length;
            if (this.sectionStart < endOfText) {
              const actualIndex = this.index;
              this.index = endOfText;
              this.cbs.ontext(this.sectionStart, endOfText);
              this.index = actualIndex;
            }
            this.sectionStart = endOfText + 2;
            this.stateInClosingTagName(c);
            this.inRCDATA = false;
            return;
          }
          this.sequenceIndex = 0;
        }
        if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
          this.sequenceIndex += 1;
        } else if (this.sequenceIndex === 0) {
          if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
            if (!this.inVPre && c === this.delimiterOpen[0]) {
              this.state = 2;
              this.delimiterIndex = 0;
              this.stateInterpolationOpen(c);
            }
          } else if (this.fastForwardTo(60)) {
            this.sequenceIndex = 1;
          }
        } else {
          this.sequenceIndex = Number(c === 60);
        }
      }
      stateCDATASequence(c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
          if (++this.sequenceIndex === Sequences.Cdata.length) {
            this.state = 28;
            this.currentSequence = Sequences.CdataEnd;
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
          }
        } else {
          this.sequenceIndex = 0;
          this.state = 23;
          this.stateInDeclaration(c);
        }
      }
      /**
       * When we wait for one specific character, we can speed things up
       * by skipping through the buffer until we find it.
       *
       * @returns Whether the character was found.
       */
      fastForwardTo(c) {
        while (++this.index < this.buffer.length) {
          const cc = this.buffer.charCodeAt(this.index);
          if (cc === 10) {
            this.newlines.push(this.index);
          }
          if (cc === c) {
            return true;
          }
        }
        this.index = this.buffer.length - 1;
        return false;
      }
      /**
       * Comments and CDATA end with `-->` and `]]>`.
       *
       * Their common qualities are:
       * - Their end sequences have a distinct character they start with.
       * - That character is then repeated, so we have to check multiple repeats.
       * - All characters but the start character of the sequence can be skipped.
       */
      stateInCommentLike(c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
          if (++this.sequenceIndex === this.currentSequence.length) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, this.index - 2);
            } else {
              this.cbs.oncomment(this.sectionStart, this.index - 2);
            }
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
            this.state = 1;
          }
        } else if (this.sequenceIndex === 0) {
          if (this.fastForwardTo(this.currentSequence[0])) {
            this.sequenceIndex = 1;
          }
        } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
          this.sequenceIndex = 0;
        }
      }
      startSpecial(sequence, offset) {
        this.enterRCDATA(sequence, offset);
        this.state = 31;
      }
      enterRCDATA(sequence, offset) {
        this.inRCDATA = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset;
      }
      stateBeforeTagName(c) {
        if (c === 33) {
          this.state = 22;
          this.sectionStart = this.index + 1;
        } else if (c === 63) {
          this.state = 24;
          this.sectionStart = this.index + 1;
        } else if (isTagStartChar(c)) {
          this.sectionStart = this.index;
          if (this.mode === 0) {
            this.state = 6;
          } else if (this.inSFCRoot) {
            this.state = 34;
          } else if (!this.inXML) {
            if (c === 116) {
              this.state = 30;
            } else {
              this.state = c === 115 ? 29 : 6;
            }
          } else {
            this.state = 6;
          }
        } else if (c === 47) {
          this.state = 8;
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInTagName(c) {
        if (isEndOfTagSection(c)) {
          this.handleTagName(c);
        }
      }
      stateInSFCRootTagName(c) {
        if (isEndOfTagSection(c)) {
          const tag = this.buffer.slice(this.sectionStart, this.index);
          if (tag !== "template") {
            this.enterRCDATA(toCharCodes(`</` + tag), 0);
          }
          this.handleTagName(c);
        }
      }
      handleTagName(c) {
        this.cbs.onopentagname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = 11;
        this.stateBeforeAttrName(c);
      }
      stateBeforeClosingTagName(c) {
        if (isWhitespace(c)) ;
        else if (c === 62) {
          if (true) {
            this.cbs.onerr(14, this.index);
          }
          this.state = 1;
          this.sectionStart = this.index + 1;
        } else {
          this.state = isTagStartChar(c) ? 9 : 27;
          this.sectionStart = this.index;
        }
      }
      stateInClosingTagName(c) {
        if (c === 62 || isWhitespace(c)) {
          this.cbs.onclosetag(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = 10;
          this.stateAfterClosingTagName(c);
        }
      }
      stateAfterClosingTagName(c) {
        if (c === 62) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeAttrName(c) {
        if (c === 62) {
          this.cbs.onopentagend(this.index);
          if (this.inRCDATA) {
            this.state = 32;
          } else {
            this.state = 1;
          }
          this.sectionStart = this.index + 1;
        } else if (c === 47) {
          this.state = 7;
          if (this.peek() !== 62) {
            this.cbs.onerr(22, this.index);
          }
        } else if (c === 60 && this.peek() === 47) {
          this.cbs.onopentagend(this.index);
          this.state = 5;
          this.sectionStart = this.index;
        } else if (!isWhitespace(c)) {
          if (c === 61) {
            this.cbs.onerr(
              19,
              this.index
            );
          }
          this.handleAttrStart(c);
        }
      }
      handleAttrStart(c) {
        if (c === 118 && this.peek() === 45) {
          this.state = 13;
          this.sectionStart = this.index;
        } else if (c === 46 || c === 58 || c === 64 || c === 35) {
          this.cbs.ondirname(this.index, this.index + 1);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 12;
          this.sectionStart = this.index;
        }
      }
      stateInSelfClosingTag(c) {
        if (c === 62) {
          this.cbs.onselfclosingtag(this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
          this.inRCDATA = false;
        } else if (!isWhitespace(c)) {
          this.state = 11;
          this.stateBeforeAttrName(c);
        }
      }
      stateInAttrName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.onattribname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 34 || c === 39 || c === 60) {
          this.cbs.onerr(
            17,
            this.index
          );
        }
      }
      stateInDirName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 58) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else if (c === 46) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDirArg(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 91) {
          this.state = 15;
        } else if (c === 46) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDynamicDirArg(c) {
        if (c === 93) {
          this.state = 14;
        } else if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index + 1);
          this.handleAttrNameEnd(c);
          if (true) {
            this.cbs.onerr(
              27,
              this.index
            );
          }
        }
      }
      stateInDirModifier(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 46) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.sectionStart = this.index + 1;
        }
      }
      handleAttrNameEnd(c) {
        this.sectionStart = this.index;
        this.state = 17;
        this.cbs.onattribnameend(this.index);
        this.stateAfterAttrName(c);
      }
      stateAfterAttrName(c) {
        if (c === 61) {
          this.state = 18;
        } else if (c === 47 || c === 62) {
          this.cbs.onattribend(0, this.sectionStart);
          this.sectionStart = -1;
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (!isWhitespace(c)) {
          this.cbs.onattribend(0, this.sectionStart);
          this.handleAttrStart(c);
        }
      }
      stateBeforeAttrValue(c) {
        if (c === 34) {
          this.state = 19;
          this.sectionStart = this.index + 1;
        } else if (c === 39) {
          this.state = 20;
          this.sectionStart = this.index + 1;
        } else if (!isWhitespace(c)) {
          this.sectionStart = this.index;
          this.state = 21;
          this.stateInAttrValueNoQuotes(c);
        }
      }
      handleInAttrValue(c, quote) {
        if (c === quote || this.fastForwardTo(quote)) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(
            quote === 34 ? 3 : 2,
            this.index + 1
          );
          this.state = 11;
        }
      }
      stateInAttrValueDoubleQuotes(c) {
        this.handleInAttrValue(c, 34);
      }
      stateInAttrValueSingleQuotes(c) {
        this.handleInAttrValue(c, 39);
      }
      stateInAttrValueNoQuotes(c) {
        if (isWhitespace(c) || c === 62) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(1, this.index);
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {
          this.cbs.onerr(
            18,
            this.index
          );
        } else ;
      }
      stateBeforeDeclaration(c) {
        if (c === 91) {
          this.state = 26;
          this.sequenceIndex = 0;
        } else {
          this.state = c === 45 ? 25 : 23;
        }
      }
      stateInDeclaration(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateInProcessingInstruction(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.onprocessinginstruction(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeComment(c) {
        if (c === 45) {
          this.state = 28;
          this.currentSequence = Sequences.CommentEnd;
          this.sequenceIndex = 2;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 23;
        }
      }
      stateInSpecialComment(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.oncomment(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeSpecialS(c) {
        if (c === Sequences.ScriptEnd[3]) {
          this.startSpecial(Sequences.ScriptEnd, 4);
        } else if (c === Sequences.StyleEnd[3]) {
          this.startSpecial(Sequences.StyleEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      stateBeforeSpecialT(c) {
        if (c === Sequences.TitleEnd[3]) {
          this.startSpecial(Sequences.TitleEnd, 4);
        } else if (c === Sequences.TextareaEnd[3]) {
          this.startSpecial(Sequences.TextareaEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      startEntity() {
      }
      stateInEntity() {
      }
      /**
       * Iterates through the buffer, calling the function corresponding to the current state.
       *
       * States that are more likely to be hit are higher up, as a performance improvement.
       */
      parse(input) {
        this.buffer = input;
        while (this.index < this.buffer.length) {
          const c = this.buffer.charCodeAt(this.index);
          if (c === 10) {
            this.newlines.push(this.index);
          }
          switch (this.state) {
            case 1: {
              this.stateText(c);
              break;
            }
            case 2: {
              this.stateInterpolationOpen(c);
              break;
            }
            case 3: {
              this.stateInterpolation(c);
              break;
            }
            case 4: {
              this.stateInterpolationClose(c);
              break;
            }
            case 31: {
              this.stateSpecialStartSequence(c);
              break;
            }
            case 32: {
              this.stateInRCDATA(c);
              break;
            }
            case 26: {
              this.stateCDATASequence(c);
              break;
            }
            case 19: {
              this.stateInAttrValueDoubleQuotes(c);
              break;
            }
            case 12: {
              this.stateInAttrName(c);
              break;
            }
            case 13: {
              this.stateInDirName(c);
              break;
            }
            case 14: {
              this.stateInDirArg(c);
              break;
            }
            case 15: {
              this.stateInDynamicDirArg(c);
              break;
            }
            case 16: {
              this.stateInDirModifier(c);
              break;
            }
            case 28: {
              this.stateInCommentLike(c);
              break;
            }
            case 27: {
              this.stateInSpecialComment(c);
              break;
            }
            case 11: {
              this.stateBeforeAttrName(c);
              break;
            }
            case 6: {
              this.stateInTagName(c);
              break;
            }
            case 34: {
              this.stateInSFCRootTagName(c);
              break;
            }
            case 9: {
              this.stateInClosingTagName(c);
              break;
            }
            case 5: {
              this.stateBeforeTagName(c);
              break;
            }
            case 17: {
              this.stateAfterAttrName(c);
              break;
            }
            case 20: {
              this.stateInAttrValueSingleQuotes(c);
              break;
            }
            case 18: {
              this.stateBeforeAttrValue(c);
              break;
            }
            case 8: {
              this.stateBeforeClosingTagName(c);
              break;
            }
            case 10: {
              this.stateAfterClosingTagName(c);
              break;
            }
            case 29: {
              this.stateBeforeSpecialS(c);
              break;
            }
            case 30: {
              this.stateBeforeSpecialT(c);
              break;
            }
            case 21: {
              this.stateInAttrValueNoQuotes(c);
              break;
            }
            case 7: {
              this.stateInSelfClosingTag(c);
              break;
            }
            case 23: {
              this.stateInDeclaration(c);
              break;
            }
            case 22: {
              this.stateBeforeDeclaration(c);
              break;
            }
            case 25: {
              this.stateBeforeComment(c);
              break;
            }
            case 24: {
              this.stateInProcessingInstruction(c);
              break;
            }
            case 33: {
              this.stateInEntity();
              break;
            }
          }
          this.index++;
        }
        this.cleanup();
        this.finish();
      }
      /**
       * Remove data that has already been consumed from the buffer.
       */
      cleanup() {
        if (this.sectionStart !== this.index) {
          if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
            this.cbs.ontext(this.sectionStart, this.index);
            this.sectionStart = this.index;
          } else if (this.state === 19 || this.state === 20 || this.state === 21) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = this.index;
          }
        }
      }
      finish() {
        this.handleTrailingData();
        this.cbs.onend();
      }
      /** Handle any trailing data. */
      handleTrailingData() {
        const endIndex = this.buffer.length;
        if (this.sectionStart >= endIndex) {
          return;
        }
        if (this.state === 28) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, endIndex);
          } else {
            this.cbs.oncomment(this.sectionStart, endIndex);
          }
        } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ;
        else {
          this.cbs.ontext(this.sectionStart, endIndex);
        }
      }
      emitCodePoint(cp2, consumed) {
      }
    };
    CompilerDeprecationTypes = {
      "COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
      "COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
      "COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
      "COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
      "COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
      "COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
      "COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
      "COMPILER_FILTERS": "COMPILER_FILTERS"
    };
    deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key2) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key2}.sync\` should be changed to \`v-model:${key2}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
      },
      ["COMPILER_FILTERS"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
      }
    };
    ErrorCodes = {
      "ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
      "0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
      "CDATA_IN_HTML_CONTENT": 1,
      "1": "CDATA_IN_HTML_CONTENT",
      "DUPLICATE_ATTRIBUTE": 2,
      "2": "DUPLICATE_ATTRIBUTE",
      "END_TAG_WITH_ATTRIBUTES": 3,
      "3": "END_TAG_WITH_ATTRIBUTES",
      "END_TAG_WITH_TRAILING_SOLIDUS": 4,
      "4": "END_TAG_WITH_TRAILING_SOLIDUS",
      "EOF_BEFORE_TAG_NAME": 5,
      "5": "EOF_BEFORE_TAG_NAME",
      "EOF_IN_CDATA": 6,
      "6": "EOF_IN_CDATA",
      "EOF_IN_COMMENT": 7,
      "7": "EOF_IN_COMMENT",
      "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
      "8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
      "EOF_IN_TAG": 9,
      "9": "EOF_IN_TAG",
      "INCORRECTLY_CLOSED_COMMENT": 10,
      "10": "INCORRECTLY_CLOSED_COMMENT",
      "INCORRECTLY_OPENED_COMMENT": 11,
      "11": "INCORRECTLY_OPENED_COMMENT",
      "INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
      "12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
      "MISSING_ATTRIBUTE_VALUE": 13,
      "13": "MISSING_ATTRIBUTE_VALUE",
      "MISSING_END_TAG_NAME": 14,
      "14": "MISSING_END_TAG_NAME",
      "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
      "15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
      "NESTED_COMMENT": 16,
      "16": "NESTED_COMMENT",
      "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
      "17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
      "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
      "18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
      "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
      "19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
      "UNEXPECTED_NULL_CHARACTER": 20,
      "20": "UNEXPECTED_NULL_CHARACTER",
      "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
      "21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
      "UNEXPECTED_SOLIDUS_IN_TAG": 22,
      "22": "UNEXPECTED_SOLIDUS_IN_TAG",
      "X_INVALID_END_TAG": 23,
      "23": "X_INVALID_END_TAG",
      "X_MISSING_END_TAG": 24,
      "24": "X_MISSING_END_TAG",
      "X_MISSING_INTERPOLATION_END": 25,
      "25": "X_MISSING_INTERPOLATION_END",
      "X_MISSING_DIRECTIVE_NAME": 26,
      "26": "X_MISSING_DIRECTIVE_NAME",
      "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
      "27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
      "X_V_IF_NO_EXPRESSION": 28,
      "28": "X_V_IF_NO_EXPRESSION",
      "X_V_IF_SAME_KEY": 29,
      "29": "X_V_IF_SAME_KEY",
      "X_V_ELSE_NO_ADJACENT_IF": 30,
      "30": "X_V_ELSE_NO_ADJACENT_IF",
      "X_V_FOR_NO_EXPRESSION": 31,
      "31": "X_V_FOR_NO_EXPRESSION",
      "X_V_FOR_MALFORMED_EXPRESSION": 32,
      "32": "X_V_FOR_MALFORMED_EXPRESSION",
      "X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
      "33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
      "X_V_BIND_NO_EXPRESSION": 34,
      "34": "X_V_BIND_NO_EXPRESSION",
      "X_V_ON_NO_EXPRESSION": 35,
      "35": "X_V_ON_NO_EXPRESSION",
      "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
      "36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
      "X_V_SLOT_MIXED_SLOT_USAGE": 37,
      "37": "X_V_SLOT_MIXED_SLOT_USAGE",
      "X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
      "38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
      "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
      "39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
      "X_V_SLOT_MISPLACED": 40,
      "40": "X_V_SLOT_MISPLACED",
      "X_V_MODEL_NO_EXPRESSION": 41,
      "41": "X_V_MODEL_NO_EXPRESSION",
      "X_V_MODEL_MALFORMED_EXPRESSION": 42,
      "42": "X_V_MODEL_MALFORMED_EXPRESSION",
      "X_V_MODEL_ON_SCOPE_VARIABLE": 43,
      "43": "X_V_MODEL_ON_SCOPE_VARIABLE",
      "X_V_MODEL_ON_PROPS": 44,
      "44": "X_V_MODEL_ON_PROPS",
      "X_INVALID_EXPRESSION": 45,
      "45": "X_INVALID_EXPRESSION",
      "X_KEEP_ALIVE_INVALID_CHILDREN": 46,
      "46": "X_KEEP_ALIVE_INVALID_CHILDREN",
      "X_PREFIX_ID_NOT_SUPPORTED": 47,
      "47": "X_PREFIX_ID_NOT_SUPPORTED",
      "X_MODULE_MODE_NOT_SUPPORTED": 48,
      "48": "X_MODULE_MODE_NOT_SUPPORTED",
      "X_CACHE_HANDLER_NOT_SUPPORTED": 49,
      "49": "X_CACHE_HANDLER_NOT_SUPPORTED",
      "X_SCOPE_ID_NOT_SUPPORTED": 50,
      "50": "X_SCOPE_ID_NOT_SUPPORTED",
      "X_VNODE_HOOKS": 51,
      "51": "X_VNODE_HOOKS",
      "X_V_BIND_INVALID_SAME_NAME_ARGUMENT": 52,
      "52": "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
      "__EXTEND_POINT__": 53,
      "53": "__EXTEND_POINT__"
    };
    errorMessages = {
      // parse errors
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      // Vue-specific parse errors
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      // transform errors
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [52]: `v-bind with same-name shorthand only allows static argument.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
      [45]: `Error parsing JavaScript expression: `,
      [46]: `<KeepAlive> expects exactly one child component.`,
      [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
      // generic errors
      [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [48]: `ES module mode is not supported in this build of compiler.`,
      [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [50]: `"scopeId" option is only supported in module mode.`,
      // just to fulfill types
      [53]: ``
    };
    isFunctionType = (node2) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node2.type);
    };
    isStaticProperty = (node2) => node2 && (node2.type === "ObjectProperty" || node2.type === "ObjectMethod") && !node2.computed;
    isStaticPropertyKey = (node2, parent) => isStaticProperty(parent) && parent.key === node2;
    TS_NODE_TYPES = [
      "TSAsExpression",
      // foo as number
      "TSTypeAssertion",
      // (<number>foo)
      "TSNonNullExpression",
      // foo!
      "TSInstantiationExpression",
      // foo<string>
      "TSSatisfiesExpression"
      // foo satisfies T
    ];
    isStaticExp = (p2) => p2.type === 4 && p2.isStatic;
    nonIdentifierRE = /^\d|[^\$\w\xA0-\uFFFF]/;
    isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;
    isMemberExpressionBrowser = (exp) => {
      const path = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    isMemberExpressionNode = NOOP;
    isMemberExpression = isMemberExpressionBrowser;
    fnExpRE = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));
    isFnExpressionNode = NOOP;
    isFnExpression = isFnExpressionBrowser;
    propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
    defaultParserOptions = {
      parseMode: "base",
      ns: 0,
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      isVoidTag: NO,
      isPreTag: NO,
      isIgnoreNewlineTag: NO,
      isCustomElement: NO,
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true,
      prefixIdentifiers: false
    };
    currentOptions = defaultParserOptions;
    currentRoot = null;
    currentInput = "";
    currentOpenTag = null;
    currentProp = null;
    currentAttrValue = "";
    currentAttrStartIndex = -1;
    currentAttrEndIndex = -1;
    inPre = 0;
    inVPre = false;
    currentVPreBoundary = null;
    stack = [];
    tokenizer = new Tokenizer(stack, {
      onerr: emitError,
      ontext(start, end) {
        onText(getSlice(start, end), start, end);
      },
      ontextentity(char, start, end) {
        onText(char, start, end);
      },
      oninterpolation(start, end) {
        if (inVPre) {
          return onText(getSlice(start, end), start, end);
        }
        let innerStart = start + tokenizer.delimiterOpen.length;
        let innerEnd = end - tokenizer.delimiterClose.length;
        while (isWhitespace(currentInput.charCodeAt(innerStart))) {
          innerStart++;
        }
        while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
          innerEnd--;
        }
        let exp = getSlice(innerStart, innerEnd);
        if (exp.includes("&")) {
          {
            exp = currentOptions.decodeEntities(exp, false);
          }
        }
        addNode({
          type: 5,
          content: createExp(exp, false, getLoc(innerStart, innerEnd)),
          loc: getLoc(start, end)
        });
      },
      onopentagname(start, end) {
        const name = getSlice(start, end);
        currentOpenTag = {
          type: 1,
          tag: name,
          ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
          tagType: 0,
          // will be refined on tag close
          props: [],
          children: [],
          loc: getLoc(start - 1, end),
          codegenNode: void 0
        };
      },
      onopentagend(end) {
        endOpenTag(end);
      },
      onclosetag(start, end) {
        const name = getSlice(start, end);
        if (!currentOptions.isVoidTag(name)) {
          let found = false;
          for (let i = 0; i < stack.length; i++) {
            const e = stack[i];
            if (e.tag.toLowerCase() === name.toLowerCase()) {
              found = true;
              if (i > 0) {
                emitError(24, stack[0].loc.start.offset);
              }
              for (let j = 0; j <= i; j++) {
                const el = stack.shift();
                onCloseTag(el, end, j < i);
              }
              break;
            }
          }
          if (!found) {
            emitError(23, backTrack(start, 60));
          }
        }
      },
      onselfclosingtag(end) {
        const name = currentOpenTag.tag;
        currentOpenTag.isSelfClosing = true;
        endOpenTag(end);
        if (stack[0] && stack[0].tag === name) {
          onCloseTag(stack.shift(), end);
        }
      },
      onattribname(start, end) {
        currentProp = {
          type: 6,
          name: getSlice(start, end),
          nameLoc: getLoc(start, end),
          value: void 0,
          loc: getLoc(start)
        };
      },
      ondirname(start, end) {
        const raw2 = getSlice(start, end);
        const name = raw2 === "." || raw2 === ":" ? "bind" : raw2 === "@" ? "on" : raw2 === "#" ? "slot" : raw2.slice(2);
        if (!inVPre && name === "") {
          emitError(26, start);
        }
        if (inVPre || name === "") {
          currentProp = {
            type: 6,
            name: raw2,
            nameLoc: getLoc(start, end),
            value: void 0,
            loc: getLoc(start)
          };
        } else {
          currentProp = {
            type: 7,
            name,
            rawName: raw2,
            exp: void 0,
            arg: void 0,
            modifiers: raw2 === "." ? [createSimpleExpression("prop")] : [],
            loc: getLoc(start)
          };
          if (name === "pre") {
            inVPre = tokenizer.inVPre = true;
            currentVPreBoundary = currentOpenTag;
            const props = currentOpenTag.props;
            for (let i = 0; i < props.length; i++) {
              if (props[i].type === 7) {
                props[i] = dirToAttr(props[i]);
              }
            }
          }
        }
      },
      ondirarg(start, end) {
        if (start === end) return;
        const arg = getSlice(start, end);
        if (inVPre) {
          currentProp.name += arg;
          setLocEnd(currentProp.nameLoc, end);
        } else {
          const isStatic = arg[0] !== `[`;
          currentProp.arg = createExp(
            isStatic ? arg : arg.slice(1, -1),
            isStatic,
            getLoc(start, end),
            isStatic ? 3 : 0
          );
        }
      },
      ondirmodifier(start, end) {
        const mod = getSlice(start, end);
        if (inVPre) {
          currentProp.name += "." + mod;
          setLocEnd(currentProp.nameLoc, end);
        } else if (currentProp.name === "slot") {
          const arg = currentProp.arg;
          if (arg) {
            arg.content += "." + mod;
            setLocEnd(arg.loc, end);
          }
        } else {
          const exp = createSimpleExpression(mod, true, getLoc(start, end));
          currentProp.modifiers.push(exp);
        }
      },
      onattribdata(start, end) {
        currentAttrValue += getSlice(start, end);
        if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribentity(char, start, end) {
        currentAttrValue += char;
        if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribnameend(end) {
        const start = currentProp.loc.start.offset;
        const name = getSlice(start, end);
        if (currentProp.type === 7) {
          currentProp.rawName = name;
        }
        if (currentOpenTag.props.some(
          (p2) => (p2.type === 7 ? p2.rawName : p2.name) === name
        )) {
          emitError(2, start);
        }
      },
      onattribend(quote, end) {
        if (currentOpenTag && currentProp) {
          setLocEnd(currentProp.loc, end);
          if (quote !== 0) {
            if (currentAttrValue.includes("&")) {
              currentAttrValue = currentOptions.decodeEntities(
                currentAttrValue,
                true
              );
            }
            if (currentProp.type === 6) {
              if (currentProp.name === "class") {
                currentAttrValue = condense(currentAttrValue).trim();
              }
              if (quote === 1 && !currentAttrValue) {
                emitError(13, end);
              }
              currentProp.value = {
                type: 2,
                content: currentAttrValue,
                loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
              };
              if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
                tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
              }
            } else {
              let expParseMode = 0;
              currentProp.exp = createExp(
                currentAttrValue,
                false,
                getLoc(currentAttrStartIndex, currentAttrEndIndex),
                0,
                expParseMode
              );
              if (currentProp.name === "for") {
                currentProp.forParseResult = parseForExpression(currentProp.exp);
              }
              let syncIndex = -1;
              if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.findIndex(
                (mod) => mod.content === "sync"
              )) > -1 && checkCompatEnabled(
                "COMPILER_V_BIND_SYNC",
                currentOptions,
                currentProp.loc,
                currentProp.arg.loc.source
              )) {
                currentProp.name = "model";
                currentProp.modifiers.splice(syncIndex, 1);
              }
            }
          }
          if (currentProp.type !== 7 || currentProp.name !== "pre") {
            currentOpenTag.props.push(currentProp);
          }
        }
        currentAttrValue = "";
        currentAttrStartIndex = currentAttrEndIndex = -1;
      },
      oncomment(start, end) {
        if (currentOptions.comments) {
          addNode({
            type: 3,
            content: getSlice(start, end),
            loc: getLoc(start - 4, end + 3)
          });
        }
      },
      onend() {
        const end = currentInput.length;
        if (tokenizer.state !== 1) {
          switch (tokenizer.state) {
            case 5:
            case 8:
              emitError(5, end);
              break;
            case 3:
            case 4:
              emitError(
                25,
                tokenizer.sectionStart
              );
              break;
            case 28:
              if (tokenizer.currentSequence === Sequences.CdataEnd) {
                emitError(6, end);
              } else {
                emitError(7, end);
              }
              break;
            case 6:
            case 7:
            case 9:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
              emitError(9, end);
              break;
          }
        }
        for (let index2 = 0; index2 < stack.length; index2++) {
          onCloseTag(stack[index2], end - 1);
          emitError(24, stack[index2].loc.start.offset);
        }
      },
      oncdata(start, end) {
        if (stack[0].ns !== 0) {
          onText(getSlice(start, end), start, end);
        } else {
          emitError(1, start - 9);
        }
      },
      onprocessinginstruction(start) {
        if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
          emitError(
            21,
            start - 1
          );
        }
      }
    });
    forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    stripParensRE = /^\(|\)$/g;
    specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
    windowsNewlineRE = /\r\n/g;
    allowHoistedHelperSet = /* @__PURE__ */ new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    PURE_ANNOTATION = `/*@__PURE__*/`;
    aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
    prohibitedKeywordRE = new RegExp(
      "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
    );
    stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
    transformExpression = (node2, context) => {
      if (node2.type === 5) {
        node2.content = processExpression(
          node2.content,
          context
        );
      } else if (node2.type === 1) {
        const memo = findDir(node2, "memo");
        for (let i = 0; i < node2.props.length; i++) {
          const dir = node2.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg) && // key has been processed in transformFor(vMemo + vFor)
            !(memo && arg && arg.type === 4 && arg.content === "key")) {
              dir.exp = processExpression(
                exp,
                context,
                // slot args must be processed as function params
                dir.name === "slot"
              );
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context);
            }
          }
        }
      }
    };
    transformIf = createStructuralDirectiveTransform(
      /^(if|else|else-if)$/,
      (node2, dir, context) => {
        return processIf(node2, dir, context, (ifNode, branch, isRoot) => {
          const siblings2 = context.parent.children;
          let i = siblings2.indexOf(ifNode);
          let key2 = 0;
          while (i-- >= 0) {
            const sibling = siblings2[i];
            if (sibling && sibling.type === 9) {
              key2 += sibling.branches.length;
            }
          }
          return () => {
            if (isRoot) {
              ifNode.codegenNode = createCodegenNodeForBranch(
                branch,
                key2,
                context
              );
            } else {
              const parentCondition = getParentCondition(ifNode.codegenNode);
              parentCondition.alternate = createCodegenNodeForBranch(
                branch,
                key2 + ifNode.branches.length - 1,
                context
              );
            }
          };
        });
      }
    );
    transformBind = (dir, _node, context) => {
      const { modifiers, loc } = dir;
      const arg = dir.arg;
      let { exp } = dir;
      if (exp && exp.type === 4 && !exp.content.trim()) {
        {
          exp = void 0;
        }
      }
      if (!exp) {
        if (arg.type !== 4 || !arg.isStatic) {
          context.onError(
            createCompilerError(
              52,
              arg.loc
            )
          );
          return {
            props: [
              createObjectProperty(arg, createSimpleExpression("", true, loc))
            ]
          };
        }
        transformBindShorthand(dir);
        exp = dir.exp;
      }
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.some((mod) => mod.content === "camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = camelize(arg.content);
          } else {
            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context.inSSR) {
        if (modifiers.some((mod) => mod.content === "prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.some((mod) => mod.content === "attr")) {
          injectPrefix(arg, "^");
        }
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    transformBindShorthand = (dir, context) => {
      const arg = dir.arg;
      const propName = camelize(arg.content);
      dir.exp = createSimpleExpression(propName, false, arg.loc);
    };
    injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    transformFor = createStructuralDirectiveTransform(
      "for",
      (node2, dir, context) => {
        const { helper, removeHelper } = context;
        return processFor(node2, dir, context, (forNode) => {
          const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
          ]);
          const isTemplate = isTemplateNode(node2);
          const memo = findDir(node2, "memo");
          const keyProp = findProp(node2, `key`, false, true);
          const isDirKey = keyProp && keyProp.type === 7;
          if (isDirKey && !keyProp.exp) {
            transformBindShorthand(keyProp);
          }
          let keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
          const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
          const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
          const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
          forNode.codegenNode = createVNodeCall(
            context,
            helper(FRAGMENT),
            void 0,
            renderExp,
            fragmentFlag,
            void 0,
            void 0,
            true,
            !isStableFragment,
            false,
            node2.loc
          );
          return () => {
            let childBlock;
            const { children } = forNode;
            if (isTemplate) {
              node2.children.some((c) => {
                if (c.type === 1) {
                  const key2 = findProp(c, "key");
                  if (key2) {
                    context.onError(
                      createCompilerError(
                        33,
                        key2.loc
                      )
                    );
                    return true;
                  }
                }
              });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
            const slotOutlet = isSlotOutlet(node2) ? node2 : isTemplate && node2.children.length === 1 && isSlotOutlet(node2.children[0]) ? node2.children[0] : null;
            if (slotOutlet) {
              childBlock = slotOutlet.codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
            } else if (needFragmentWrapper) {
              childBlock = createVNodeCall(
                context,
                helper(FRAGMENT),
                keyProperty ? createObjectExpression([keyProperty]) : void 0,
                node2.children,
                64,
                void 0,
                void 0,
                true,
                void 0,
                false
              );
            } else {
              childBlock = children[0].codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
              if (childBlock.isBlock !== !isStableFragment) {
                if (childBlock.isBlock) {
                  removeHelper(OPEN_BLOCK);
                  removeHelper(
                    getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                  );
                } else {
                  removeHelper(
                    getVNodeHelper(context.inSSR, childBlock.isComponent)
                  );
                }
              }
              childBlock.isBlock = !isStableFragment;
              if (childBlock.isBlock) {
                helper(OPEN_BLOCK);
                helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
              } else {
                helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            if (memo) {
              const loop = createFunctionExpression(
                createForLoopParams(forNode.parseResult, [
                  createSimpleExpression(`_cached`)
                ])
              );
              loop.body = createBlockStatement([
                createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                createCompoundExpression([
                  `if (_cached`,
                  ...keyExp ? [` && _cached.key === `, keyExp] : [],
                  ` && ${context.helperString(
                    IS_MEMO_SAME
                  )}(_cached, _memo)) return _cached`
                ]),
                createCompoundExpression([`const _item = `, childBlock]),
                createSimpleExpression(`_item.memo = _memo`),
                createSimpleExpression(`return _item`)
              ]);
              renderExp.arguments.push(
                loop,
                createSimpleExpression(`_cache`),
                createSimpleExpression(String(context.cached.length))
              );
              context.cached.push(null);
            } else {
              renderExp.arguments.push(
                createFunctionExpression(
                  createForLoopParams(forNode.parseResult),
                  childBlock,
                  true
                )
              );
            }
          };
        });
      }
    );
    defaultFallback = createSimpleExpression(`undefined`, false);
    trackSlotScopes = (node2, context) => {
      if (node2.type === 1 && (node2.tagType === 1 || node2.tagType === 3)) {
        const vSlot = findDir(node2, "slot");
        if (vSlot) {
          vSlot.exp;
          context.scopes.vSlot++;
          return () => {
            context.scopes.vSlot--;
          };
        }
      }
    };
    trackVForSlotScopes = (node2, context) => {
      let vFor;
      if (isTemplateNode(node2) && node2.props.some(isVSlot) && (vFor = findDir(node2, "for"))) {
        const result = vFor.forParseResult;
        if (result) {
          finalizeForParseResult(result, context);
          const { value, key: key2, index: index2 } = result;
          const { addIdentifiers, removeIdentifiers } = context;
          value && addIdentifiers(value);
          key2 && addIdentifiers(key2);
          index2 && addIdentifiers(index2);
          return () => {
            value && removeIdentifiers(value);
            key2 && removeIdentifiers(key2);
            index2 && removeIdentifiers(index2);
          };
        }
      }
    };
    buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
      props,
      children,
      false,
      true,
      children.length ? children[0].loc : loc
    );
    directiveImportMap = /* @__PURE__ */ new WeakMap();
    transformElement = (node2, context) => {
      return function postTransformElement() {
        node2 = context.currentNode;
        if (!(node2.type === 1 && (node2.tagType === 0 || node2.tagType === 1))) {
          return;
        }
        const { tag, props } = node2;
        const isComponent2 = node2.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node2, context) : `"${tag}"`;
        const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = (
          // dynamic component may resolve to plain elements
          isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
          // updates inside get proper isSVG flag at runtime. (#639, #643)
          // This is technically web-specific, but splitting the logic out of core
          // leads to too much unnecessary complexity.
          (tag === "svg" || tag === "foreignObject" || tag === "math")
        );
        if (props.length > 0) {
          const propsBuildResult = buildProps(
            node2,
            context,
            void 0,
            isComponent2,
            isDynamicComponent
          );
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(
            directives.map((dir) => buildDirectiveArgs(dir, context))
          ) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node2.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node2.children.length > 1) {
              context.onError(
                createCompilerError(46, {
                  start: node2.children[0].loc.start,
                  end: node2.children[node2.children.length - 1].loc.end,
                  source: ""
                })
              );
            }
          }
          const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
          vnodeTag !== TELEPORT && // explained above.
          vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node2, context);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node2.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node2.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node2.children;
            }
          } else {
            vnodeChildren = node2.children;
          }
        }
        if (dynamicPropNames && dynamicPropNames.length) {
          vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
        }
        node2.codegenNode = createVNodeCall(
          context,
          vnodeTag,
          vnodeProps,
          vnodeChildren,
          patchFlag === 0 ? void 0 : patchFlag,
          vnodeDynamicProps,
          vnodeDirectives,
          !!shouldUseBlock,
          false,
          isComponent2,
          node2.loc
        );
      };
    };
    transformSlotOutlet = (node2, context) => {
      if (isSlotOutlet(node2)) {
        const { children, loc } = node2;
        const { slotName, slotProps } = processSlotOutlet(node2, context);
        const slotArgs = [
          context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node2.codegenNode = createCallExpression(
          context.helper(RENDER_SLOT),
          slotArgs,
          loc
        );
      }
    };
    transformOn = (dir, node2, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vnode")) {
            context.onError(createCompilerError(51, arg.loc));
          }
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          const eventString = node2.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
            // for non-element and vnode lifecycle event listeners, auto convert
            // it to camelCase. See issue #2249
            toHandlerKey(camelize(rawName))
          ) : (
            // preserve case for plain element listeners that have uppercase
            // letters, as these may be custom elements' custom events
            `on:${rawName}`
          );
          eventName = createSimpleExpression(eventString, true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp);
        const isInlineStatement = !(isMemberExp || isFnExpression(exp));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
          validateBrowserExpression(
            exp,
            context,
            false,
            hasMultipleStatements
          );
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(
            eventName,
            exp || createSimpleExpression(`() => {}`, false, loc)
          )
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context.cache(ret.props[0].value);
      }
      ret.props.forEach((p2) => p2.key.isHandlerKey = true);
      return ret;
    };
    transformText = (node2, context) => {
      if (node2.type === 0 || node2.type === 1 || node2.type === 11 || node2.type === 10) {
        return () => {
          const children = node2.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText$1(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = createCompoundExpression(
                      [child],
                      child.loc
                    );
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || // if this is a plain element with a single text child, leave it
          // as-is since the runtime has dedicated fast path for this by directly
          // setting textContent of the element.
          // for component root it's always normalized anyway.
          children.length === 1 && (node2.type === 0 || node2.type === 1 && node2.tagType === 0 && // #3756
          // custom directives can potentially add DOM elements arbitrarily,
          // we need to avoid setting textContent of the element at runtime
          // to avoid accidentally overwriting the DOM elements added
          // by the user through custom directives.
          !node2.props.find(
            (p2) => p2.type === 7 && !context.directiveTransforms[p2.name]
          ) && // in compat mode, <template> tags with no special directives
          // will be rendered as a fragment so its children must be
          // converted into vnodes.
          !(node2.tag === "template"))) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context.ssr && getConstantType(child, context) === 0) {
                callArgs.push(
                  1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``)
                );
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(
                  context.helper(CREATE_TEXT),
                  callArgs
                )
              };
            }
          }
        };
      }
    };
    seen$1 = /* @__PURE__ */ new WeakSet();
    transformOnce = (node2, context) => {
      if (node2.type === 1 && findDir(node2, "once", true)) {
        if (seen$1.has(node2) || context.inVOnce || context.inSSR) {
          return;
        }
        seen$1.add(node2);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
          context.inVOnce = false;
          const cur = context.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context.cache(
              cur.codegenNode,
              true,
              true
            );
          }
        };
      }
    };
    transformModel = (dir, node2, context) => {
      const { exp, arg } = dir;
      if (!exp) {
        context.onError(
          createCompilerError(41, dir.loc)
        );
        return createTransformProps();
      }
      const rawExp = exp.loc.source.trim();
      const expString = exp.type === 4 ? exp.content : rawExp;
      const bindingType = context.bindingMetadata[rawExp];
      if (bindingType === "props" || bindingType === "props-aliased") {
        context.onError(createCompilerError(44, exp.loc));
        return createTransformProps();
      }
      if (!expString.trim() || !isMemberExpression(exp) && true) {
        context.onError(
          createCompilerError(42, exp.loc)
        );
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp)
      ];
      if (dir.modifiers.length && node2.tagType === 1) {
        const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(
          createObjectProperty(
            modifiersKey,
            createSimpleExpression(
              `{ ${modifiers} }`,
              false,
              dir.loc,
              2
            )
          )
        );
      }
      return createTransformProps(props);
    };
    validDivisionCharRE = /[\w).+\-_$\]]/;
    transformFilter = (node2, context) => {
      if (!isCompatEnabled("COMPILER_FILTERS", context)) {
        return;
      }
      if (node2.type === 5) {
        rewriteFilter(node2.content, context);
      } else if (node2.type === 1) {
        node2.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context);
          }
        });
      }
    };
    seen = /* @__PURE__ */ new WeakSet();
    transformMemo = (node2, context) => {
      if (node2.type === 1) {
        const dir = findDir(node2, "memo");
        if (!dir || seen.has(node2)) {
          return;
        }
        seen.add(node2);
        return () => {
          const codegenNode = node2.codegenNode || context.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node2.tagType !== 1) {
              convertToBlock(codegenNode, context);
            }
            node2.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context.cached.length)
            ]);
            context.cached.push(null);
          }
        };
      }
    };
    BindingTypes = {
      "DATA": "data",
      "PROPS": "props",
      "PROPS_ALIASED": "props-aliased",
      "SETUP_LET": "setup-let",
      "SETUP_CONST": "setup-const",
      "SETUP_REACTIVE_CONST": "setup-reactive-const",
      "SETUP_MAYBE_REF": "setup-maybe-ref",
      "SETUP_REF": "setup-ref",
      "OPTIONS": "options",
      "LITERAL_CONST": "literal-const"
    };
    noopDirectiveTransform = () => ({ props: [] });
  }
});

// node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
var compiler_dom_esm_bundler_exports = {};
__export(compiler_dom_esm_bundler_exports, {
  BASE_TRANSITION: () => BASE_TRANSITION,
  BindingTypes: () => BindingTypes,
  CAMELIZE: () => CAMELIZE,
  CAPITALIZE: () => CAPITALIZE,
  CREATE_BLOCK: () => CREATE_BLOCK,
  CREATE_COMMENT: () => CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK: () => CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE: () => CREATE_ELEMENT_VNODE,
  CREATE_SLOTS: () => CREATE_SLOTS,
  CREATE_STATIC: () => CREATE_STATIC,
  CREATE_TEXT: () => CREATE_TEXT,
  CREATE_VNODE: () => CREATE_VNODE,
  CompilerDeprecationTypes: () => CompilerDeprecationTypes,
  ConstantTypes: () => ConstantTypes,
  DOMDirectiveTransforms: () => DOMDirectiveTransforms,
  DOMErrorCodes: () => DOMErrorCodes,
  DOMErrorMessages: () => DOMErrorMessages,
  DOMNodeTransforms: () => DOMNodeTransforms,
  ElementTypes: () => ElementTypes,
  ErrorCodes: () => ErrorCodes,
  FRAGMENT: () => FRAGMENT,
  GUARD_REACTIVE_PROPS: () => GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME: () => IS_MEMO_SAME,
  IS_REF: () => IS_REF,
  KEEP_ALIVE: () => KEEP_ALIVE,
  MERGE_PROPS: () => MERGE_PROPS,
  NORMALIZE_CLASS: () => NORMALIZE_CLASS,
  NORMALIZE_PROPS: () => NORMALIZE_PROPS,
  NORMALIZE_STYLE: () => NORMALIZE_STYLE,
  Namespaces: () => Namespaces,
  NodeTypes: () => NodeTypes,
  OPEN_BLOCK: () => OPEN_BLOCK,
  POP_SCOPE_ID: () => POP_SCOPE_ID,
  PUSH_SCOPE_ID: () => PUSH_SCOPE_ID,
  RENDER_LIST: () => RENDER_LIST,
  RENDER_SLOT: () => RENDER_SLOT,
  RESOLVE_COMPONENT: () => RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE: () => RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT: () => RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER: () => RESOLVE_FILTER,
  SET_BLOCK_TRACKING: () => SET_BLOCK_TRACKING,
  SUSPENSE: () => SUSPENSE,
  TELEPORT: () => TELEPORT,
  TO_DISPLAY_STRING: () => TO_DISPLAY_STRING,
  TO_HANDLERS: () => TO_HANDLERS,
  TO_HANDLER_KEY: () => TO_HANDLER_KEY,
  TRANSITION: () => TRANSITION,
  TRANSITION_GROUP: () => TRANSITION_GROUP,
  TS_NODE_TYPES: () => TS_NODE_TYPES,
  UNREF: () => UNREF,
  V_MODEL_CHECKBOX: () => V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC: () => V_MODEL_DYNAMIC,
  V_MODEL_RADIO: () => V_MODEL_RADIO,
  V_MODEL_SELECT: () => V_MODEL_SELECT,
  V_MODEL_TEXT: () => V_MODEL_TEXT,
  V_ON_WITH_KEYS: () => V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS: () => V_ON_WITH_MODIFIERS,
  V_SHOW: () => V_SHOW,
  WITH_CTX: () => WITH_CTX,
  WITH_DIRECTIVES: () => WITH_DIRECTIVES,
  WITH_MEMO: () => WITH_MEMO,
  advancePositionWithClone: () => advancePositionWithClone,
  advancePositionWithMutation: () => advancePositionWithMutation,
  assert: () => assert,
  baseCompile: () => baseCompile,
  baseParse: () => baseParse,
  buildDirectiveArgs: () => buildDirectiveArgs,
  buildProps: () => buildProps,
  buildSlots: () => buildSlots,
  checkCompatEnabled: () => checkCompatEnabled,
  compile: () => compile,
  convertToBlock: () => convertToBlock,
  createArrayExpression: () => createArrayExpression,
  createAssignmentExpression: () => createAssignmentExpression,
  createBlockStatement: () => createBlockStatement,
  createCacheExpression: () => createCacheExpression,
  createCallExpression: () => createCallExpression,
  createCompilerError: () => createCompilerError,
  createCompoundExpression: () => createCompoundExpression,
  createConditionalExpression: () => createConditionalExpression,
  createDOMCompilerError: () => createDOMCompilerError,
  createForLoopParams: () => createForLoopParams,
  createFunctionExpression: () => createFunctionExpression,
  createIfStatement: () => createIfStatement,
  createInterpolation: () => createInterpolation,
  createObjectExpression: () => createObjectExpression,
  createObjectProperty: () => createObjectProperty,
  createReturnStatement: () => createReturnStatement,
  createRoot: () => createRoot,
  createSequenceExpression: () => createSequenceExpression,
  createSimpleExpression: () => createSimpleExpression,
  createStructuralDirectiveTransform: () => createStructuralDirectiveTransform,
  createTemplateLiteral: () => createTemplateLiteral,
  createTransformContext: () => createTransformContext,
  createVNodeCall: () => createVNodeCall,
  errorMessages: () => errorMessages,
  extractIdentifiers: () => extractIdentifiers,
  findDir: () => findDir,
  findProp: () => findProp,
  forAliasRE: () => forAliasRE,
  generate: () => generate,
  generateCodeFrame: () => generateCodeFrame,
  getBaseTransformPreset: () => getBaseTransformPreset,
  getConstantType: () => getConstantType,
  getMemoedVNodeCall: () => getMemoedVNodeCall,
  getVNodeBlockHelper: () => getVNodeBlockHelper,
  getVNodeHelper: () => getVNodeHelper,
  hasDynamicKeyVBind: () => hasDynamicKeyVBind,
  hasScopeRef: () => hasScopeRef,
  helperNameMap: () => helperNameMap,
  injectProp: () => injectProp,
  isCoreComponent: () => isCoreComponent,
  isFnExpression: () => isFnExpression,
  isFnExpressionBrowser: () => isFnExpressionBrowser,
  isFnExpressionNode: () => isFnExpressionNode,
  isFunctionType: () => isFunctionType,
  isInDestructureAssignment: () => isInDestructureAssignment,
  isInNewExpression: () => isInNewExpression,
  isMemberExpression: () => isMemberExpression,
  isMemberExpressionBrowser: () => isMemberExpressionBrowser,
  isMemberExpressionNode: () => isMemberExpressionNode,
  isReferencedIdentifier: () => isReferencedIdentifier,
  isSimpleIdentifier: () => isSimpleIdentifier,
  isSlotOutlet: () => isSlotOutlet,
  isStaticArgOf: () => isStaticArgOf,
  isStaticExp: () => isStaticExp,
  isStaticProperty: () => isStaticProperty,
  isStaticPropertyKey: () => isStaticPropertyKey,
  isTemplateNode: () => isTemplateNode,
  isText: () => isText$1,
  isVSlot: () => isVSlot,
  locStub: () => locStub,
  noopDirectiveTransform: () => noopDirectiveTransform,
  parse: () => parse,
  parserOptions: () => parserOptions,
  processExpression: () => processExpression,
  processFor: () => processFor,
  processIf: () => processIf,
  processSlotOutlet: () => processSlotOutlet,
  registerRuntimeHelpers: () => registerRuntimeHelpers,
  resolveComponentType: () => resolveComponentType,
  stringifyExpression: () => stringifyExpression,
  toValidAssetId: () => toValidAssetId,
  trackSlotScopes: () => trackSlotScopes,
  trackVForSlotScopes: () => trackVForSlotScopes,
  transform: () => transform,
  transformBind: () => transformBind,
  transformElement: () => transformElement,
  transformExpression: () => transformExpression,
  transformModel: () => transformModel,
  transformOn: () => transformOn,
  transformStyle: () => transformStyle,
  traverseNode: () => traverseNode,
  unwrapTSNode: () => unwrapTSNode,
  walkBlockDeclarations: () => walkBlockDeclarations,
  walkFunctionParams: () => walkFunctionParams,
  walkIdentifiers: () => walkIdentifiers,
  warnDeprecation: () => warnDeprecation
});
function decodeHtmlBrowser(raw2, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw2.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw2;
    return decoder.textContent;
  }
}
function createDOMCompilerError(code3, loc) {
  return createCompilerError(
    code3,
    loc,
    true ? DOMErrorMessages : void 0
  );
}
function hasMultipleChildren(node2) {
  const children = node2.children = node2.children.filter(
    (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())
  );
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}
function isValidHTMLNesting(parent, child) {
  if (parent === "template") {
    return true;
  }
  if (parent in onlyValidChildren) {
    return onlyValidChildren[parent].has(child);
  }
  if (child in onlyValidParents) {
    return onlyValidParents[child].has(parent);
  }
  if (parent in knownInvalidChildren) {
    if (knownInvalidChildren[parent].has(child)) return false;
  }
  if (child in knownInvalidParents) {
    if (knownInvalidParents[child].has(parent)) return false;
  }
  return true;
}
function compile(src, options = {}) {
  return baseCompile(
    src,
    extend2({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend2(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
function parse(template, options = {}) {
  return baseParse(template, extend2({}, parserOptions, options));
}
var V_MODEL_RADIO, V_MODEL_CHECKBOX, V_MODEL_TEXT, V_MODEL_SELECT, V_MODEL_DYNAMIC, V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS, V_SHOW, TRANSITION, TRANSITION_GROUP, decoder, parserOptions, transformStyle, parseInlineCSS, DOMErrorCodes, DOMErrorMessages, transformVHtml, transformVText, transformModel2, isEventOptionModifier, isNonKeyModifier, maybeKeyModifier, isKeyboardEvent, resolveModifiers, transformClick, transformOn2, transformShow, transformTransition, ignoreSideEffectTags, headings, emptySet, onlyValidChildren, onlyValidParents, knownInvalidChildren, knownInvalidParents, validateHtmlNesting, DOMNodeTransforms, DOMDirectiveTransforms;
var init_compiler_dom_esm_bundler = __esm({
  "node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"() {
    init_compiler_core_esm_bundler();
    init_compiler_core_esm_bundler();
    init_shared_esm_bundler();
    V_MODEL_RADIO = Symbol(true ? `vModelRadio` : ``);
    V_MODEL_CHECKBOX = Symbol(
      true ? `vModelCheckbox` : ``
    );
    V_MODEL_TEXT = Symbol(true ? `vModelText` : ``);
    V_MODEL_SELECT = Symbol(
      true ? `vModelSelect` : ``
    );
    V_MODEL_DYNAMIC = Symbol(
      true ? `vModelDynamic` : ``
    );
    V_ON_WITH_MODIFIERS = Symbol(
      true ? `vOnModifiersGuard` : ``
    );
    V_ON_WITH_KEYS = Symbol(
      true ? `vOnKeysGuard` : ``
    );
    V_SHOW = Symbol(true ? `vShow` : ``);
    TRANSITION = Symbol(true ? `Transition` : ``);
    TRANSITION_GROUP = Symbol(
      true ? `TransitionGroup` : ``
    );
    registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
    });
    parserOptions = {
      parseMode: "html",
      isVoidTag,
      isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      isPreTag: (tag) => tag === "pre",
      isIgnoreNewlineTag: (tag) => tag === "pre" || tag === "textarea",
      decodeEntities: decodeHtmlBrowser,
      isBuiltInComponent: (tag) => {
        if (tag === "Transition" || tag === "transition") {
          return TRANSITION;
        } else if (tag === "TransitionGroup" || tag === "transition-group") {
          return TRANSITION_GROUP;
        }
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
      getNamespace(tag, parent, rootNamespace) {
        let ns = parent ? parent.ns : rootNamespace;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (parent.props.some(
              (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
            )) {
              ns = 0;
            }
          } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      }
    };
    transformStyle = (node2) => {
      if (node2.type === 1) {
        node2.props.forEach((p2, i) => {
          if (p2.type === 6 && p2.name === "style" && p2.value) {
            node2.props[i] = {
              type: 7,
              name: `bind`,
              arg: createSimpleExpression(`style`, true, p2.loc),
              exp: parseInlineCSS(p2.value.content, p2.loc),
              modifiers: [],
              loc: p2.loc
            };
          }
        });
      }
    };
    parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(
        JSON.stringify(normalized),
        false,
        loc,
        3
      );
    };
    DOMErrorCodes = {
      "X_V_HTML_NO_EXPRESSION": 53,
      "53": "X_V_HTML_NO_EXPRESSION",
      "X_V_HTML_WITH_CHILDREN": 54,
      "54": "X_V_HTML_WITH_CHILDREN",
      "X_V_TEXT_NO_EXPRESSION": 55,
      "55": "X_V_TEXT_NO_EXPRESSION",
      "X_V_TEXT_WITH_CHILDREN": 56,
      "56": "X_V_TEXT_WITH_CHILDREN",
      "X_V_MODEL_ON_INVALID_ELEMENT": 57,
      "57": "X_V_MODEL_ON_INVALID_ELEMENT",
      "X_V_MODEL_ARG_ON_ELEMENT": 58,
      "58": "X_V_MODEL_ARG_ON_ELEMENT",
      "X_V_MODEL_ON_FILE_INPUT_ELEMENT": 59,
      "59": "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
      "X_V_MODEL_UNNECESSARY_VALUE": 60,
      "60": "X_V_MODEL_UNNECESSARY_VALUE",
      "X_V_SHOW_NO_EXPRESSION": 61,
      "61": "X_V_SHOW_NO_EXPRESSION",
      "X_TRANSITION_INVALID_CHILDREN": 62,
      "62": "X_TRANSITION_INVALID_CHILDREN",
      "X_IGNORED_SIDE_EFFECT_TAG": 63,
      "63": "X_IGNORED_SIDE_EFFECT_TAG",
      "__EXTEND_POINT__": 64,
      "64": "__EXTEND_POINT__"
    };
    DOMErrorMessages = {
      [53]: `v-html is missing expression.`,
      [54]: `v-html will override element children.`,
      [55]: `v-text is missing expression.`,
      [56]: `v-text will override element children.`,
      [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [58]: `v-model argument is not supported on plain elements.`,
      [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [61]: `v-show is missing expression.`,
      [62]: `<Transition> expects exactly one child element or component.`,
      [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
    };
    transformVHtml = (dir, node2, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(53, loc)
        );
      }
      if (node2.children.length) {
        context.onError(
          createDOMCompilerError(54, loc)
        );
        node2.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`innerHTML`, true, loc),
            exp || createSimpleExpression("", true)
          )
        ]
      };
    };
    transformVText = (dir, node2, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(55, loc)
        );
      }
      if (node2.children.length) {
        context.onError(
          createDOMCompilerError(56, loc)
        );
        node2.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`textContent`, true),
            exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
              context.helperString(TO_DISPLAY_STRING),
              [exp],
              loc
            ) : createSimpleExpression("", true)
          )
        ]
      };
    };
    transformModel2 = (dir, node2, context) => {
      const baseResult = transformModel(dir, node2, context);
      if (!baseResult.props.length || node2.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context.onError(
          createDOMCompilerError(
            58,
            dir.arg.loc
          )
        );
      }
      function checkDuplicatedValue() {
        const value = findDir(node2, "bind");
        if (value && isStaticArgOf(value.arg, "value")) {
          context.onError(
            createDOMCompilerError(
              60,
              value.loc
            )
          );
        }
      }
      const { tag } = node2;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type = findProp(node2, `type`);
          if (type) {
            if (type.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context.onError(
                    createDOMCompilerError(
                      59,
                      dir.loc
                    )
                  );
                  break;
                default:
                  checkDuplicatedValue();
                  break;
              }
            }
          } else if (hasDynamicKeyVBind(node2)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else {
            checkDuplicatedValue();
          }
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else {
          checkDuplicatedValue();
        }
        if (!isInvalidType) {
          baseResult.needRuntime = context.helper(directiveToUse);
        }
      } else {
        context.onError(
          createDOMCompilerError(
            57,
            dir.loc
          )
        );
      }
      baseResult.props = baseResult.props.filter(
        (p2) => !(p2.key.type === 4 && p2.key.content === "modelValue")
      );
      return baseResult;
    };
    isEventOptionModifier = makeMap(`passive,once,capture`);
    isNonKeyModifier = makeMap(
      // event propagation management
      `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
    );
    maybeKeyModifier = makeMap("left,right");
    isKeyboardEvent = makeMap(`onkeyup,onkeydown,onkeypress`);
    resolveModifiers = (key2, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i].content;
        if (modifier === "native" && checkCompatEnabled(
          "COMPILER_V_ON_NATIVE",
          context,
          loc
        )) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (isStaticExp(key2)) {
              if (isKeyboardEvent(key2.content.toLowerCase())) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
      };
    };
    transformClick = (key2, event) => {
      const isStaticClick = isStaticExp(key2) && key2.content.toLowerCase() === "onclick";
      return isStaticClick ? createSimpleExpression(event, true) : key2.type !== 4 ? createCompoundExpression([
        `(`,
        key2,
        `) === "onClick" ? "${event}" : (`,
        key2,
        `)`
      ]) : key2;
    };
    transformOn2 = (dir, node2, context) => {
      return transformOn(dir, node2, context, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length) return baseResult;
        let { key: key2, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key2, modifiers, context, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key2 = transformClick(key2, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key2 = transformClick(key2, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
            handlerExp,
            JSON.stringify(nonKeyModifiers)
          ]);
        }
        if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
        (!isStaticExp(key2) || isKeyboardEvent(key2.content.toLowerCase()))) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers)
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
          key2 = isStaticExp(key2) ? createSimpleExpression(`${key2.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key2, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [createObjectProperty(key2, handlerExp)]
        };
      });
    };
    transformShow = (dir, node2, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(61, loc)
        );
      }
      return {
        props: [],
        needRuntime: context.helper(V_SHOW)
      };
    };
    transformTransition = (node2, context) => {
      if (node2.type === 1 && node2.tagType === 1) {
        const component = context.isBuiltInComponent(node2.tag);
        if (component === TRANSITION) {
          return () => {
            if (!node2.children.length) {
              return;
            }
            if (hasMultipleChildren(node2)) {
              context.onError(
                createDOMCompilerError(
                  62,
                  {
                    start: node2.children[0].loc.start,
                    end: node2.children[node2.children.length - 1].loc.end,
                    source: ""
                  }
                )
              );
            }
            const child = node2.children[0];
            if (child.type === 1) {
              for (const p2 of child.props) {
                if (p2.type === 7 && p2.name === "show") {
                  node2.props.push({
                    type: 6,
                    name: "persisted",
                    nameLoc: node2.loc,
                    value: void 0,
                    loc: node2.loc
                  });
                }
              }
            }
          };
        }
      }
    };
    ignoreSideEffectTags = (node2, context) => {
      if (node2.type === 1 && node2.tagType === 0 && (node2.tag === "script" || node2.tag === "style")) {
        context.onError(
          createDOMCompilerError(
            63,
            node2.loc
          )
        );
        context.removeNode();
      }
    };
    headings = /* @__PURE__ */ new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
    emptySet = /* @__PURE__ */ new Set([]);
    onlyValidChildren = {
      head: /* @__PURE__ */ new Set([
        "base",
        "basefront",
        "bgsound",
        "link",
        "meta",
        "title",
        "noscript",
        "noframes",
        "style",
        "script",
        "template"
      ]),
      optgroup: /* @__PURE__ */ new Set(["option"]),
      select: /* @__PURE__ */ new Set(["optgroup", "option", "hr"]),
      // table
      table: /* @__PURE__ */ new Set(["caption", "colgroup", "tbody", "tfoot", "thead"]),
      tr: /* @__PURE__ */ new Set(["td", "th"]),
      colgroup: /* @__PURE__ */ new Set(["col"]),
      tbody: /* @__PURE__ */ new Set(["tr"]),
      thead: /* @__PURE__ */ new Set(["tr"]),
      tfoot: /* @__PURE__ */ new Set(["tr"]),
      // these elements can not have any children elements
      script: emptySet,
      iframe: emptySet,
      option: emptySet,
      textarea: emptySet,
      style: emptySet,
      title: emptySet
    };
    onlyValidParents = {
      // sections
      html: emptySet,
      body: /* @__PURE__ */ new Set(["html"]),
      head: /* @__PURE__ */ new Set(["html"]),
      // table
      td: /* @__PURE__ */ new Set(["tr"]),
      colgroup: /* @__PURE__ */ new Set(["table"]),
      caption: /* @__PURE__ */ new Set(["table"]),
      tbody: /* @__PURE__ */ new Set(["table"]),
      tfoot: /* @__PURE__ */ new Set(["table"]),
      col: /* @__PURE__ */ new Set(["colgroup"]),
      th: /* @__PURE__ */ new Set(["tr"]),
      thead: /* @__PURE__ */ new Set(["table"]),
      tr: /* @__PURE__ */ new Set(["tbody", "thead", "tfoot"]),
      // data list
      dd: /* @__PURE__ */ new Set(["dl", "div"]),
      dt: /* @__PURE__ */ new Set(["dl", "div"]),
      // other
      figcaption: /* @__PURE__ */ new Set(["figure"]),
      // li: new Set(["ul", "ol"]),
      summary: /* @__PURE__ */ new Set(["details"]),
      area: /* @__PURE__ */ new Set(["map"])
    };
    knownInvalidChildren = {
      p: /* @__PURE__ */ new Set([
        "address",
        "article",
        "aside",
        "blockquote",
        "center",
        "details",
        "dialog",
        "dir",
        "div",
        "dl",
        "fieldset",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "hr",
        "li",
        "main",
        "nav",
        "menu",
        "ol",
        "p",
        "pre",
        "section",
        "table",
        "ul"
      ]),
      svg: /* @__PURE__ */ new Set([
        "b",
        "blockquote",
        "br",
        "code",
        "dd",
        "div",
        "dl",
        "dt",
        "em",
        "embed",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hr",
        "i",
        "img",
        "li",
        "menu",
        "meta",
        "ol",
        "p",
        "pre",
        "ruby",
        "s",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "table",
        "u",
        "ul",
        "var"
      ])
    };
    knownInvalidParents = {
      a: /* @__PURE__ */ new Set(["a"]),
      button: /* @__PURE__ */ new Set(["button"]),
      dd: /* @__PURE__ */ new Set(["dd", "dt"]),
      dt: /* @__PURE__ */ new Set(["dd", "dt"]),
      form: /* @__PURE__ */ new Set(["form"]),
      li: /* @__PURE__ */ new Set(["li"]),
      h1: headings,
      h2: headings,
      h3: headings,
      h4: headings,
      h5: headings,
      h6: headings
    };
    validateHtmlNesting = (node2, context) => {
      if (node2.type === 1 && node2.tagType === 0 && context.parent && context.parent.type === 1 && context.parent.tagType === 0 && !isValidHTMLNesting(context.parent.tag, node2.tag)) {
        const error2 = new SyntaxError(
          `<${node2.tag}> cannot be child of <${context.parent.tag}>, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality.`
        );
        error2.loc = node2.loc;
        context.onWarn(error2);
      }
    };
    DOMNodeTransforms = [
      transformStyle,
      ...true ? [transformTransition, validateHtmlNesting] : []
    ];
    DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel2,
      // override compiler-core
      on: transformOn2,
      // override compiler-core
      show: transformShow
    };
  }
});

// node_modules/@vue/language-core/lib/parsers/scriptSetupRanges.js
var require_scriptSetupRanges = __commonJS({
  "node_modules/@vue/language-core/lib/parsers/scriptSetupRanges.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseScriptSetupRanges = parseScriptSetupRanges;
    exports.parseBindingRanges = parseBindingRanges;
    exports.findBindingVars = findBindingVars;
    exports.getStartEnd = getStartEnd;
    exports.getNodeText = getNodeText;
    var common_1 = require_common();
    function parseScriptSetupRanges(ts3, ast, vueCompilerOptions) {
      var _a;
      let foundNonImportExportNode = false;
      let importSectionEndOffset = 0;
      const props = {};
      const slots = {};
      const emits = {};
      const expose = {};
      const options = {};
      const cssModules = [];
      const templateRefs = [];
      const definePropProposalA = vueCompilerOptions.experimentalDefinePropProposal === "kevinEdition" || ast.text.trimStart().startsWith("// @experimentalDefinePropProposal=kevinEdition");
      const definePropProposalB = vueCompilerOptions.experimentalDefinePropProposal === "johnsonEdition" || ast.text.trimStart().startsWith("// @experimentalDefinePropProposal=johnsonEdition");
      const defineProp = [];
      const text6 = ast.text;
      const leadingCommentEndOffset = ((_a = ts3.getLeadingCommentRanges(text6, 0)) == null ? void 0 : _a.reverse()[0].end) ?? 0;
      const importComponentNames = /* @__PURE__ */ new Set();
      let bindings = parseBindingRanges(ts3, ast);
      ts3.forEachChild(ast, (node2) => {
        var _a2, _b;
        const isTypeExport = (ts3.isTypeAliasDeclaration(node2) || ts3.isInterfaceDeclaration(node2)) && ((_a2 = node2.modifiers) == null ? void 0 : _a2.some((mod) => mod.kind === ts3.SyntaxKind.ExportKeyword));
        if (!foundNonImportExportNode && !ts3.isImportDeclaration(node2) && !isTypeExport && !ts3.isEmptyStatement(node2) && !ts3.isImportEqualsDeclaration(node2)) {
          const commentRanges = ts3.getLeadingCommentRanges(text6, node2.pos);
          if (commentRanges == null ? void 0 : commentRanges.length) {
            const commentRange = commentRanges.sort((a, b) => a.pos - b.pos)[0];
            importSectionEndOffset = commentRange.pos;
          } else {
            importSectionEndOffset = getStartEnd(ts3, node2, ast).start;
          }
          foundNonImportExportNode = true;
        }
        if (ts3.isImportDeclaration(node2) && ((_b = node2.importClause) == null ? void 0 : _b.name) && !node2.importClause.isTypeOnly) {
          const moduleName = getNodeText(ts3, node2.moduleSpecifier, ast).slice(1, -1);
          if (vueCompilerOptions.extensions.some((ext) => moduleName.endsWith(ext))) {
            importComponentNames.add(getNodeText(ts3, node2.importClause.name, ast));
          }
        }
      });
      ts3.forEachChild(ast, (child) => visitNode(child, [ast]));
      const templateRefNames = new Set(templateRefs.map((ref) => ref.name));
      bindings = bindings.filter((range3) => {
        const name = text6.substring(range3.start, range3.end);
        return !templateRefNames.has(name);
      });
      return {
        leadingCommentEndOffset,
        importSectionEndOffset,
        bindings,
        importComponentNames,
        props,
        slots,
        emits,
        expose,
        options,
        cssModules,
        defineProp,
        templateRefs
      };
      function _getStartEnd(node2) {
        return getStartEnd(ts3, node2, ast);
      }
      function parseDefineFunction(node2) {
        var _a2;
        return {
          ..._getStartEnd(node2),
          exp: _getStartEnd(node2.expression),
          arg: node2.arguments.length ? _getStartEnd(node2.arguments[0]) : void 0,
          typeArg: ((_a2 = node2.typeArguments) == null ? void 0 : _a2.length) ? _getStartEnd(node2.typeArguments[0]) : void 0
        };
      }
      function visitNode(node2, parents) {
        var _a2, _b, _c, _d, _e, _f;
        const parent = parents[parents.length - 1];
        if (ts3.isCallExpression(node2) && ts3.isIdentifier(node2.expression)) {
          const callText = getNodeText(ts3, node2.expression, ast);
          if (vueCompilerOptions.macros.defineModel.includes(callText)) {
            let localName;
            let propName;
            let options2;
            if (ts3.isVariableDeclaration(parent) && ts3.isIdentifier(parent.name)) {
              localName = _getStartEnd(parent.name);
            }
            if (node2.arguments.length >= 2) {
              propName = _getStartEnd(node2.arguments[0]);
              options2 = node2.arguments[1];
            } else if (node2.arguments.length >= 1) {
              if (ts3.isStringLiteral(node2.arguments[0])) {
                propName = _getStartEnd(node2.arguments[0]);
              } else {
                options2 = node2.arguments[0];
              }
            }
            let runtimeType;
            let defaultValue;
            let required = false;
            if (options2 && ts3.isObjectLiteralExpression(options2)) {
              for (const property2 of options2.properties) {
                if (!ts3.isPropertyAssignment(property2) || !ts3.isIdentifier(property2.name)) {
                  continue;
                }
                const text7 = getNodeText(ts3, property2.name, ast);
                if (text7 === "type") {
                  runtimeType = _getStartEnd(property2.initializer);
                } else if (text7 === "default") {
                  defaultValue = _getStartEnd(property2.initializer);
                } else if (text7 === "required" && property2.initializer.kind === ts3.SyntaxKind.TrueKeyword) {
                  required = true;
                }
              }
            }
            defineProp.push({
              localName,
              name: propName,
              type: ((_a2 = node2.typeArguments) == null ? void 0 : _a2.length) ? _getStartEnd(node2.typeArguments[0]) : void 0,
              modifierType: node2.typeArguments && ((_b = node2.typeArguments) == null ? void 0 : _b.length) >= 2 ? _getStartEnd(node2.typeArguments[1]) : void 0,
              runtimeType,
              defaultValue,
              required,
              isModel: true
            });
          } else if (callText === "defineProp") {
            let localName;
            let propName;
            let options2;
            if (ts3.isVariableDeclaration(parent) && ts3.isIdentifier(parent.name)) {
              localName = _getStartEnd(parent.name);
            }
            let runtimeType;
            let defaultValue;
            let required = false;
            if (definePropProposalA) {
              if (node2.arguments.length >= 2) {
                options2 = node2.arguments[1];
              }
              if (node2.arguments.length >= 1) {
                propName = _getStartEnd(node2.arguments[0]);
              }
              if (options2 && ts3.isObjectLiteralExpression(options2)) {
                for (const property2 of options2.properties) {
                  if (!ts3.isPropertyAssignment(property2) || !ts3.isIdentifier(property2.name)) {
                    continue;
                  }
                  const text7 = getNodeText(ts3, property2.name, ast);
                  if (text7 === "type") {
                    runtimeType = _getStartEnd(property2.initializer);
                  } else if (text7 === "default") {
                    defaultValue = _getStartEnd(property2.initializer);
                  } else if (text7 === "required" && property2.initializer.kind === ts3.SyntaxKind.TrueKeyword) {
                    required = true;
                  }
                }
              }
            } else if (definePropProposalB) {
              if (node2.arguments.length >= 3) {
                options2 = node2.arguments[2];
              }
              if (node2.arguments.length >= 2) {
                if (node2.arguments[1].kind === ts3.SyntaxKind.TrueKeyword) {
                  required = true;
                }
              }
              if (node2.arguments.length >= 1) {
                defaultValue = _getStartEnd(node2.arguments[0]);
              }
              if (options2 && ts3.isObjectLiteralExpression(options2)) {
                for (const property2 of options2.properties) {
                  if (!ts3.isPropertyAssignment(property2) || !ts3.isIdentifier(property2.name)) {
                    continue;
                  }
                  const text7 = getNodeText(ts3, property2.name, ast);
                  if (text7 === "type") {
                    runtimeType = _getStartEnd(property2.initializer);
                  }
                }
              }
            }
            defineProp.push({
              localName,
              name: propName,
              type: ((_c = node2.typeArguments) == null ? void 0 : _c.length) ? _getStartEnd(node2.typeArguments[0]) : void 0,
              runtimeType,
              defaultValue,
              required
            });
          } else if (vueCompilerOptions.macros.defineSlots.includes(callText)) {
            slots.define = {
              ...parseDefineFunction(node2),
              statement: getStatementRange(ts3, parents, node2, ast)
            };
            if (ts3.isVariableDeclaration(parent)) {
              if (ts3.isIdentifier(parent.name)) {
                slots.name = getNodeText(ts3, parent.name, ast);
              } else {
                slots.isObjectBindingPattern = ts3.isObjectBindingPattern(parent.name);
              }
            }
          } else if (vueCompilerOptions.macros.defineEmits.includes(callText)) {
            emits.define = {
              ...parseDefineFunction(node2),
              statement: getStatementRange(ts3, parents, node2, ast)
            };
            if (ts3.isVariableDeclaration(parent)) {
              emits.name = getNodeText(ts3, parent.name, ast);
            }
            if (((_d = node2.typeArguments) == null ? void 0 : _d.length) && ts3.isTypeLiteralNode(node2.typeArguments[0]) && node2.typeArguments[0].members.at(0)) {
              for (const member of node2.typeArguments[0].members) {
                if (ts3.isCallSignatureDeclaration(member) && member.parameters[0].type && ts3.isUnionTypeNode(member.parameters[0].type)) {
                  emits.define.hasUnionTypeArg = true;
                  return;
                }
              }
            }
          } else if (vueCompilerOptions.macros.defineExpose.includes(callText)) {
            expose.define = parseDefineFunction(node2);
          } else if (vueCompilerOptions.macros.defineProps.includes(callText)) {
            if (ts3.isVariableDeclaration(parent)) {
              if (ts3.isObjectBindingPattern(parent.name)) {
                props.destructured = /* @__PURE__ */ new Set();
                const identifiers = (0, common_1.collectIdentifiers)(ts3, parent.name, []);
                for (const [id, isRest] of identifiers) {
                  const name = getNodeText(ts3, id, ast);
                  if (isRest) {
                    props.destructuredRest = name;
                  } else {
                    props.destructured.add(name);
                  }
                }
              } else {
                props.name = getNodeText(ts3, parent.name, ast);
              }
            }
            props.define = {
              ...parseDefineFunction(node2),
              statement: getStatementRange(ts3, parents, node2, ast)
            };
            if (node2.arguments.length) {
              props.define.arg = _getStartEnd(node2.arguments[0]);
            }
            if ((_e = node2.typeArguments) == null ? void 0 : _e.length) {
              props.define.typeArg = _getStartEnd(node2.typeArguments[0]);
            }
          } else if (vueCompilerOptions.macros.withDefaults.includes(callText)) {
            props.withDefaults = _getStartEnd(node2);
            if (node2.arguments.length >= 2) {
              const arg = node2.arguments[1];
              props.withDefaults.arg = _getStartEnd(arg);
            }
            if (ts3.isVariableDeclaration(parent)) {
              props.name = getNodeText(ts3, parent.name, ast);
            }
          } else if (vueCompilerOptions.macros.defineOptions.includes(callText)) {
            if (node2.arguments.length && ts3.isObjectLiteralExpression(node2.arguments[0])) {
              const obj = node2.arguments[0];
              ts3.forEachChild(obj, (node3) => {
                if (ts3.isPropertyAssignment(node3) && ts3.isIdentifier(node3.name)) {
                  const name = getNodeText(ts3, node3.name, ast);
                  if (name === "inheritAttrs") {
                    options.inheritAttrs = getNodeText(ts3, node3.initializer, ast);
                  }
                }
              });
              for (const prop of node2.arguments[0].properties) {
                if (ts3.isPropertyAssignment(prop) && getNodeText(ts3, prop.name, ast) === "name" && ts3.isStringLiteral(prop.initializer)) {
                  options.name = prop.initializer.text;
                }
              }
            }
          } else if (vueCompilerOptions.composibles.useTemplateRef.includes(callText) && node2.arguments.length && !((_f = node2.typeArguments) == null ? void 0 : _f.length)) {
            const define2 = parseDefineFunction(node2);
            let name;
            if (ts3.isVariableDeclaration(parent)) {
              name = getNodeText(ts3, parent.name, ast);
            }
            templateRefs.push({
              name,
              define: define2
            });
          } else if (vueCompilerOptions.composibles.useCssModule.includes(callText)) {
            const define2 = parseDefineFunction(node2);
            cssModules.push({
              define: define2
            });
          }
        }
        ts3.forEachChild(node2, (child) => {
          parents.push(node2);
          visitNode(child, parents);
          parents.pop();
        });
      }
    }
    function parseBindingRanges(ts3, sourceFile) {
      const bindings = [];
      ts3.forEachChild(sourceFile, (node2) => {
        if (ts3.isVariableStatement(node2)) {
          for (const node_2 of node2.declarationList.declarations) {
            const vars = _findBindingVars(node_2.name);
            for (const _var of vars) {
              bindings.push(_var);
            }
          }
        } else if (ts3.isFunctionDeclaration(node2)) {
          if (node2.name && ts3.isIdentifier(node2.name)) {
            bindings.push(_getStartEnd(node2.name));
          }
        } else if (ts3.isClassDeclaration(node2)) {
          if (node2.name) {
            bindings.push(_getStartEnd(node2.name));
          }
        } else if (ts3.isEnumDeclaration(node2)) {
          bindings.push(_getStartEnd(node2.name));
        }
        if (ts3.isImportDeclaration(node2)) {
          if (node2.importClause && !node2.importClause.isTypeOnly) {
            if (node2.importClause.name) {
              bindings.push(_getStartEnd(node2.importClause.name));
            }
            if (node2.importClause.namedBindings) {
              if (ts3.isNamedImports(node2.importClause.namedBindings)) {
                for (const element3 of node2.importClause.namedBindings.elements) {
                  if (element3.isTypeOnly) {
                    continue;
                  }
                  bindings.push(_getStartEnd(element3.name));
                }
              } else if (ts3.isNamespaceImport(node2.importClause.namedBindings)) {
                bindings.push(_getStartEnd(node2.importClause.namedBindings.name));
              }
            }
          }
        }
      });
      return bindings;
      function _getStartEnd(node2) {
        return getStartEnd(ts3, node2, sourceFile);
      }
      function _findBindingVars(left) {
        return findBindingVars(ts3, left, sourceFile);
      }
    }
    function findBindingVars(ts3, left, sourceFile) {
      const vars = [];
      worker(left);
      return vars;
      function worker(_node) {
        if (ts3.isIdentifier(_node)) {
          vars.push(getStartEnd(ts3, _node, sourceFile));
        } else if (ts3.isObjectBindingPattern(_node) || ts3.isArrayBindingPattern(_node)) {
          for (const property2 of _node.elements) {
            if (ts3.isBindingElement(property2)) {
              worker(property2.name);
            }
          }
        } else if (ts3.isPropertyAssignment(_node)) {
          worker(_node.initializer);
        } else if (ts3.isShorthandPropertyAssignment(_node)) {
          vars.push(getStartEnd(ts3, _node.name, sourceFile));
        } else if (ts3.isSpreadAssignment(_node) || ts3.isSpreadElement(_node)) {
          worker(_node.expression);
        }
      }
    }
    function getStartEnd(ts3, node2, sourceFile) {
      return {
        start: ts3.getTokenPosOfNode(node2, sourceFile),
        end: node2.end
      };
    }
    function getNodeText(ts3, node2, sourceFile) {
      const { start, end } = getStartEnd(ts3, node2, sourceFile);
      return sourceFile.text.substring(start, end);
    }
    function getStatementRange(ts3, parents, node2, sourceFile) {
      let statementRange;
      for (let i = parents.length - 1; i >= 0; i--) {
        if (ts3.isStatement(parents[i])) {
          const statement = parents[i];
          ts3.forEachChild(statement, (child) => {
            const range3 = getStartEnd(ts3, child, sourceFile);
            statementRange ?? (statementRange = range3);
            statementRange.end = range3.end;
          });
          break;
        }
      }
      if (!statementRange) {
        statementRange = getStartEnd(ts3, node2, sourceFile);
      }
      return statementRange;
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/common.js
var require_common = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.variableNameRegex = exports.combineLastMapping = exports.endOfLine = exports.newLine = void 0;
    exports.conditionWrapWith = conditionWrapWith;
    exports.wrapWith = wrapWith;
    exports.collectVars = collectVars;
    exports.collectIdentifiers = collectIdentifiers;
    exports.createTsAst = createTsAst;
    exports.generateSfcBlockSection = generateSfcBlockSection;
    var scriptSetupRanges_1 = require_scriptSetupRanges();
    exports.newLine = "\n";
    exports.endOfLine = `;${exports.newLine}`;
    exports.combineLastMapping = { __combineLastMapping: true };
    exports.variableNameRegex = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
    function* conditionWrapWith(condition, startOffset, endOffset, features, ...wrapCodes) {
      if (condition) {
        yield* wrapWith(startOffset, endOffset, features, ...wrapCodes);
      } else {
        for (const wrapCode of wrapCodes) {
          yield wrapCode;
        }
      }
    }
    function* wrapWith(startOffset, endOffset, features, ...wrapCodes) {
      yield ["", "template", startOffset, features];
      let offset = 1;
      for (const wrapCode of wrapCodes) {
        if (typeof wrapCode !== "string") {
          offset++;
        }
        yield wrapCode;
      }
      yield ["", "template", endOffset, { __combineOffsetMapping: offset }];
    }
    function collectVars(ts3, node2, ast, results = []) {
      const identifiers = collectIdentifiers(ts3, node2, []);
      for (const [id] of identifiers) {
        results.push((0, scriptSetupRanges_1.getNodeText)(ts3, id, ast));
      }
      return results;
    }
    function collectIdentifiers(ts3, node2, results = [], isRest = false) {
      if (ts3.isIdentifier(node2)) {
        results.push([node2, isRest]);
      } else if (ts3.isObjectBindingPattern(node2)) {
        for (const el of node2.elements) {
          collectIdentifiers(ts3, el.name, results, !!el.dotDotDotToken);
        }
      } else if (ts3.isArrayBindingPattern(node2)) {
        for (const el of node2.elements) {
          if (ts3.isBindingElement(el)) {
            collectIdentifiers(ts3, el.name, results, !!el.dotDotDotToken);
          }
        }
      } else {
        ts3.forEachChild(node2, (node3) => collectIdentifiers(ts3, node3, results, false));
      }
      return results;
    }
    function createTsAst(ts3, astHolder, text6) {
      if (astHolder.__volar_ast_text !== text6) {
        astHolder.__volar_ast_text = text6;
        astHolder.__volar_ast = ts3.createSourceFile("/a.ts", text6, 99);
      }
      return astHolder.__volar_ast;
    }
    function generateSfcBlockSection(block, start, end, features) {
      return [
        block.content.substring(start, end),
        block.name,
        start,
        features
      ];
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/context.js
var require_context = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTemplateCodegenContext = createTemplateCodegenContext;
    var common_1 = require_common();
    var _codeFeatures = {
      all: {
        verification: true,
        completion: true,
        semantic: true,
        navigation: true
      },
      verification: {
        verification: true
      },
      completion: {
        completion: true
      },
      additionalCompletion: {
        completion: { isAdditional: true }
      },
      navigation: {
        navigation: true
      },
      navigationWithoutRename: {
        navigation: {
          shouldRename() {
            return false;
          }
        }
      },
      navigationAndCompletion: {
        navigation: true,
        completion: true
      },
      navigationAndAdditionalCompletion: {
        navigation: true,
        completion: { isAdditional: true }
      },
      withoutHighlight: {
        semantic: { shouldHighlight: () => false },
        verification: true,
        navigation: true,
        completion: true
      },
      withoutHighlightAndCompletion: {
        semantic: { shouldHighlight: () => false },
        verification: true,
        navigation: true
      },
      withoutHighlightAndCompletionAndNavigation: {
        semantic: { shouldHighlight: () => false },
        verification: true
      }
    };
    function createTemplateCodegenContext(options) {
      let ignoredError = false;
      let expectErrorToken;
      let variableId = 0;
      const codeFeatures = new Proxy(_codeFeatures, {
        get(target, key2) {
          const data = target[key2];
          if (data.verification) {
            if (ignoredError) {
              return {
                ...data,
                verification: false
              };
            }
            if (expectErrorToken) {
              const token2 = expectErrorToken;
              if (typeof data.verification !== "object" || !data.verification.shouldReport) {
                return {
                  ...data,
                  verification: {
                    shouldReport: () => {
                      token2.errors++;
                      return false;
                    }
                  }
                };
              }
            }
          }
          return data;
        }
      });
      const localVars = /* @__PURE__ */ new Map();
      const accessExternalVariables = /* @__PURE__ */ new Map();
      const slots = [];
      const dynamicSlots = [];
      const hasSlotElements = /* @__PURE__ */ new Set();
      ;
      const blockConditions = [];
      const usedComponentCtxVars = /* @__PURE__ */ new Set();
      const scopedClasses = [];
      const emptyClassOffsets = [];
      const inlayHints = [];
      const templateRefs = /* @__PURE__ */ new Map();
      return {
        slots,
        dynamicSlots,
        codeFeatures,
        accessExternalVariables,
        hasSlotElements,
        blockConditions,
        usedComponentCtxVars,
        scopedClasses,
        emptyClassOffsets,
        inlayHints,
        hasSlot: false,
        inheritedAttrVars: /* @__PURE__ */ new Set(),
        templateRefs,
        singleRootElType: void 0,
        singleRootNode: void 0,
        accessExternalVariable(name, offset) {
          let arr = accessExternalVariables.get(name);
          if (!arr) {
            accessExternalVariables.set(name, arr = /* @__PURE__ */ new Set());
          }
          if (offset !== void 0) {
            arr.add(offset);
          }
        },
        hasLocalVariable: (name) => {
          return !!localVars.get(name);
        },
        addLocalVariable: (name) => {
          localVars.set(name, (localVars.get(name) ?? 0) + 1);
        },
        removeLocalVariable: (name) => {
          localVars.set(name, localVars.get(name) - 1);
        },
        getInternalVariable: () => {
          return `__VLS_${variableId++}`;
        },
        ignoreError: function* () {
          if (!ignoredError) {
            ignoredError = true;
            yield `// @vue-ignore start${common_1.newLine}`;
          }
        },
        expectError: function* (prevNode) {
          if (!expectErrorToken) {
            expectErrorToken = {
              errors: 0,
              node: prevNode
            };
            yield `// @vue-expect-error start${common_1.newLine}`;
          }
        },
        resetDirectiveComments: function* (endStr) {
          if (expectErrorToken) {
            const token2 = expectErrorToken;
            yield* (0, common_1.wrapWith)(expectErrorToken.node.loc.start.offset, expectErrorToken.node.loc.end.offset, {
              verification: {
                shouldReport: () => token2.errors === 0
              }
            }, `// @ts-expect-error __VLS_TS_EXPECT_ERROR`);
            yield `${common_1.newLine}${common_1.endOfLine}`;
            expectErrorToken = void 0;
            yield `// @vue-expect-error ${endStr}${common_1.newLine}`;
          }
          if (ignoredError) {
            ignoredError = false;
            yield `// @vue-ignore ${endStr}${common_1.newLine}`;
          }
        },
        generateAutoImportCompletion: function* () {
          if (!options.edited) {
            return;
          }
          const all3 = [...accessExternalVariables.entries()];
          if (!all3.some(([_, offsets]) => offsets.size)) {
            return;
          }
          yield `// @ts-ignore${common_1.newLine}`;
          yield `[`;
          for (const [varName, offsets] of all3) {
            for (const offset of offsets) {
              if (options.scriptSetupBindingNames.has(varName)) {
                yield [
                  varName,
                  "template",
                  offset,
                  {
                    ...codeFeatures.additionalCompletion,
                    ...codeFeatures.withoutHighlightAndCompletionAndNavigation
                  }
                ];
              } else {
                yield [
                  varName,
                  "template",
                  offset,
                  codeFeatures.additionalCompletion
                ];
              }
              yield `,`;
            }
            offsets.clear();
          }
          yield `]${common_1.endOfLine}`;
        }
      };
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/camelized.js
var require_camelized = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/camelized.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateCamelized = generateCamelized;
    var shared_1 = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    var common_1 = require_common();
    function* generateCamelized(code3, offset, info) {
      const parts = code3.split("-");
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (part !== "") {
          if (i === 0) {
            yield [
              part,
              "template",
              offset,
              info
            ];
          } else {
            yield [
              (0, shared_1.capitalize)(part),
              "template",
              offset,
              common_1.combineLastMapping
            ];
          }
        }
        offset += part.length + 1;
      }
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/interpolation.js
var require_interpolation = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/interpolation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateInterpolation = generateInterpolation;
    exports.forEachInterpolationSegment = forEachInterpolationSegment;
    var shared_1 = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    var scriptSetupRanges_1 = require_scriptSetupRanges();
    var common_1 = require_common();
    function* generateInterpolation(options, ctx, _code, astHolder, start, data, prefix, suffix) {
      const code3 = prefix + _code + suffix;
      const ast = (0, common_1.createTsAst)(options.ts, astHolder, code3);
      for (let [section, offset, type] of forEachInterpolationSegment(options.ts, options.destructuredPropNames, options.templateRefNames, ctx, code3, start !== void 0 ? start - prefix.length : void 0, ast)) {
        if (offset === void 0) {
          yield section;
        } else {
          offset -= prefix.length;
          let addSuffix = "";
          const overLength = offset + section.length - _code.length;
          if (overLength > 0) {
            addSuffix = section.substring(section.length - overLength);
            section = section.substring(0, section.length - overLength);
          }
          if (offset < 0) {
            yield section.substring(0, -offset);
            section = section.substring(-offset);
            offset = 0;
          }
          const shouldSkip2 = section.length === 0 && (type === "startText" || type === "endText");
          if (!shouldSkip2) {
            if (start !== void 0 && data) {
              yield [
                section,
                "template",
                start + offset,
                type === "errorMappingOnly" ? ctx.codeFeatures.verification : typeof data === "function" ? data(start + offset) : data
              ];
            } else {
              yield section;
            }
          }
          yield addSuffix;
        }
      }
    }
    function* forEachInterpolationSegment(ts3, destructuredPropNames, templateRefNames, ctx, code3, offset, ast) {
      let ctxVars = [];
      const varCb = (id, isShorthand) => {
        const text6 = (0, scriptSetupRanges_1.getNodeText)(ts3, id, ast);
        if (ctx.hasLocalVariable(text6) || // https://github.com/vuejs/core/blob/245230e135152900189f13a4281302de45fdcfaa/packages/compiler-core/src/transforms/transformExpression.ts#L342-L352
        (0, shared_1.isGloballyWhitelisted)(text6) || text6 === "require" || text6.startsWith("__VLS_")) {
        } else {
          ctxVars.push({
            text: text6,
            isShorthand,
            offset: (0, scriptSetupRanges_1.getStartEnd)(ts3, id, ast).start
          });
          if (destructuredPropNames == null ? void 0 : destructuredPropNames.has(text6)) {
            return;
          }
          if (offset !== void 0) {
            ctx.accessExternalVariable(text6, offset + (0, scriptSetupRanges_1.getStartEnd)(ts3, id, ast).start);
          } else {
            ctx.accessExternalVariable(text6);
          }
        }
      };
      ts3.forEachChild(ast, (node2) => walkIdentifiers2(ts3, node2, ast, varCb, ctx));
      ctxVars = ctxVars.sort((a, b) => a.offset - b.offset);
      if (ctxVars.length) {
        if (ctxVars[0].isShorthand) {
          yield [code3.substring(0, ctxVars[0].offset + ctxVars[0].text.length), 0];
          yield [": ", void 0];
        } else if (ctxVars[0].offset > 0) {
          yield [code3.substring(0, ctxVars[0].offset), 0, "startText"];
        }
        for (let i = 0; i < ctxVars.length - 1; i++) {
          const curVar = ctxVars[i];
          const nextVar = ctxVars[i + 1];
          yield* generateVar(code3, destructuredPropNames, templateRefNames, curVar, nextVar);
          if (nextVar.isShorthand) {
            yield [code3.substring(curVar.offset + curVar.text.length, nextVar.offset + nextVar.text.length), curVar.offset + curVar.text.length];
            yield [": ", void 0];
          } else {
            yield [code3.substring(curVar.offset + curVar.text.length, nextVar.offset), curVar.offset + curVar.text.length];
          }
        }
        const lastVar = ctxVars.at(-1);
        yield* generateVar(code3, destructuredPropNames, templateRefNames, lastVar);
        if (lastVar.offset + lastVar.text.length < code3.length) {
          yield [code3.substring(lastVar.offset + lastVar.text.length), lastVar.offset + lastVar.text.length, "endText"];
        }
      } else {
        yield [code3, 0];
      }
    }
    function* generateVar(code3, destructuredPropNames, templateRefNames, curVar, nextVar = curVar) {
      yield ["", nextVar.offset, "errorMappingOnly"];
      const isDestructuredProp = (destructuredPropNames == null ? void 0 : destructuredPropNames.has(curVar.text)) ?? false;
      const isTemplateRef = (templateRefNames == null ? void 0 : templateRefNames.has(curVar.text)) ?? false;
      if (isTemplateRef) {
        yield [`__VLS_unref(`, void 0];
        yield [code3.substring(curVar.offset, curVar.offset + curVar.text.length), curVar.offset];
        yield [`)`, void 0];
      } else {
        if (!isDestructuredProp) {
          yield [`__VLS_ctx.`, void 0];
        }
        yield [code3.substring(curVar.offset, curVar.offset + curVar.text.length), curVar.offset];
      }
    }
    function walkIdentifiers2(ts3, node2, ast, cb, ctx, blockVars = [], isRoot = true) {
      if (ts3.isIdentifier(node2)) {
        cb(node2, false);
      } else if (ts3.isShorthandPropertyAssignment(node2)) {
        cb(node2.name, true);
      } else if (ts3.isPropertyAccessExpression(node2)) {
        walkIdentifiers2(ts3, node2.expression, ast, cb, ctx, blockVars, false);
      } else if (ts3.isVariableDeclaration(node2)) {
        (0, common_1.collectVars)(ts3, node2.name, ast, blockVars);
        for (const varName of blockVars) {
          ctx.addLocalVariable(varName);
        }
        if (node2.initializer) {
          walkIdentifiers2(ts3, node2.initializer, ast, cb, ctx, blockVars, false);
        }
      } else if (ts3.isArrowFunction(node2) || ts3.isFunctionExpression(node2)) {
        processFunction(ts3, node2, ast, cb, ctx);
      } else if (ts3.isObjectLiteralExpression(node2)) {
        for (const prop of node2.properties) {
          if (ts3.isPropertyAssignment(prop)) {
            if (ts3.isComputedPropertyName(prop.name)) {
              walkIdentifiers2(ts3, prop.name.expression, ast, cb, ctx, blockVars, false);
            }
            walkIdentifiers2(ts3, prop.initializer, ast, cb, ctx, blockVars, false);
          } else if (ts3.isShorthandPropertyAssignment(prop)) {
            walkIdentifiers2(ts3, prop, ast, cb, ctx, blockVars, false);
          } else if (ts3.isSpreadAssignment(prop)) {
            walkIdentifiers2(ts3, prop.expression, ast, cb, ctx, blockVars, false);
          } else if (ts3.isFunctionLike(prop) && prop.body) {
            processFunction(ts3, prop, ast, cb, ctx);
          }
        }
      } else if (ts3.isTypeReferenceNode(node2)) {
        ts3.forEachChild(node2, (node3) => walkIdentifiersInTypeReference(ts3, node3, cb));
      } else {
        const _blockVars = blockVars;
        if (ts3.isBlock(node2)) {
          blockVars = [];
        }
        ts3.forEachChild(node2, (node3) => walkIdentifiers2(ts3, node3, ast, cb, ctx, blockVars, false));
        if (ts3.isBlock(node2)) {
          for (const varName of blockVars) {
            ctx.removeLocalVariable(varName);
          }
        }
        blockVars = _blockVars;
      }
      if (isRoot) {
        for (const varName of blockVars) {
          ctx.removeLocalVariable(varName);
        }
      }
    }
    function processFunction(ts3, node2, ast, cb, ctx) {
      const functionArgs = [];
      for (const param of node2.parameters) {
        (0, common_1.collectVars)(ts3, param.name, ast, functionArgs);
        if (param.type) {
          walkIdentifiers2(ts3, param.type, ast, cb, ctx);
        }
      }
      for (const varName of functionArgs) {
        ctx.addLocalVariable(varName);
      }
      if (node2.body) {
        walkIdentifiers2(ts3, node2.body, ast, cb, ctx);
      }
      for (const varName of functionArgs) {
        ctx.removeLocalVariable(varName);
      }
    }
    function walkIdentifiersInTypeReference(ts3, node2, cb) {
      if (ts3.isTypeQueryNode(node2) && ts3.isIdentifier(node2.exprName)) {
        cb(node2.exprName, false);
      } else {
        ts3.forEachChild(node2, (node3) => walkIdentifiersInTypeReference(ts3, node3, cb));
      }
    }
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r4 = range3(a, b, str);
      return r4 && {
        start: r4[0],
        end: r4[1],
        pre: str.slice(0, r4[0]),
        body: str.slice(r4[0] + a.length, r4[1]),
        post: str.slice(r4[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range3;
    function range3(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body3 = m.body;
      var post = m.post;
      var p2 = pre.split(",");
      p2[p2.length - 1] += "{" + body3 + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p2[p2.length - 1] += postParts.shift();
        p2.push.apply(p2, postParts);
      }
      parts.push.apply(parts, p2);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m) return [str];
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p2) {
                return m.pre + n[0] + p2;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/dist/commonjs/assert-valid-pattern.js
var require_assert_valid_pattern = __commonJS({
  "node_modules/minimatch/dist/commonjs/assert-valid-pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertValidPattern = void 0;
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    exports.assertValidPattern = assertValidPattern;
  }
});

// node_modules/minimatch/dist/commonjs/brace-expressions.js
var require_brace_expressions = __commonJS({
  "node_modules/minimatch/dist/commonjs/brace-expressions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseClass = void 0;
    var posixClasses = {
      "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
      "[:alpha:]": ["\\p{L}\\p{Nl}", true],
      "[:ascii:]": ["\\x00-\\x7f", false],
      "[:blank:]": ["\\p{Zs}\\t", true],
      "[:cntrl:]": ["\\p{Cc}", true],
      "[:digit:]": ["\\p{Nd}", true],
      "[:graph:]": ["\\p{Z}\\p{C}", true, true],
      "[:lower:]": ["\\p{Ll}", true],
      "[:print:]": ["\\p{C}", true],
      "[:punct:]": ["\\p{P}", true],
      "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
      "[:upper:]": ["\\p{Lu}", true],
      "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
      "[:xdigit:]": ["A-Fa-f0-9", false]
    };
    var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
    var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var rangesToString = (ranges) => ranges.join("");
    var parseClass = (glob, position3) => {
      const pos = position3;
      if (glob.charAt(pos) !== "[") {
        throw new Error("not in a brace expression");
      }
      const ranges = [];
      const negs = [];
      let i = pos + 1;
      let sawStart = false;
      let uflag = false;
      let escaping = false;
      let negate = false;
      let endPos = pos;
      let rangeStart = "";
      WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = true;
          i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        sawStart = true;
        if (c === "\\") {
          if (!escaping) {
            escaping = true;
            i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob.startsWith(cls, i)) {
              if (rangeStart) {
                return ["$.", false, glob.length - pos, true];
              }
              i += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          } else if (c === rangeStart) {
            ranges.push(braceEscape(c));
          }
          rangeStart = "";
          i++;
          continue;
        }
        if (glob.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-"));
          i += 2;
          continue;
        }
        if (glob.startsWith("-", i + 1)) {
          rangeStart = c;
          i += 2;
          continue;
        }
        ranges.push(braceEscape(c));
        i++;
      }
      if (endPos < i) {
        return ["", false, 0, false];
      }
      if (!ranges.length && !negs.length) {
        return ["$.", false, glob.length - pos, true];
      }
      if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
        const r4 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r4), false, endPos - pos, false];
      }
      const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
      const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
      const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
      return [comb, uflag, endPos - pos, true];
    };
    exports.parseClass = parseClass;
  }
});

// node_modules/minimatch/dist/commonjs/unescape.js
var require_unescape = __commonJS({
  "node_modules/minimatch/dist/commonjs/unescape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unescape = void 0;
    var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
    };
    exports.unescape = unescape;
  }
});

// node_modules/minimatch/dist/commonjs/ast.js
var require_ast = __commonJS({
  "node_modules/minimatch/dist/commonjs/ast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AST = void 0;
    var brace_expressions_js_1 = require_brace_expressions();
    var unescape_js_1 = require_unescape();
    var types2 = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
    var isExtglobType = (c) => types2.has(c);
    var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
    var startNoDot = "(?!\\.)";
    var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
    var justDots = /* @__PURE__ */ new Set(["..", "."]);
    var reSpecials = new Set("().*{}+?[]^$\\!");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var qmark = "[^/]";
    var star = qmark + "*?";
    var starNoEmpty = qmark + "+?";
    var _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _AST_instances, fillNegs_fn, _AST_static, parseAST_fn, partsToRegExp_fn, parseGlob_fn;
    var _AST = class _AST {
      constructor(type, parent, options = {}) {
        __privateAdd(this, _AST_instances);
        __publicField(this, "type");
        __privateAdd(this, _root);
        __privateAdd(this, _hasMagic);
        __privateAdd(this, _uflag, false);
        __privateAdd(this, _parts, []);
        __privateAdd(this, _parent);
        __privateAdd(this, _parentIndex);
        __privateAdd(this, _negs);
        __privateAdd(this, _filledNegs, false);
        __privateAdd(this, _options);
        __privateAdd(this, _toString);
        // set to true if it's an extglob with no children
        // (which really means one child of '')
        __privateAdd(this, _emptyExt, false);
        this.type = type;
        if (type)
          __privateSet(this, _hasMagic, true);
        __privateSet(this, _parent, parent);
        __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
        __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(__privateGet(this, _root), _options));
        __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
        if (type === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
          __privateGet(this, _negs).push(this);
        __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
      }
      get hasMagic() {
        if (__privateGet(this, _hasMagic) !== void 0)
          return __privateGet(this, _hasMagic);
        for (const p2 of __privateGet(this, _parts)) {
          if (typeof p2 === "string")
            continue;
          if (p2.type || p2.hasMagic)
            return __privateSet(this, _hasMagic, true);
        }
        return __privateGet(this, _hasMagic);
      }
      // reconstructs the pattern
      toString() {
        if (__privateGet(this, _toString) !== void 0)
          return __privateGet(this, _toString);
        if (!this.type) {
          return __privateSet(this, _toString, __privateGet(this, _parts).map((p2) => String(p2)).join(""));
        } else {
          return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p2) => String(p2)).join("|") + ")");
        }
      }
      push(...parts) {
        for (const p2 of parts) {
          if (p2 === "")
            continue;
          if (typeof p2 !== "string" && !(p2 instanceof _AST && __privateGet(p2, _parent) === this)) {
            throw new Error("invalid part: " + p2);
          }
          __privateGet(this, _parts).push(p2);
        }
      }
      toJSON() {
        var _a;
        const ret = this.type === null ? __privateGet(this, _parts).slice().map((p2) => typeof p2 === "string" ? p2 : p2.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p2) => p2.toJSON())];
        if (this.isStart() && !this.type)
          ret.unshift([]);
        if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && ((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!")) {
          ret.push({});
        }
        return ret;
      }
      isStart() {
        var _a;
        if (__privateGet(this, _root) === this)
          return true;
        if (!((_a = __privateGet(this, _parent)) == null ? void 0 : _a.isStart()))
          return false;
        if (__privateGet(this, _parentIndex) === 0)
          return true;
        const p2 = __privateGet(this, _parent);
        for (let i = 0; i < __privateGet(this, _parentIndex); i++) {
          const pp = __privateGet(p2, _parts)[i];
          if (!(pp instanceof _AST && pp.type === "!")) {
            return false;
          }
        }
        return true;
      }
      isEnd() {
        var _a, _b, _c;
        if (__privateGet(this, _root) === this)
          return true;
        if (((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!")
          return true;
        if (!((_b = __privateGet(this, _parent)) == null ? void 0 : _b.isEnd()))
          return false;
        if (!this.type)
          return (_c = __privateGet(this, _parent)) == null ? void 0 : _c.isEnd();
        const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
        return __privateGet(this, _parentIndex) === pl - 1;
      }
      copyIn(part) {
        if (typeof part === "string")
          this.push(part);
        else
          this.push(part.clone(this));
      }
      clone(parent) {
        const c = new _AST(this.type, parent);
        for (const p2 of __privateGet(this, _parts)) {
          c.copyIn(p2);
        }
        return c;
      }
      static fromGlob(pattern, options = {}) {
        var _a;
        const ast = new _AST(null, void 0, options);
        __privateMethod(_a = _AST, _AST_static, parseAST_fn).call(_a, pattern, ast, 0, options);
        return ast;
      }
      // returns the regular expression if there's magic, or the unescaped
      // string if not.
      toMMPattern() {
        if (this !== __privateGet(this, _root))
          return __privateGet(this, _root).toMMPattern();
        const glob = this.toString();
        const [re2, body3, hasMagic, uflag] = this.toRegExpSource();
        const anyMagic = hasMagic || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
        if (!anyMagic) {
          return body3;
        }
        const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
        return Object.assign(new RegExp(`^${re2}$`, flags), {
          _src: re2,
          _glob: glob
        });
      }
      get options() {
        return __privateGet(this, _options);
      }
      // returns the string match, the regexp source, whether there's magic
      // in the regexp (so a regular expression is required) and whether or
      // not the uflag is needed for the regular expression (for posix classes)
      // TODO: instead of injecting the start/end at this point, just return
      // the BODY of the regexp, along with the start/end portions suitable
      // for binding the start/end in either a joined full-path makeRe context
      // (where we bind to (^|/), or a standalone matchPart context (where
      // we bind to ^, and not /).  Otherwise slashes get duped!
      //
      // In part-matching mode, the start is:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: ^(?!\.\.?$)
      // - if dots allowed or not possible: ^
      // - if dots possible and not allowed: ^(?!\.)
      // end is:
      // - if not isEnd(): nothing
      // - else: $
      //
      // In full-path matching mode, we put the slash at the START of the
      // pattern, so start is:
      // - if first pattern: same as part-matching mode
      // - if not isStart(): nothing
      // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
      // - if dots allowed or not possible: /
      // - if dots possible and not allowed: /(?!\.)
      // end is:
      // - if last pattern, same as part-matching mode
      // - else nothing
      //
      // Always put the (?:$|/) on negated tails, though, because that has to be
      // there to bind the end of the negated pattern portion, and it's easier to
      // just stick it in now rather than try to inject it later in the middle of
      // the pattern.
      //
      // We can just always return the same end, and leave it up to the caller
      // to know whether it's going to be used joined or in parts.
      // And, if the start is adjusted slightly, can do the same there:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
      // - if dots allowed or not possible: (?:/|^)
      // - if dots possible and not allowed: (?:/|^)(?!\.)
      //
      // But it's better to have a simpler binding without a conditional, for
      // performance, so probably better to return both start options.
      //
      // Then the caller just ignores the end if it's not the first pattern,
      // and the start always gets applied.
      //
      // But that's always going to be $ if it's the ending pattern, or nothing,
      // so the caller can just attach $ at the end of the pattern when building.
      //
      // So the todo is:
      // - better detect what kind of start is needed
      // - return both flavors of starting pattern
      // - attach $ at the end of the pattern when creating the actual RegExp
      //
      // Ah, but wait, no, that all only applies to the root when the first pattern
      // is not an extglob. If the first pattern IS an extglob, then we need all
      // that dot prevention biz to live in the extglob portions, because eg
      // +(*|.x*) can match .xy but not .yx.
      //
      // So, return the two flavors if it's #root and the first child is not an
      // AST, otherwise leave it to the child AST to handle it, and there,
      // use the (?:^|/) style of start binding.
      //
      // Even simplified further:
      // - Since the start for a join is eg /(?!\.) and the start for a part
      // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
      // or start or whatever) and prepend ^ or / at the Regexp construction.
      toRegExpSource(allowDot) {
        var _a;
        const dot = allowDot ?? !!__privateGet(this, _options).dot;
        if (__privateGet(this, _root) === this)
          __privateMethod(this, _AST_instances, fillNegs_fn).call(this);
        if (!this.type) {
          const noEmpty = this.isStart() && this.isEnd();
          const src = __privateGet(this, _parts).map((p2) => {
            var _a2;
            const [re2, _, hasMagic, uflag] = typeof p2 === "string" ? __privateMethod(_a2 = _AST, _AST_static, parseGlob_fn).call(_a2, p2, __privateGet(this, _hasMagic), noEmpty) : p2.toRegExpSource(allowDot);
            __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic);
            __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
            return re2;
          }).join("");
          let start2 = "";
          if (this.isStart()) {
            if (typeof __privateGet(this, _parts)[0] === "string") {
              const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
              if (!dotTravAllowed) {
                const aps = addPatternStart;
                const needNoTrav = (
                  // dots are allowed, and the pattern starts with [ or .
                  dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
                  src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
                  src.startsWith("\\.\\.") && aps.has(src.charAt(4))
                );
                const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
              }
            }
          }
          let end = "";
          if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && ((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!") {
            end = "(?:$|\\/)";
          }
          const final2 = start2 + src + end;
          return [
            final2,
            (0, unescape_js_1.unescape)(src),
            __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
            __privateGet(this, _uflag)
          ];
        }
        const repeated = this.type === "*" || this.type === "+";
        const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
        let body3 = __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, dot);
        if (this.isStart() && this.isEnd() && !body3 && this.type !== "!") {
          const s = this.toString();
          __privateSet(this, _parts, [s]);
          this.type = null;
          __privateSet(this, _hasMagic, void 0);
          return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
        }
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, true);
        if (bodyDotAllowed === body3) {
          bodyDotAllowed = "";
        }
        if (bodyDotAllowed) {
          body3 = `(?:${body3})(?:${bodyDotAllowed})*?`;
        }
        let final = "";
        if (this.type === "!" && __privateGet(this, _emptyExt)) {
          final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
        } else {
          const close = this.type === "!" ? (
            // !() must match something,but !(x) can match ''
            "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
          ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
          final = start + body3 + close;
        }
        return [
          final,
          (0, unescape_js_1.unescape)(body3),
          __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
          __privateGet(this, _uflag)
        ];
      }
    };
    _root = new WeakMap();
    _hasMagic = new WeakMap();
    _uflag = new WeakMap();
    _parts = new WeakMap();
    _parent = new WeakMap();
    _parentIndex = new WeakMap();
    _negs = new WeakMap();
    _filledNegs = new WeakMap();
    _options = new WeakMap();
    _toString = new WeakMap();
    _emptyExt = new WeakMap();
    _AST_instances = new WeakSet();
    fillNegs_fn = function() {
      if (this !== __privateGet(this, _root))
        throw new Error("should only call on root");
      if (__privateGet(this, _filledNegs))
        return this;
      this.toString();
      __privateSet(this, _filledNegs, true);
      let n;
      while (n = __privateGet(this, _negs).pop()) {
        if (n.type !== "!")
          continue;
        let p2 = n;
        let pp = __privateGet(p2, _parent);
        while (pp) {
          for (let i = __privateGet(p2, _parentIndex) + 1; !pp.type && i < __privateGet(pp, _parts).length; i++) {
            for (const part of __privateGet(n, _parts)) {
              if (typeof part === "string") {
                throw new Error("string part in extglob AST??");
              }
              part.copyIn(__privateGet(pp, _parts)[i]);
            }
          }
          p2 = pp;
          pp = __privateGet(p2, _parent);
        }
      }
      return this;
    };
    _AST_static = new WeakSet();
    parseAST_fn = function(str, ast, pos, opt) {
      var _a, _b;
      let escaping = false;
      let inBrace = false;
      let braceStart = -1;
      let braceNeg = false;
      if (ast.type === null) {
        let i2 = pos;
        let acc2 = "";
        while (i2 < str.length) {
          const c = str.charAt(i2++);
          if (escaping || c === "\\") {
            escaping = !escaping;
            acc2 += c;
            continue;
          }
          if (inBrace) {
            if (i2 === braceStart + 1) {
              if (c === "^" || c === "!") {
                braceNeg = true;
              }
            } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
              inBrace = false;
            }
            acc2 += c;
            continue;
          } else if (c === "[") {
            inBrace = true;
            braceStart = i2;
            braceNeg = false;
            acc2 += c;
            continue;
          }
          if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
            ast.push(acc2);
            acc2 = "";
            const ext = new _AST(c, ast);
            i2 = __privateMethod(_a = _AST, _AST_static, parseAST_fn).call(_a, str, ext, i2, opt);
            ast.push(ext);
            continue;
          }
          acc2 += c;
        }
        ast.push(acc2);
        return i2;
      }
      let i = pos + 1;
      let part = new _AST(null, ast);
      const parts = [];
      let acc = "";
      while (i < str.length) {
        const c = str.charAt(i++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc += c;
          continue;
        }
        if (inBrace) {
          if (i === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i;
          braceNeg = false;
          acc += c;
          continue;
        }
        if (isExtglobType(c) && str.charAt(i) === "(") {
          part.push(acc);
          acc = "";
          const ext = new _AST(c, part);
          part.push(ext);
          i = __privateMethod(_b = _AST, _AST_static, parseAST_fn).call(_b, str, ext, i, opt);
          continue;
        }
        if (c === "|") {
          part.push(acc);
          acc = "";
          parts.push(part);
          part = new _AST(null, ast);
          continue;
        }
        if (c === ")") {
          if (acc === "" && __privateGet(ast, _parts).length === 0) {
            __privateSet(ast, _emptyExt, true);
          }
          part.push(acc);
          acc = "";
          ast.push(...parts, part);
          return i;
        }
        acc += c;
      }
      ast.type = null;
      __privateSet(ast, _hasMagic, void 0);
      __privateSet(ast, _parts, [str.substring(pos - 1)]);
      return i;
    };
    partsToRegExp_fn = function(dot) {
      return __privateGet(this, _parts).map((p2) => {
        if (typeof p2 === "string") {
          throw new Error("string type in extglob ast??");
        }
        const [re2, _, _hasMagic2, uflag] = p2.toRegExpSource(dot);
        __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
        return re2;
      }).filter((p2) => !(this.isStart() && this.isEnd()) || !!p2).join("|");
    };
    parseGlob_fn = function(glob, hasMagic, noEmpty = false) {
      let escaping = false;
      let re2 = "";
      let uflag = false;
      for (let i = 0; i < glob.length; i++) {
        const c = glob.charAt(i);
        if (escaping) {
          escaping = false;
          re2 += (reSpecials.has(c) ? "\\" : "") + c;
          continue;
        }
        if (c === "\\") {
          if (i === glob.length - 1) {
            re2 += "\\\\";
          } else {
            escaping = true;
          }
          continue;
        }
        if (c === "[") {
          const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
          if (consumed) {
            re2 += src;
            uflag = uflag || needUflag;
            i += consumed - 1;
            hasMagic = hasMagic || magic;
            continue;
          }
        }
        if (c === "*") {
          if (noEmpty && glob === "*")
            re2 += starNoEmpty;
          else
            re2 += star;
          hasMagic = true;
          continue;
        }
        if (c === "?") {
          re2 += qmark;
          hasMagic = true;
          continue;
        }
        re2 += regExpEscape(c);
      }
      return [re2, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
    };
    __privateAdd(_AST, _AST_static);
    var AST = _AST;
    exports.AST = AST;
  }
});

// node_modules/minimatch/dist/commonjs/escape.js
var require_escape = __commonJS({
  "node_modules/minimatch/dist/commonjs/escape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escape = void 0;
    var escape = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
    };
    exports.escape = escape;
  }
});

// node_modules/minimatch/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/minimatch/dist/commonjs/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
    var brace_expansion_1 = __importDefault(require_brace_expansion());
    var assert_valid_pattern_js_1 = require_assert_valid_pattern();
    var ast_js_1 = require_ast();
    var escape_js_1 = require_escape();
    var unescape_js_1 = require_unescape();
    var minimatch = (p2, pattern, options = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p2);
    };
    exports.minimatch = minimatch;
    var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
    var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
    var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
    var starDotExtTestNocase = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
    };
    var starDotExtTestNocaseDot = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => f.toLowerCase().endsWith(ext2);
    };
    var starDotStarRE = /^\*+\.\*+$/;
    var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
    var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
    var dotStarRE = /^\.\*+$/;
    var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
    var starRE = /^\*+$/;
    var starTest = (f) => f.length !== 0 && !f.startsWith(".");
    var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
    var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
    var qmarksTestNocase = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTest = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTestNoExt = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && !f.startsWith(".");
    };
    var qmarksTestNoExtDot = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && f !== "." && f !== "..";
    };
    var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
    var path = {
      win32: { sep: "\\" },
      posix: { sep: "/" }
    };
    exports.sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
    exports.minimatch.sep = exports.sep;
    exports.GLOBSTAR = Symbol("globstar **");
    exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var filter = (pattern, options = {}) => (p2) => (0, exports.minimatch)(p2, pattern, options);
    exports.filter = filter;
    exports.minimatch.filter = exports.filter;
    var ext = (a, b = {}) => Object.assign({}, a, b);
    var defaults2 = (def2) => {
      if (!def2 || typeof def2 !== "object" || !Object.keys(def2).length) {
        return exports.minimatch;
      }
      const orig = exports.minimatch;
      const m = (p2, pattern, options = {}) => orig(p2, pattern, ext(def2, options));
      return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
          constructor(pattern, options = {}) {
            super(pattern, ext(def2, options));
          }
          static defaults(options) {
            return orig.defaults(ext(def2, options)).Minimatch;
          }
        },
        AST: class AST extends orig.AST {
          /* c8 ignore start */
          constructor(type, parent, options = {}) {
            super(type, parent, ext(def2, options));
          }
          /* c8 ignore stop */
          static fromGlob(pattern, options = {}) {
            return orig.AST.fromGlob(pattern, ext(def2, options));
          }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def2, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def2, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def2, options)),
        defaults: (options) => orig.defaults(ext(def2, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def2, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def2, options)),
        match: (list4, pattern, options = {}) => orig.match(list4, pattern, ext(def2, options)),
        sep: orig.sep,
        GLOBSTAR: exports.GLOBSTAR
      });
    };
    exports.defaults = defaults2;
    exports.minimatch.defaults = exports.defaults;
    var braceExpand = (pattern, options = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return (0, brace_expansion_1.default)(pattern);
    };
    exports.braceExpand = braceExpand;
    exports.minimatch.braceExpand = exports.braceExpand;
    var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
    exports.makeRe = makeRe;
    exports.minimatch.makeRe = exports.makeRe;
    var match = (list4, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list4 = list4.filter((f) => mm.match(f));
      if (mm.options.nonull && !list4.length) {
        list4.push(pattern);
      }
      return list4;
    };
    exports.match = match;
    exports.minimatch.match = exports.match;
    var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options = {}) {
        __publicField(this, "options");
        __publicField(this, "set");
        __publicField(this, "pattern");
        __publicField(this, "windowsPathsNoEscape");
        __publicField(this, "nonegate");
        __publicField(this, "negate");
        __publicField(this, "comment");
        __publicField(this, "empty");
        __publicField(this, "preserveMultipleSlashes");
        __publicField(this, "partial");
        __publicField(this, "globSet");
        __publicField(this, "globParts");
        __publicField(this, "nocase");
        __publicField(this, "isWindows");
        __publicField(this, "platform");
        __publicField(this, "windowsNoMagicRoot");
        __publicField(this, "regexp");
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === "win32";
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        this.make();
      }
      hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
          return true;
        }
        for (const pattern of this.set) {
          for (const part of pattern) {
            if (typeof part !== "string")
              return true;
          }
        }
        return false;
      }
      debug(..._) {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
          this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        let set = this.globParts.map((s, _, __) => {
          if (this.isWindows && this.windowsNoMagicRoot) {
            const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
            const isDrive = /^[a-z]:/i.test(s[0]);
            if (isUNC) {
              return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
            } else if (isDrive) {
              return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
            }
          }
          return s.map((ss) => this.parse(ss));
        });
        this.debug(this.pattern, set);
        this.set = set.filter((s) => s.indexOf(false) === -1);
        if (this.isWindows) {
          for (let i = 0; i < this.set.length; i++) {
            const p2 = this.set[i];
            if (p2[0] === "" && p2[1] === "" && this.globParts[i][2] === "?" && typeof p2[3] === "string" && /^[a-z]:$/i.test(p2[3])) {
              p2[2] = "?";
            }
          }
        }
        this.debug(this.pattern, this.set);
      }
      // various transforms to equivalent pattern sets that are
      // faster to process in a filesystem walk.  The goal is to
      // eliminate what we can, and push all ** patterns as far
      // to the right as possible, even if it increases the number
      // of patterns that we have to process.
      preprocess(globParts) {
        if (this.options.noglobstar) {
          for (let i = 0; i < globParts.length; i++) {
            for (let j = 0; j < globParts[i].length; j++) {
              if (globParts[i][j] === "**") {
                globParts[i][j] = "*";
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          globParts = this.firstPhasePreProcess(globParts);
          globParts = this.secondPhasePreProcess(globParts);
        } else if (optimizationLevel >= 1) {
          globParts = this.levelOneOptimize(globParts);
        } else {
          globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
      }
      // just get rid of adjascent ** portions
      adjascentGlobstarOptimize(globParts) {
        return globParts.map((parts) => {
          let gs = -1;
          while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
            let i = gs;
            while (parts[i + 1] === "**") {
              i++;
            }
            if (i !== gs) {
              parts.splice(gs, i - gs);
            }
          }
          return parts;
        });
      }
      // get rid of adjascent ** and resolve .. portions
      levelOneOptimize(globParts) {
        return globParts.map((parts) => {
          parts = parts.reduce((set, part) => {
            const prev = set[set.length - 1];
            if (part === "**" && prev === "**") {
              return set;
            }
            if (part === "..") {
              if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                set.pop();
                return set;
              }
            }
            set.push(part);
            return set;
          }, []);
          return parts.length === 0 ? [""] : parts;
        });
      }
      levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
          parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
          didSomething = false;
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              const p2 = parts[i];
              if (i === 1 && p2 === "" && parts[0] === "")
                continue;
              if (p2 === "." || p2 === "") {
                didSomething = true;
                parts.splice(i, 1);
                i--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd2 = 0;
          while (-1 !== (dd2 = parts.indexOf("..", dd2 + 1))) {
            const p2 = parts[dd2 - 1];
            if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
              didSomething = true;
              parts.splice(dd2 - 1, 2);
              dd2 -= 2;
            }
          }
        } while (didSomething);
        return parts.length === 0 ? [""] : parts;
      }
      // First phase: single-pattern processing
      // <pre> is 1 or more portions
      // <rest> is 1 or more portions
      // <p> is any portion other than ., .., '', or **
      // <e> is . or ''
      //
      // **/.. is *brutal* for filesystem walking performance, because
      // it effectively resets the recursive walk each time it occurs,
      // and ** cannot be reduced out by a .. pattern part like a regexp
      // or most strings (other than .., ., and '') can be.
      //
      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
      // <pre>/<e>/<rest> -> <pre>/<rest>
      // <pre>/<p>/../<rest> -> <pre>/<rest>
      // **/**/<rest> -> **/<rest>
      //
      // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
      // this WOULD be allowed if ** did follow symlinks, or * didn't
      firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
          didSomething = false;
          for (let parts of globParts) {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
              let gss = gs;
              while (parts[gss + 1] === "**") {
                gss++;
              }
              if (gss > gs) {
                parts.splice(gs + 1, gss - gs);
              }
              let next = parts[gs + 1];
              const p2 = parts[gs + 2];
              const p22 = parts[gs + 3];
              if (next !== "..")
                continue;
              if (!p2 || p2 === "." || p2 === ".." || !p22 || p22 === "." || p22 === "..") {
                continue;
              }
              didSomething = true;
              parts.splice(gs, 1);
              const other = parts.slice(0);
              other[gs] = "**";
              globParts.push(other);
              gs--;
            }
            if (!this.preserveMultipleSlashes) {
              for (let i = 1; i < parts.length - 1; i++) {
                const p2 = parts[i];
                if (i === 1 && p2 === "" && parts[0] === "")
                  continue;
                if (p2 === "." || p2 === "") {
                  didSomething = true;
                  parts.splice(i, 1);
                  i--;
                }
              }
              if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
                didSomething = true;
                parts.pop();
              }
            }
            let dd2 = 0;
            while (-1 !== (dd2 = parts.indexOf("..", dd2 + 1))) {
              const p2 = parts[dd2 - 1];
              if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
                didSomething = true;
                const needDot = dd2 === 1 && parts[dd2 + 1] === "**";
                const splin = needDot ? ["."] : [];
                parts.splice(dd2 - 1, 2, ...splin);
                if (parts.length === 0)
                  parts.push("");
                dd2 -= 2;
              }
            }
          }
        } while (didSomething);
        return globParts;
      }
      // second phase: multi-pattern dedupes
      // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
      // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
      // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
      //
      // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
      // ^-- not valid because ** doens't follow symlinks
      secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
          for (let j = i + 1; j < globParts.length; j++) {
            const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
            if (matched) {
              globParts[i] = [];
              globParts[j] = matched;
              break;
            }
          }
        }
        return globParts.filter((gs) => gs.length);
      }
      partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = "";
        while (ai < a.length && bi < b.length) {
          if (a[ai] === b[bi]) {
            result.push(which === "b" ? b[bi] : a[ai]);
            ai++;
            bi++;
          } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
            result.push(a[ai]);
            ai++;
          } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
            result.push(b[bi]);
            bi++;
          } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
            if (which === "b")
              return false;
            which = "a";
            result.push(a[ai]);
            ai++;
            bi++;
          } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
            if (which === "a")
              return false;
            which = "b";
            result.push(b[bi]);
            ai++;
            bi++;
          } else {
            return false;
          }
        }
        return a.length === b.length && result;
      }
      parseNegate() {
        if (this.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial = false) {
        const options = this.options;
        if (this.isWindows) {
          const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
          const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
          const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
          const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
          const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
          const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
          if (typeof fdi === "number" && typeof pdi === "number") {
            const [fd, pd] = [file[fdi], pattern[pdi]];
            if (fd.toLowerCase() === pd.toLowerCase()) {
              pattern[pdi] = fd;
              if (pdi > fdi) {
                pattern = pattern.slice(pdi);
              } else if (fdi > pdi) {
                file = file.slice(fdi);
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          file = this.levelTwoFileOptimize(file);
        }
        this.debug("matchOne", this, { file, pattern });
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p2 = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p2, f);
          if (p2 === false) {
            return false;
          }
          if (p2 === exports.GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p2, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl) {
                return true;
              }
            }
            return false;
          }
          let hit;
          if (typeof p2 === "string") {
            hit = f === p2;
            this.debug("string match", p2, f, hit);
          } else {
            hit = p2.test(f);
            this.debug("pattern match", p2, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        } else {
          throw new Error("wtf?");
        }
      }
      braceExpand() {
        return (0, exports.braceExpand)(this.pattern, this.options);
      }
      parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        if (pattern === "**")
          return exports.GLOBSTAR;
        if (pattern === "")
          return "";
        let m;
        let fastTest = null;
        if (m = pattern.match(starRE)) {
          fastTest = options.dot ? starTestDot : starTest;
        } else if (m = pattern.match(starDotExtRE)) {
          fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
        } else if (m = pattern.match(qmarksRE)) {
          fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
        } else if (m = pattern.match(starDotStarRE)) {
          fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        } else if (m = pattern.match(dotStarRE)) {
          fastTest = dotStarTest;
        }
        const re2 = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re2 === "object") {
          Reflect.defineProperty(re2, "test", { value: fastTest });
        }
        return re2;
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = new Set(options.nocase ? ["i"] : []);
        let re2 = set.map((pattern) => {
          const pp = pattern.map((p2) => {
            if (p2 instanceof RegExp) {
              for (const f of p2.flags.split(""))
                flags.add(f);
            }
            return typeof p2 === "string" ? regExpEscape(p2) : p2 === exports.GLOBSTAR ? exports.GLOBSTAR : p2._src;
          });
          pp.forEach((p2, i) => {
            const next = pp[i + 1];
            const prev = pp[i - 1];
            if (p2 !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
              return;
            }
            if (prev === void 0) {
              if (next !== void 0 && next !== exports.GLOBSTAR) {
                pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
              } else {
                pp[i] = twoStar;
              }
            } else if (next === void 0) {
              pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
            } else if (next !== exports.GLOBSTAR) {
              pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
              pp[i + 1] = exports.GLOBSTAR;
            }
          });
          return pp.filter((p2) => p2 !== exports.GLOBSTAR).join("/");
        }).join("|");
        const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
        re2 = "^" + open + re2 + close + "$";
        if (this.negate)
          re2 = "^(?!" + re2 + ").+$";
        try {
          this.regexp = new RegExp(re2, [...flags].join(""));
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      slashSplit(p2) {
        if (this.preserveMultipleSlashes) {
          return p2.split("/");
        } else if (this.isWindows && /^\/\/[^\/]+/.test(p2)) {
          return ["", ...p2.split(/\/+/)];
        } else {
          return p2.split(/\/+/);
        }
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment) {
          return false;
        }
        if (this.empty) {
          return f === "";
        }
        if (f === "/" && partial) {
          return true;
        }
        const options = this.options;
        if (this.isWindows) {
          f = f.split("\\").join("/");
        }
        const ff = this.slashSplit(f);
        this.debug(this.pattern, "split", ff);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename = ff[ff.length - 1];
        if (!filename) {
          for (let i = ff.length - 2; !filename && i >= 0; i--) {
            filename = ff[i];
          }
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = ff;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate) {
              return true;
            }
            return !this.negate;
          }
        }
        if (options.flipNegate) {
          return false;
        }
        return this.negate;
      }
      static defaults(def2) {
        return exports.minimatch.defaults(def2).Minimatch;
      }
    };
    exports.Minimatch = Minimatch;
    var ast_js_2 = require_ast();
    Object.defineProperty(exports, "AST", { enumerable: true, get: function() {
      return ast_js_2.AST;
    } });
    var escape_js_2 = require_escape();
    Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    var unescape_js_2 = require_unescape();
    Object.defineProperty(exports, "unescape", { enumerable: true, get: function() {
      return unescape_js_2.unescape;
    } });
    exports.minimatch.AST = ast_js_1.AST;
    exports.minimatch.Minimatch = Minimatch;
    exports.minimatch.escape = escape_js_1.escape;
    exports.minimatch.unescape = unescape_js_1.unescape;
  }
});

// node_modules/muggle-string/out/binarySearch.js
var require_binarySearch = __commonJS({
  "node_modules/muggle-string/out/binarySearch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.binarySearch = void 0;
    function binarySearch(offsets, start) {
      let low = 0;
      let high = offsets.length - 1;
      while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const midValue = offsets[mid];
        if (midValue < start) {
          low = mid + 1;
        } else if (midValue > start) {
          high = mid - 1;
        } else {
          low = mid;
          high = mid;
          break;
        }
      }
      return Math.max(Math.min(low, high, offsets.length - 1), 0);
    }
    exports.binarySearch = binarySearch;
  }
});

// node_modules/muggle-string/out/track.js
var require_track = __commonJS({
  "node_modules/muggle-string/out/track.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStack = exports.track = exports.resetOffsetStack = exports.offsetStack = exports.setTracking = void 0;
    var tracking = true;
    var stackOffset = 0;
    function setTracking(value) {
      tracking = value;
    }
    exports.setTracking = setTracking;
    function offsetStack() {
      stackOffset++;
    }
    exports.offsetStack = offsetStack;
    function resetOffsetStack() {
      stackOffset--;
    }
    exports.resetOffsetStack = resetOffsetStack;
    function track2(segments, stacks = []) {
      return [
        new Proxy(segments, {
          get(target, prop, receiver) {
            if (tracking) {
              if (prop === "push")
                return push2;
              if (prop === "pop")
                return pop;
              if (prop === "shift")
                return shift;
              if (prop === "unshift")
                return unshift;
              if (prop === "splice")
                return splice2;
              if (prop === "sort")
                return sort;
              if (prop === "reverse")
                return reverse;
            }
            return Reflect.get(target, prop, receiver);
          }
        }),
        stacks
      ];
      function push2(...items) {
        stacks.push({ stack: getStack(), length: items.length });
        return segments.push(...items);
      }
      function pop() {
        if (stacks.length) {
          const last = stacks[stacks.length - 1];
          if (last.length > 1) {
            last.length--;
          } else {
            stacks.pop();
          }
        }
        return segments.pop();
      }
      function shift() {
        if (stacks.length) {
          const first = stacks[0];
          if (first.length > 1) {
            first.length--;
          } else {
            stacks.shift();
          }
        }
        return segments.shift();
      }
      function unshift(...items) {
        stacks.unshift({ stack: getStack(), length: items.length });
        return segments.unshift(...items);
      }
      function splice2(start, deleteCount, ...items) {
        if (deleteCount === void 0) {
          deleteCount = segments.length - start;
        }
        let _stackStart = 0;
        let operateIndex;
        for (let i = 0; i < stacks.length; i++) {
          const stack2 = stacks[i];
          const stackStart = _stackStart;
          const stackEnd = stackStart + stack2.length;
          _stackStart = stackEnd;
          if (start >= stackStart) {
            operateIndex = i + 1;
            const originalLength = stack2.length;
            stack2.length = start - stackStart;
            stacks.splice(operateIndex, 0, { stack: stack2.stack, length: originalLength - stack2.length });
            break;
          }
        }
        if (operateIndex === void 0) {
          throw new Error("Invalid splice operation");
        }
        let _deleteCount = deleteCount;
        for (let i = operateIndex; i < stacks.length; i++) {
          const stack2 = stacks[i];
          while (_deleteCount > 0 && stack2.length > 0) {
            stack2.length--;
            _deleteCount--;
          }
          if (_deleteCount === 0) {
            break;
          }
        }
        stacks.splice(operateIndex, 0, { stack: getStack(), length: items.length });
        return segments.splice(start, deleteCount, ...items);
      }
      function sort(compareFn) {
        stacks.splice(0, stacks.length, { stack: getStack(), length: segments.length });
        return segments.sort(compareFn);
      }
      function reverse() {
        stacks.splice(0, stacks.length, { stack: getStack(), length: segments.length });
        return segments.reverse();
      }
    }
    exports.track = track2;
    function getStack() {
      const stack2 = new Error().stack;
      let source = stack2.split("\n")[3 + stackOffset].trim();
      if (source.endsWith(")")) {
        source = source.slice(source.lastIndexOf("(") + 1, -1);
      } else {
        source = source.slice(source.lastIndexOf(" ") + 1);
      }
      return source;
    }
    exports.getStack = getStack;
  }
});

// node_modules/muggle-string/out/types.js
var require_types = __commonJS({
  "node_modules/muggle-string/out/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/muggle-string/out/index.js
var require_out = __commonJS({
  "node_modules/muggle-string/out/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceRange = exports.replaceSourceRange = exports.replaceAll = exports.replace = exports.create = exports.toString = exports.getLength = void 0;
    var binarySearch_1 = require_binarySearch();
    var track_1 = require_track();
    __exportStar(require_types(), exports);
    __exportStar(require_track(), exports);
    function getLength(segments) {
      let length = 0;
      for (const segment of segments) {
        length += typeof segment == "string" ? segment.length : segment[0].length;
      }
      return length;
    }
    exports.getLength = getLength;
    function toString3(segments) {
      return segments.map((s) => typeof s === "string" ? s : s[0]).join("");
    }
    exports.toString = toString3;
    function create2(source) {
      return [[source, void 0, 0]];
    }
    exports.create = create2;
    function replace2(segments, pattern, ...replacers) {
      const str = toString3(segments);
      const match = str.match(pattern);
      if (match && match.index !== void 0) {
        const startOffset = match.index;
        const endOffset = startOffset + match[0].length;
        (0, track_1.offsetStack)();
        replaceRange(segments, startOffset, endOffset, ...replacers.map((replacer2) => typeof replacer2 === "function" ? replacer2(match[0]) : replacer2));
        (0, track_1.resetOffsetStack)();
      }
    }
    exports.replace = replace2;
    function replaceAll(segments, pattern, ...replacers) {
      const str = toString3(segments);
      const allMatch = str.matchAll(pattern);
      let length = str.length;
      let lengthDiff = 0;
      for (const match of allMatch) {
        if (match.index !== void 0) {
          const startOffset = match.index + lengthDiff;
          const endOffset = startOffset + match[0].length;
          (0, track_1.offsetStack)();
          replaceRange(segments, startOffset, endOffset, ...replacers.map((replacer2) => typeof replacer2 === "function" ? replacer2(match[0]) : replacer2));
          (0, track_1.resetOffsetStack)();
          const newLength = getLength(segments);
          lengthDiff += newLength - length;
          length = newLength;
        }
      }
    }
    exports.replaceAll = replaceAll;
    function replaceSourceRange(segments, source, startOffset, endOffset, ...newSegments) {
      for (const segment of segments) {
        if (typeof segment === "string") {
          continue;
        }
        if (segment[1] === source) {
          const segmentStart = segment[2];
          const segmentEnd = segment[2] + segment[0].length;
          if (segmentStart <= startOffset && segmentEnd >= endOffset) {
            const inserts = [];
            if (startOffset > segmentStart) {
              inserts.push(trimSegmentEnd(segment, startOffset - segmentStart));
            }
            for (const newSegment of newSegments) {
              inserts.push(newSegment);
            }
            if (endOffset < segmentEnd) {
              inserts.push(trimSegmentStart(segment, endOffset - segmentEnd));
            }
            combineStrings(inserts);
            (0, track_1.offsetStack)();
            segments.splice(segments.indexOf(segment), 1, ...inserts);
            (0, track_1.resetOffsetStack)();
            return true;
          }
        }
      }
      return false;
    }
    exports.replaceSourceRange = replaceSourceRange;
    function replaceRange(segments, startOffset, endOffset, ...newSegments) {
      const offsets = toOffsets(segments);
      const startIndex = (0, binarySearch_1.binarySearch)(offsets, startOffset);
      const endIndex = (0, binarySearch_1.binarySearch)(offsets, endOffset);
      const startSegment = segments[startIndex];
      const endSegment = segments[endIndex];
      const startSegmentStart = offsets[startIndex];
      const endSegmentStart = offsets[endIndex];
      const endSegmentEnd = offsets[endIndex] + (typeof endSegment === "string" ? endSegment.length : endSegment[0].length);
      const inserts = [];
      if (startOffset > startSegmentStart) {
        inserts.push(trimSegmentEnd(startSegment, startOffset - startSegmentStart));
      }
      for (const newSegment of newSegments) {
        inserts.push(newSegment);
      }
      if (endOffset < endSegmentEnd) {
        inserts.push(trimSegmentStart(endSegment, endOffset - endSegmentStart));
      }
      combineStrings(inserts);
      (0, track_1.offsetStack)();
      segments.splice(startIndex, endIndex - startIndex + 1, ...inserts);
      (0, track_1.resetOffsetStack)();
    }
    exports.replaceRange = replaceRange;
    function combineStrings(segments) {
      for (let i = segments.length - 1; i >= 1; i--) {
        if (typeof segments[i] === "string" && typeof segments[i - 1] === "string") {
          segments[i - 1] = segments[i - 1] + segments[i];
          (0, track_1.offsetStack)();
          segments.splice(i, 1);
          (0, track_1.resetOffsetStack)();
        }
      }
    }
    function trimSegmentEnd(segment, trimEnd) {
      if (typeof segment === "string") {
        return segment.slice(0, trimEnd);
      }
      return [
        segment[0].slice(0, trimEnd),
        ...segment.slice(1)
      ];
    }
    function trimSegmentStart(segment, trimStart) {
      if (typeof segment === "string") {
        return segment.slice(trimStart);
      }
      if (trimStart < 0) {
        trimStart += segment[0].length;
      }
      return [
        segment[0].slice(trimStart),
        segment[1],
        segment[2] + trimStart,
        ...segment.slice(3)
      ];
    }
    function toOffsets(segments) {
      const offsets = [];
      let offset = 0;
      for (const segment of segments) {
        offsets.push(offset);
        offset += typeof segment == "string" ? segment.length : segment[0].length;
      }
      return offsets;
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/elementEvents.js
var require_elementEvents = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/elementEvents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateElementEvents = generateElementEvents;
    exports.generateEventArg = generateEventArg;
    exports.generateEventExpression = generateEventExpression;
    exports.isCompoundExpression = isCompoundExpression;
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var shared_1 = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    var shared_2 = require_shared();
    var common_1 = require_common();
    var camelized_1 = require_camelized();
    var interpolation_1 = require_interpolation();
    function* generateElementEvents(options, ctx, node2, componentVar, componentInstanceVar, emitVar, eventsVar) {
      var _a;
      let usedComponentEventsVar = false;
      let propsVar;
      for (const prop of node2.props) {
        if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE && prop.name === "on" && ((_a = prop.arg) == null ? void 0 : _a.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && !prop.arg.loc.source.startsWith("[") && !prop.arg.loc.source.endsWith("]")) {
          usedComponentEventsVar = true;
          if (!propsVar) {
            propsVar = ctx.getInternalVariable();
            yield `let ${propsVar}!: __VLS_FunctionalComponentProps<typeof ${componentVar}, typeof ${componentInstanceVar}>${common_1.endOfLine}`;
          }
          const originalPropName = (0, shared_1.camelize)("on-" + prop.arg.loc.source);
          const originalPropNameObjectKey = common_1.variableNameRegex.test(originalPropName) ? originalPropName : `'${originalPropName}'`;
          yield `const ${ctx.getInternalVariable()}: `;
          if (!options.vueCompilerOptions.strictTemplates) {
            yield `Record<string, unknown> & `;
          }
          yield `(${common_1.newLine}`;
          yield `__VLS_IsFunction<typeof ${propsVar}, '${originalPropName}'> extends true${common_1.newLine}`;
          yield `? typeof ${propsVar}${common_1.newLine}`;
          yield `: __VLS_IsFunction<typeof ${eventsVar}, '${prop.arg.loc.source}'> extends true${common_1.newLine}`;
          yield `? {${common_1.newLine}`;
          yield `/**__VLS_emit,${emitVar},${prop.arg.loc.source}*/${common_1.newLine}`;
          yield `${originalPropNameObjectKey}?: typeof ${eventsVar}['${prop.arg.loc.source}']${common_1.newLine}`;
          yield `}${common_1.newLine}`;
          if (prop.arg.loc.source !== (0, shared_1.camelize)(prop.arg.loc.source)) {
            yield `: __VLS_IsFunction<typeof ${eventsVar}, '${(0, shared_1.camelize)(prop.arg.loc.source)}'> extends true${common_1.newLine}`;
            yield `? {${common_1.newLine}`;
            yield `/**__VLS_emit,${emitVar},${(0, shared_1.camelize)(prop.arg.loc.source)}*/${common_1.newLine}`;
            yield `${originalPropNameObjectKey}?: typeof ${eventsVar}['${(0, shared_1.camelize)(prop.arg.loc.source)}']${common_1.newLine}`;
            yield `}${common_1.newLine}`;
          }
          yield `: typeof ${propsVar}${common_1.newLine}`;
          yield `) = {${common_1.newLine}`;
          yield* generateEventArg(ctx, prop.arg, true);
          yield `: `;
          yield* generateEventExpression(options, ctx, prop);
          yield `}${common_1.endOfLine}`;
        }
      }
      return usedComponentEventsVar;
    }
    var eventArgFeatures = {
      navigation: {
        // @click-outside -> onClickOutside
        resolveRenameNewName(newName) {
          return (0, shared_1.camelize)("on-" + newName);
        },
        // onClickOutside -> @click-outside
        resolveRenameEditText(newName) {
          const hName = (0, shared_2.hyphenateAttr)(newName);
          if ((0, shared_2.hyphenateAttr)(newName).startsWith("on-")) {
            return (0, shared_1.camelize)(hName.slice("on-".length));
          }
          return newName;
        }
      }
    };
    function* generateEventArg(ctx, arg, enableHover) {
      const features = enableHover ? {
        ...ctx.codeFeatures.withoutHighlightAndCompletion,
        ...eventArgFeatures
      } : eventArgFeatures;
      if (common_1.variableNameRegex.test((0, shared_1.camelize)(arg.loc.source))) {
        yield ["", "template", arg.loc.start.offset, features];
        yield `on`;
        yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(arg.loc.source), arg.loc.start.offset, common_1.combineLastMapping);
      } else {
        yield* (0, common_1.wrapWith)(arg.loc.start.offset, arg.loc.end.offset, features, `'`, ["", "template", arg.loc.start.offset, common_1.combineLastMapping], "on", ...(0, camelized_1.generateCamelized)((0, shared_1.capitalize)(arg.loc.source), arg.loc.start.offset, common_1.combineLastMapping), `'`);
      }
    }
    function* generateEventExpression(options, ctx, prop) {
      var _a;
      if (((_a = prop.exp) == null ? void 0 : _a.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
        let prefix = "(";
        let suffix = ")";
        let isFirstMapping = true;
        const ast = (0, common_1.createTsAst)(options.ts, prop.exp, prop.exp.content);
        const _isCompoundExpression = isCompoundExpression(options.ts, ast);
        if (_isCompoundExpression) {
          yield `(...[$event]) => {${common_1.newLine}`;
          ctx.addLocalVariable("$event");
          prefix = "";
          suffix = "";
          for (const blockCondition of ctx.blockConditions) {
            prefix += `if (!(${blockCondition})) return${common_1.endOfLine}`;
          }
        }
        yield* (0, interpolation_1.generateInterpolation)(options, ctx, prop.exp.content, prop.exp.loc, prop.exp.loc.start.offset, (offset) => {
          if (_isCompoundExpression && isFirstMapping) {
            isFirstMapping = false;
            ctx.inlayHints.push({
              blockName: "template",
              offset,
              setting: "vue.inlayHints.inlineHandlerLeading",
              label: "$event =>",
              paddingRight: true,
              tooltip: [
                "`$event` is a hidden parameter, you can use it in this callback.",
                "To hide this hint, set `vue.inlayHints.inlineHandlerLeading` to `false` in IDE settings.",
                "[More info](https://github.com/vuejs/language-tools/issues/2445#issuecomment-1444771420)"
              ].join("\n\n")
            });
          }
          return ctx.codeFeatures.all;
        }, prefix, suffix);
        if (_isCompoundExpression) {
          ctx.removeLocalVariable("$event");
          yield common_1.endOfLine;
          yield* ctx.generateAutoImportCompletion();
          yield `}`;
        }
      } else {
        yield `() => {}`;
      }
    }
    function isCompoundExpression(ts3, ast) {
      let result = true;
      if (ast.statements.length === 0) {
        result = false;
      } else if (ast.statements.length === 1) {
        ts3.forEachChild(ast, (child_1) => {
          if (ts3.isExpressionStatement(child_1)) {
            ts3.forEachChild(child_1, (child_2) => {
              if (ts3.isArrowFunction(child_2)) {
                result = false;
              } else if (isPropertyAccessOrId(ts3, child_2)) {
                result = false;
              }
            });
          } else if (ts3.isFunctionDeclaration(child_1)) {
            result = false;
          }
        });
      }
      return result;
    }
    function isPropertyAccessOrId(ts3, node2) {
      if (ts3.isIdentifier(node2)) {
        return true;
      }
      if (ts3.isPropertyAccessExpression(node2)) {
        return isPropertyAccessOrId(ts3, node2.expression);
      }
      return false;
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/stringLiteralKey.js
var require_stringLiteralKey = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/stringLiteralKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateStringLiteralKey = generateStringLiteralKey;
    var common_1 = require_common();
    function* generateStringLiteralKey(code3, offset, info) {
      if (offset === void 0 || !info) {
        yield `"${code3}"`;
      } else {
        yield* (0, common_1.wrapWith)(offset, offset + code3.length, info, `"`, [code3, "template", offset, common_1.combineLastMapping], `"`);
      }
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/objectProperty.js
var require_objectProperty = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/objectProperty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateObjectProperty = generateObjectProperty;
    var shared_1 = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    var common_1 = require_common();
    var camelized_1 = require_camelized();
    var interpolation_1 = require_interpolation();
    var stringLiteralKey_1 = require_stringLiteralKey();
    function* generateObjectProperty(options, ctx, code3, offset, features, astHolder, shouldCamelize = false, shouldBeConstant = false) {
      if (code3.startsWith("[") && code3.endsWith("]") && astHolder) {
        if (shouldBeConstant) {
          yield* (0, interpolation_1.generateInterpolation)(options, ctx, code3.slice(1, -1), astHolder, offset + 1, features, `[__VLS_tryAsConstant(`, `)]`);
        } else {
          yield* (0, interpolation_1.generateInterpolation)(options, ctx, code3, astHolder, offset, features, "", "");
        }
      } else if (shouldCamelize) {
        if (common_1.variableNameRegex.test((0, shared_1.camelize)(code3))) {
          yield* (0, camelized_1.generateCamelized)(code3, offset, features);
        } else {
          yield* (0, common_1.wrapWith)(offset, offset + code3.length, features, `"`, ...(0, camelized_1.generateCamelized)(code3, offset, common_1.combineLastMapping), `"`);
        }
      } else {
        if (common_1.variableNameRegex.test(code3)) {
          yield [code3, "template", offset, features];
        } else {
          yield* (0, stringLiteralKey_1.generateStringLiteralKey)(code3, offset, features);
        }
      }
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/inlayHints.js
var require_inlayHints = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/inlayHints.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createVBindShorthandInlayHintInfo = createVBindShorthandInlayHintInfo;
    function createVBindShorthandInlayHintInfo(loc, variableName) {
      return {
        blockName: "template",
        offset: loc.end.offset,
        setting: "vue.inlayHints.vBindShorthand",
        label: `="${variableName}"`,
        tooltip: [
          `This is a shorthand for \`${loc.source}="${variableName}"\`.`,
          "To hide this hint, set `vue.inlayHints.vBindShorthand` to `false` in IDE settings.",
          "[More info](https://github.com/vuejs/core/pull/9451)"
        ].join("\n\n")
      };
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/elementProps.js
var require_elementProps = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/elementProps.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateElementProps = generateElementProps;
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var shared_1 = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    var minimatch_1 = require_commonjs();
    var muggle_string_1 = require_out();
    var shared_2 = require_shared();
    var common_1 = require_common();
    var camelized_1 = require_camelized();
    var elementEvents_1 = require_elementEvents();
    var interpolation_1 = require_interpolation();
    var objectProperty_1 = require_objectProperty();
    var inlayHints_1 = require_inlayHints();
    function* generateElementProps(options, ctx, node2, props, enableCodeFeatures, propsFailedExps) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      const isComponent2 = node2.tagType === CompilerDOM.ElementTypes.COMPONENT;
      for (const prop of props) {
        if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE && prop.name === "on") {
          if (((_a = prop.arg) == null ? void 0 : _a.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && !prop.arg.loc.source.startsWith("[") && !prop.arg.loc.source.endsWith("]")) {
            if (!isComponent2) {
              yield `...{ `;
              yield* (0, elementEvents_1.generateEventArg)(ctx, prop.arg, true);
              yield `: `;
              yield* (0, elementEvents_1.generateEventExpression)(options, ctx, prop);
              yield `}, `;
            } else {
              yield `...{ '${(0, shared_1.camelize)("on-" + prop.arg.loc.source)}': {} as any }, `;
            }
          } else if (((_b = prop.arg) == null ? void 0 : _b.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && ((_c = prop.exp) == null ? void 0 : _c.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && prop.arg.loc.source.startsWith("[") && prop.arg.loc.source.endsWith("]")) {
            propsFailedExps == null ? void 0 : propsFailedExps.push({ node: prop.arg, prefix: "(", suffix: ")" });
            propsFailedExps == null ? void 0 : propsFailedExps.push({ node: prop.exp, prefix: "() => {", suffix: "}" });
          } else if (!prop.arg && ((_d = prop.exp) == null ? void 0 : _d.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
            propsFailedExps == null ? void 0 : propsFailedExps.push({ node: prop.exp, prefix: "(", suffix: ")" });
          }
        }
      }
      for (const prop of props) {
        if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE && (prop.name === "bind" && ((_e = prop.arg) == null ? void 0 : _e.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION || prop.name === "model") && (!prop.exp || prop.exp.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION)) {
          let propName;
          if (((_f = prop.arg) == null ? void 0 : _f.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
            propName = prop.arg.constType === CompilerDOM.ConstantTypes.CAN_STRINGIFY ? prop.arg.content : prop.arg.loc.source;
          } else {
            propName = getModelValuePropName(node2, options.vueCompilerOptions.target, options.vueCompilerOptions);
          }
          if (propName === void 0 || options.vueCompilerOptions.dataAttributes.some((pattern) => (0, minimatch_1.minimatch)(propName, pattern))) {
            if (prop.exp && prop.exp.constType !== CompilerDOM.ConstantTypes.CAN_STRINGIFY) {
              propsFailedExps == null ? void 0 : propsFailedExps.push({ node: prop.exp, prefix: "(", suffix: ")" });
            }
            continue;
          }
          if (prop.modifiers.some((m) => m.content === "prop" || m.content === "attr")) {
            propName = propName.substring(1);
          }
          const shouldSpread = propName === "style" || propName === "class";
          const shouldCamelize = isComponent2 && (!prop.arg || prop.arg.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && prop.arg.isStatic) && (0, shared_2.hyphenateAttr)(propName) === propName && !options.vueCompilerOptions.htmlAttributes.some((pattern) => (0, minimatch_1.minimatch)(propName, pattern));
          if (shouldSpread) {
            yield `...{ `;
          }
          const codeInfo = ctx.codeFeatures.withoutHighlightAndCompletion;
          const codes2 = (0, common_1.wrapWith)(prop.loc.start.offset, prop.loc.end.offset, ctx.codeFeatures.verification, ...prop.arg ? (0, objectProperty_1.generateObjectProperty)(options, ctx, propName, prop.arg.loc.start.offset, {
            ...codeInfo,
            verification: options.vueCompilerOptions.strictTemplates ? codeInfo.verification : {
              shouldReport(_source, code3) {
                var _a2, _b2;
                if (String(code3) === "2353" || String(code3) === "2561") {
                  return false;
                }
                return typeof codeInfo.verification === "object" ? ((_b2 = (_a2 = codeInfo.verification).shouldReport) == null ? void 0 : _b2.call(_a2, _source, code3)) ?? true : true;
              }
            },
            navigation: codeInfo.navigation ? {
              resolveRenameNewName: shared_1.camelize,
              resolveRenameEditText: shouldCamelize ? shared_2.hyphenateAttr : void 0
            } : false
          }, prop.loc.name_2 ?? (prop.loc.name_2 = {}), shouldCamelize) : (0, common_1.wrapWith)(prop.loc.start.offset, prop.loc.start.offset + "v-model".length, ctx.codeFeatures.verification, propName), `: (`, ...generatePropExp(options, ctx, prop, prop.exp, ctx.codeFeatures.all, ((_g = prop.arg) == null ? void 0 : _g.loc.start.offset) === ((_h = prop.exp) == null ? void 0 : _h.loc.start.offset), enableCodeFeatures), `)`);
          if (!enableCodeFeatures) {
            yield (0, muggle_string_1.toString)([...codes2]);
          } else {
            yield* codes2;
          }
          if (shouldSpread) {
            yield ` }`;
          }
          yield `, `;
        } else if (prop.type === CompilerDOM.NodeTypes.ATTRIBUTE) {
          if (options.vueCompilerOptions.dataAttributes.some((pattern) => (0, minimatch_1.minimatch)(prop.name, pattern)) || options.vueCompilerOptions.target < 3 && prop.name === "persisted" && node2.tag.toLowerCase() === "transition") {
            continue;
          }
          const shouldSpread = prop.name === "style" || prop.name === "class";
          const shouldCamelize = isComponent2 && (0, shared_2.hyphenateAttr)(prop.name) === prop.name && !options.vueCompilerOptions.htmlAttributes.some((pattern) => (0, minimatch_1.minimatch)(prop.name, pattern));
          if (shouldSpread) {
            yield `...{ `;
          }
          const codeInfo = shouldCamelize ? {
            ...ctx.codeFeatures.withoutHighlightAndCompletion,
            navigation: ctx.codeFeatures.withoutHighlightAndCompletion.navigation ? {
              resolveRenameNewName: shared_1.camelize,
              resolveRenameEditText: shared_2.hyphenateAttr
            } : false
          } : {
            ...ctx.codeFeatures.withoutHighlightAndCompletion
          };
          if (!options.vueCompilerOptions.strictTemplates) {
            const verification = codeInfo.verification;
            codeInfo.verification = {
              shouldReport(_source, code3) {
                var _a2;
                if (String(code3) === "2353" || String(code3) === "2561") {
                  return false;
                }
                return typeof verification === "object" ? ((_a2 = verification.shouldReport) == null ? void 0 : _a2.call(verification, _source, code3)) ?? true : true;
              }
            };
          }
          const codes2 = (0, common_1.conditionWrapWith)(enableCodeFeatures, prop.loc.start.offset, prop.loc.end.offset, ctx.codeFeatures.verification, ...(0, objectProperty_1.generateObjectProperty)(options, ctx, prop.name, prop.loc.start.offset, codeInfo, prop.loc.name_1 ?? (prop.loc.name_1 = {}), shouldCamelize), `: (`, ...prop.value ? generateAttrValue(prop.value, ctx.codeFeatures.all) : [`true`], `)`);
          if (!enableCodeFeatures) {
            yield (0, muggle_string_1.toString)([...codes2]);
          } else {
            yield* codes2;
          }
          if (shouldSpread) {
            yield ` }`;
          }
          yield `, `;
        } else if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE && prop.name === "bind" && !prop.arg && ((_i = prop.exp) == null ? void 0 : _i.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
          const codes2 = (0, common_1.conditionWrapWith)(enableCodeFeatures, prop.exp.loc.start.offset, prop.exp.loc.end.offset, ctx.codeFeatures.verification, `...`, ...(0, interpolation_1.generateInterpolation)(options, ctx, prop.exp.content, prop.exp.loc, prop.exp.loc.start.offset, ctx.codeFeatures.all, "(", ")"));
          if (!enableCodeFeatures) {
            yield (0, muggle_string_1.toString)([...codes2]);
          } else {
            yield* codes2;
          }
          yield `, `;
        } else {
        }
      }
    }
    function* generatePropExp(options, ctx, prop, exp, features, isShorthand, enableCodeFeatures) {
      if (isShorthand && features.completion) {
        features = {
          ...features,
          completion: void 0
        };
      }
      if (exp && exp.constType !== CompilerDOM.ConstantTypes.CAN_STRINGIFY) {
        if (!isShorthand) {
          yield* (0, interpolation_1.generateInterpolation)(options, ctx, exp.loc.source, exp.loc, exp.loc.start.offset, features, "(", ")");
        } else {
          const propVariableName = (0, shared_1.camelize)(exp.loc.source);
          if (common_1.variableNameRegex.test(propVariableName)) {
            if (!ctx.hasLocalVariable(propVariableName)) {
              ctx.accessExternalVariable(propVariableName, exp.loc.start.offset);
              yield `__VLS_ctx.`;
            }
            yield* (0, camelized_1.generateCamelized)(exp.loc.source, exp.loc.start.offset, features);
            if (enableCodeFeatures) {
              ctx.inlayHints.push((0, inlayHints_1.createVBindShorthandInlayHintInfo)(prop.loc, propVariableName));
            }
          }
        }
      } else {
        yield `{}`;
      }
    }
    function* generateAttrValue(attrNode, features) {
      const char = attrNode.loc.source.startsWith("'") ? "'" : '"';
      yield char;
      let start = attrNode.loc.start.offset;
      let end = attrNode.loc.end.offset;
      let content3 = attrNode.loc.source;
      if (content3.startsWith('"') && content3.endsWith('"') || content3.startsWith("'") && content3.endsWith("'")) {
        start++;
        end--;
        content3 = content3.slice(1, -1);
      }
      if (needToUnicode(content3)) {
        yield* (0, common_1.wrapWith)(start, end, features, toUnicode(content3));
      } else {
        yield [content3, "template", start, features];
      }
      yield char;
    }
    function needToUnicode(str) {
      return str.includes("\\") || str.includes("\n");
    }
    function toUnicode(str) {
      return str.split("").map((value) => {
        const temp = value.charCodeAt(0).toString(16).padStart(4, "0");
        if (temp.length > 2) {
          return "\\u" + temp;
        }
        return value;
      }).join("");
    }
    function getModelValuePropName(node2, vueVersion, vueCompilerOptions) {
      var _a;
      for (const modelName in vueCompilerOptions.experimentalModelPropName) {
        const tags = vueCompilerOptions.experimentalModelPropName[modelName];
        for (const tag in tags) {
          if (node2.tag === tag || node2.tag === (0, shared_2.hyphenateTag)(tag)) {
            const v = tags[tag];
            if (typeof v === "object") {
              const arr = Array.isArray(v) ? v : [v];
              for (const attrs of arr) {
                let failed = false;
                for (const attr in attrs) {
                  const attrNode = node2.props.find((prop) => prop.type === CompilerDOM.NodeTypes.ATTRIBUTE && prop.name === attr);
                  if (!attrNode || ((_a = attrNode.value) == null ? void 0 : _a.content) !== attrs[attr]) {
                    failed = true;
                    break;
                  }
                }
                if (!failed) {
                  return modelName || void 0;
                }
              }
            }
          }
        }
      }
      for (const modelName in vueCompilerOptions.experimentalModelPropName) {
        const tags = vueCompilerOptions.experimentalModelPropName[modelName];
        for (const tag in tags) {
          if (node2.tag === tag || node2.tag === (0, shared_2.hyphenateTag)(tag)) {
            const attrs = tags[tag];
            if (attrs === true) {
              return modelName || void 0;
            }
          }
        }
      }
      return vueVersion < 3 ? "value" : "modelValue";
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/slotOutlet.js
var require_slotOutlet = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/slotOutlet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateSlotOutlet = generateSlotOutlet;
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var common_1 = require_common();
    var elementChildren_1 = require_elementChildren();
    var elementProps_1 = require_elementProps();
    var interpolation_1 = require_interpolation();
    var inlayHints_1 = require_inlayHints();
    function* generateSlotOutlet(options, ctx, node2, currentComponent, componentCtxVar) {
      var _a, _b, _c;
      const startTagOffset = node2.loc.start.offset + options.template.content.substring(node2.loc.start.offset).indexOf(node2.tag);
      const varSlot = ctx.getInternalVariable();
      const nameProp = node2.props.find((prop) => {
        var _a2;
        if (prop.type === CompilerDOM.NodeTypes.ATTRIBUTE) {
          return prop.name === "name";
        }
        if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE && prop.name === "bind" && ((_a2 = prop.arg) == null ? void 0 : _a2.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
          return prop.arg.content === "name";
        }
      });
      if (options.hasDefineSlots) {
        yield `__VLS_normalizeSlot(`;
        yield* (0, common_1.wrapWith)(node2.loc.start.offset, node2.loc.end.offset, ctx.codeFeatures.verification, `${options.slotsAssignName ?? "__VLS_slots"}[`, ...(0, common_1.wrapWith)(node2.loc.start.offset, node2.loc.end.offset, ctx.codeFeatures.verification, (nameProp == null ? void 0 : nameProp.type) === CompilerDOM.NodeTypes.ATTRIBUTE && nameProp.value ? `'${nameProp.value.content}'` : (nameProp == null ? void 0 : nameProp.type) === CompilerDOM.NodeTypes.DIRECTIVE && ((_a = nameProp.exp) == null ? void 0 : _a.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION ? nameProp.exp.content : `('default' as const)`), `]`);
        yield `)?.(`;
        yield* (0, common_1.wrapWith)(startTagOffset, startTagOffset + node2.tag.length, ctx.codeFeatures.verification, `{${common_1.newLine}`, ...(0, elementProps_1.generateElementProps)(options, ctx, node2, node2.props.filter((prop) => prop !== nameProp), true), `}`);
        yield `)${common_1.endOfLine}`;
      } else {
        yield `var ${varSlot} = {${common_1.newLine}`;
        yield* (0, elementProps_1.generateElementProps)(options, ctx, node2, node2.props.filter((prop) => prop !== nameProp), true);
        yield `}${common_1.endOfLine}`;
        if ((nameProp == null ? void 0 : nameProp.type) === CompilerDOM.NodeTypes.ATTRIBUTE && nameProp.value) {
          ctx.slots.push({
            name: nameProp.value.content,
            loc: nameProp.loc.start.offset + nameProp.loc.source.indexOf(nameProp.value.content, nameProp.name.length),
            tagRange: [startTagOffset, startTagOffset + node2.tag.length],
            varName: varSlot,
            nodeLoc: node2.loc
          });
        } else if ((nameProp == null ? void 0 : nameProp.type) === CompilerDOM.NodeTypes.DIRECTIVE && ((_b = nameProp.exp) == null ? void 0 : _b.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
          const isShortHand = ((_c = nameProp.arg) == null ? void 0 : _c.loc.start.offset) === nameProp.exp.loc.start.offset;
          if (isShortHand) {
            ctx.inlayHints.push((0, inlayHints_1.createVBindShorthandInlayHintInfo)(nameProp.exp.loc, "name"));
          }
          const slotExpVar = ctx.getInternalVariable();
          yield `var ${slotExpVar} = `;
          yield* (0, interpolation_1.generateInterpolation)(options, ctx, nameProp.exp.content, nameProp.exp, nameProp.exp.loc.start.offset, ctx.codeFeatures.all, "(", ")");
          yield ` as const${common_1.endOfLine}`;
          ctx.dynamicSlots.push({
            expVar: slotExpVar,
            varName: varSlot
          });
        } else {
          ctx.slots.push({
            name: "default",
            tagRange: [startTagOffset, startTagOffset + node2.tag.length],
            varName: varSlot,
            nodeLoc: node2.loc
          });
        }
      }
      yield* ctx.generateAutoImportCompletion();
      yield* (0, elementChildren_1.generateElementChildren)(options, ctx, node2, currentComponent, componentCtxVar);
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/vFor.js
var require_vFor = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/vFor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateVFor = generateVFor;
    exports.parseVForNode = parseVForNode;
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var common_1 = require_common();
    var interpolation_1 = require_interpolation();
    var templateChild_1 = require_templateChild();
    function* generateVFor(options, ctx, node2, currentComponent, componentCtxVar) {
      var _a, _b, _c, _d;
      const { source } = node2.parseResult;
      const { leftExpressionRange, leftExpressionText } = parseVForNode(node2);
      const forBlockVars = [];
      yield `for (const [`;
      if (leftExpressionRange && leftExpressionText) {
        const collectAst = (0, common_1.createTsAst)(options.ts, node2.parseResult, `const [${leftExpressionText}]`);
        (0, common_1.collectVars)(options.ts, collectAst, collectAst, forBlockVars);
        yield [
          leftExpressionText,
          "template",
          leftExpressionRange.start,
          ctx.codeFeatures.all
        ];
      }
      yield `] of `;
      if (source.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
        yield `__VLS_getVForSourceType(`;
        yield* (0, interpolation_1.generateInterpolation)(options, ctx, source.content, source.loc, source.loc.start.offset, ctx.codeFeatures.all, "(", ")");
        yield `!)`;
      } else {
        yield `{} as any`;
      }
      yield `) {${common_1.newLine}`;
      for (const varName of forBlockVars) {
        ctx.addLocalVariable(varName);
      }
      let isFragment = true;
      for (const argument of ((_a = node2.codegenNode) == null ? void 0 : _a.children.arguments) ?? []) {
        if (argument.type === CompilerDOM.NodeTypes.JS_FUNCTION_EXPRESSION && ((_b = argument.returns) == null ? void 0 : _b.type) === CompilerDOM.NodeTypes.VNODE_CALL && ((_d = (_c = argument.returns) == null ? void 0 : _c.props) == null ? void 0 : _d.type) === CompilerDOM.NodeTypes.JS_OBJECT_EXPRESSION) {
          if (argument.returns.tag !== CompilerDOM.FRAGMENT) {
            isFragment = false;
            continue;
          }
          for (const prop of argument.returns.props.properties) {
            if (prop.value.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && !prop.value.isStatic) {
              yield* (0, interpolation_1.generateInterpolation)(options, ctx, prop.value.content, prop.value.loc, prop.value.loc.start.offset, ctx.codeFeatures.all, "(", ")");
              yield common_1.endOfLine;
            }
          }
        }
      }
      if (isFragment) {
        yield* ctx.resetDirectiveComments("end of v-for start");
      }
      let prev;
      for (const childNode of node2.children) {
        yield* (0, templateChild_1.generateTemplateChild)(options, ctx, childNode, currentComponent, prev, componentCtxVar, true);
        prev = childNode;
      }
      for (const varName of forBlockVars) {
        ctx.removeLocalVariable(varName);
      }
      yield* ctx.generateAutoImportCompletion();
      yield `}${common_1.newLine}`;
    }
    function parseVForNode(node2) {
      const { value, key: key2, index: index2 } = node2.parseResult;
      const leftExpressionRange = value || key2 || index2 ? {
        start: (value ?? key2 ?? index2).loc.start.offset,
        end: (index2 ?? key2 ?? value).loc.end.offset
      } : void 0;
      const leftExpressionText = leftExpressionRange ? node2.loc.source.substring(leftExpressionRange.start - node2.loc.start.offset, leftExpressionRange.end - node2.loc.start.offset) : void 0;
      return {
        leftExpressionRange,
        leftExpressionText
      };
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/vIf.js
var require_vIf = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/vIf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateVIf = generateVIf;
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var muggle_string_1 = require_out();
    var common_1 = require_common();
    var interpolation_1 = require_interpolation();
    var templateChild_1 = require_templateChild();
    function* generateVIf(options, ctx, node2, currentComponent, componentCtxVar) {
      var _a;
      let originalBlockConditionsLength = ctx.blockConditions.length;
      for (let i = 0; i < node2.branches.length; i++) {
        const branch = node2.branches[i];
        if (i === 0) {
          yield `if `;
        } else if (branch.condition) {
          yield `else if `;
        } else {
          yield `else `;
        }
        let addedBlockCondition = false;
        if (((_a = branch.condition) == null ? void 0 : _a.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
          const codes2 = [
            ...(0, interpolation_1.generateInterpolation)(options, ctx, branch.condition.content, branch.condition.loc, branch.condition.loc.start.offset, ctx.codeFeatures.all, "(", ")")
          ];
          for (const code3 of codes2) {
            yield code3;
          }
          ctx.blockConditions.push((0, muggle_string_1.toString)(codes2));
          addedBlockCondition = true;
          yield ` `;
        }
        yield `{${common_1.newLine}`;
        if (isFragment(node2)) {
          yield* ctx.resetDirectiveComments("end of v-if start");
        }
        let prev;
        for (const childNode of branch.children) {
          yield* (0, templateChild_1.generateTemplateChild)(options, ctx, childNode, currentComponent, prev, componentCtxVar);
          prev = childNode;
        }
        yield* ctx.generateAutoImportCompletion();
        yield `}${common_1.newLine}`;
        if (addedBlockCondition) {
          ctx.blockConditions[ctx.blockConditions.length - 1] = `!(${ctx.blockConditions[ctx.blockConditions.length - 1]})`;
        }
      }
      ctx.blockConditions.length = originalBlockConditionsLength;
    }
    function isFragment(node2) {
      return node2.codegenNode && "consequent" in node2.codegenNode && "tag" in node2.codegenNode.consequent && node2.codegenNode.consequent.tag === CompilerDOM.FRAGMENT;
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/templateChild.js
var require_templateChild = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/templateChild.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateTemplateChild = generateTemplateChild;
    exports.getVForNode = getVForNode;
    exports.parseInterpolationNode = parseInterpolationNode;
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var common_1 = require_common();
    var element_1 = require_element();
    var interpolation_1 = require_interpolation();
    var slotOutlet_1 = require_slotOutlet();
    var vFor_1 = require_vFor();
    var vIf_1 = require_vIf();
    var transformContext = {
      onError: () => {
      },
      helperString: (str) => str.toString(),
      replaceNode: () => {
      },
      cacheHandlers: false,
      prefixIdentifiers: false,
      scopes: {
        vFor: 0,
        vOnce: 0,
        vPre: 0,
        vSlot: 0
      },
      expressionPlugins: ["typescript"]
    };
    function* generateTemplateChild(options, ctx, node2, currentComponent, prevNode, componentCtxVar, isVForChild = false) {
      var _a;
      if ((prevNode == null ? void 0 : prevNode.type) === CompilerDOM.NodeTypes.COMMENT) {
        const commentText = prevNode.content.trim().split(" ")[0];
        if (commentText.match(/^@vue-skip\b[\s\S]*/)) {
          yield `// @vue-skip${common_1.newLine}`;
          return;
        } else if (commentText.match(/^@vue-ignore\b[\s\S]*/)) {
          yield* ctx.ignoreError();
        } else if (commentText.match(/^@vue-expect-error\b[\s\S]*/)) {
          yield* ctx.expectError(prevNode);
        }
      }
      const shouldInheritRootNodeAttrs = options.inheritAttrs;
      const cur = node2;
      if (((_a = cur.codegenNode) == null ? void 0 : _a.type) === CompilerDOM.NodeTypes.JS_CACHE_EXPRESSION) {
        cur.codegenNode = cur.codegenNode.value;
      }
      if (node2.type === CompilerDOM.NodeTypes.ROOT) {
        let prev;
        if (shouldInheritRootNodeAttrs && node2.children.length === 1 && node2.children[0].type === CompilerDOM.NodeTypes.ELEMENT) {
          ctx.singleRootNode = node2.children[0];
        }
        for (const childNode of node2.children) {
          yield* generateTemplateChild(options, ctx, childNode, currentComponent, prev, componentCtxVar);
          prev = childNode;
        }
        yield* ctx.resetDirectiveComments("end of root");
      } else if (node2.type === CompilerDOM.NodeTypes.ELEMENT) {
        const vForNode = getVForNode(node2);
        const vIfNode = getVIfNode(node2);
        if (vForNode) {
          yield* (0, vFor_1.generateVFor)(options, ctx, vForNode, currentComponent, componentCtxVar);
        } else if (vIfNode) {
          yield* (0, vIf_1.generateVIf)(options, ctx, vIfNode, currentComponent, componentCtxVar);
        } else {
          if (node2.tagType === CompilerDOM.ElementTypes.SLOT) {
            yield* (0, slotOutlet_1.generateSlotOutlet)(options, ctx, node2, currentComponent, componentCtxVar);
          } else if (node2.tagType === CompilerDOM.ElementTypes.ELEMENT || node2.tagType === CompilerDOM.ElementTypes.TEMPLATE) {
            yield* (0, element_1.generateElement)(options, ctx, node2, currentComponent, componentCtxVar, isVForChild);
          } else {
            yield* (0, element_1.generateComponent)(options, ctx, node2, currentComponent);
          }
        }
      } else if (node2.type === CompilerDOM.NodeTypes.TEXT_CALL) {
        yield* generateTemplateChild(options, ctx, node2.content, currentComponent, void 0, componentCtxVar);
      } else if (node2.type === CompilerDOM.NodeTypes.COMPOUND_EXPRESSION) {
        for (const childNode of node2.children) {
          if (typeof childNode === "object") {
            yield* generateTemplateChild(options, ctx, childNode, currentComponent, void 0, componentCtxVar);
          }
        }
      } else if (node2.type === CompilerDOM.NodeTypes.INTERPOLATION) {
        const [content3, start] = parseInterpolationNode(node2, options.template.content);
        yield* (0, interpolation_1.generateInterpolation)(options, ctx, content3, node2.content.loc, start, ctx.codeFeatures.all, `(`, `)${common_1.endOfLine}`);
        yield* ctx.resetDirectiveComments("end of INTERPOLATION");
      } else if (node2.type === CompilerDOM.NodeTypes.IF) {
        yield* (0, vIf_1.generateVIf)(options, ctx, node2, currentComponent, componentCtxVar);
      } else if (node2.type === CompilerDOM.NodeTypes.FOR) {
        yield* (0, vFor_1.generateVFor)(options, ctx, node2, currentComponent, componentCtxVar);
      } else if (node2.type === CompilerDOM.NodeTypes.TEXT) {
      }
    }
    function getVForNode(node2) {
      const forDirective = node2.props.find((prop) => prop.type === CompilerDOM.NodeTypes.DIRECTIVE && prop.name === "for");
      if (forDirective) {
        let forNode;
        CompilerDOM.processFor(node2, forDirective, transformContext, (_forNode) => {
          forNode = { ..._forNode };
          return void 0;
        });
        if (forNode) {
          forNode.children = [{
            ...node2,
            props: node2.props.filter((prop) => prop !== forDirective)
          }];
          return forNode;
        }
      }
    }
    function getVIfNode(node2) {
      const forDirective = node2.props.find((prop) => prop.type === CompilerDOM.NodeTypes.DIRECTIVE && prop.name === "if");
      if (forDirective) {
        let ifNode;
        CompilerDOM.processIf(node2, forDirective, transformContext, (_ifNode) => {
          ifNode = { ..._ifNode };
          return void 0;
        });
        if (ifNode) {
          for (const branch of ifNode.branches) {
            branch.children = [{
              ...node2,
              props: node2.props.filter((prop) => prop !== forDirective)
            }];
          }
          return ifNode;
        }
      }
    }
    function parseInterpolationNode(node2, template) {
      let content3 = node2.content.loc.source;
      let start = node2.content.loc.start.offset;
      let leftCharacter;
      let rightCharacter;
      while ((leftCharacter = template.substring(start - 1, start)).trim() === "" && leftCharacter.length) {
        start--;
        content3 = leftCharacter + content3;
      }
      while ((rightCharacter = template.substring(start + content3.length, start + content3.length + 1)).trim() === "" && rightCharacter.length) {
        content3 = content3 + rightCharacter;
      }
      return [
        content3,
        start
      ];
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/elementChildren.js
var require_elementChildren = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/elementChildren.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateElementChildren = generateElementChildren;
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var common_1 = require_common();
    var templateChild_1 = require_templateChild();
    function* generateElementChildren(options, ctx, node2, currentComponent, componentCtxVar) {
      yield* ctx.resetDirectiveComments("end of element children start");
      let prev;
      for (const childNode of node2.children) {
        yield* (0, templateChild_1.generateTemplateChild)(options, ctx, childNode, currentComponent, prev, componentCtxVar);
        prev = childNode;
      }
      yield* ctx.generateAutoImportCompletion();
      if (componentCtxVar && !ctx.hasSlotElements.has(node2) && node2.children.length && node2.tagType !== CompilerDOM.ElementTypes.ELEMENT && node2.tagType !== CompilerDOM.ElementTypes.TEMPLATE) {
        ctx.usedComponentCtxVars.add(componentCtxVar);
        yield `__VLS_nonNullable(${componentCtxVar}.slots).`;
        yield* (0, common_1.wrapWith)(node2.children[0].loc.start.offset, node2.children[node2.children.length - 1].loc.end.offset, ctx.codeFeatures.navigation, `default`);
        yield common_1.endOfLine;
      }
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/elementDirectives.js
var require_elementDirectives = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/elementDirectives.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateElementDirectives = generateElementDirectives;
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var shared_1 = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    var shared_2 = require_shared();
    var common_1 = require_common();
    var camelized_1 = require_camelized();
    var interpolation_1 = require_interpolation();
    var objectProperty_1 = require_objectProperty();
    var stringLiteralKey_1 = require_stringLiteralKey();
    function* generateElementDirectives(options, ctx, node2) {
      for (const prop of node2.props) {
        if (prop.type !== CompilerDOM.NodeTypes.DIRECTIVE || prop.name === "slot" || prop.name === "on" || prop.name === "model" || prop.name === "bind" || prop.name === "scope" || prop.name === "data") {
          continue;
        }
        ctx.accessExternalVariable((0, shared_1.camelize)("v-" + prop.name), prop.loc.start.offset);
        yield* (0, common_1.wrapWith)(prop.loc.start.offset, prop.loc.end.offset, ctx.codeFeatures.verification, `__VLS_asFunctionalDirective(`, ...generateIdentifier(ctx, prop), `)(null!, { ...__VLS_directiveBindingRestFields, `, ...generateArg(options, ctx, prop), ...generateModifiers(options, ctx, prop), ...generateValue(options, ctx, prop), `}, null!, null!)`);
        yield common_1.endOfLine;
      }
    }
    function* generateIdentifier(ctx, prop) {
      const rawName = "v-" + prop.name;
      yield* (0, common_1.wrapWith)(prop.loc.start.offset, prop.loc.start.offset + rawName.length, ctx.codeFeatures.verification, `__VLS_directives.`, ...(0, camelized_1.generateCamelized)(rawName, prop.loc.start.offset, {
        ...ctx.codeFeatures.all,
        verification: false,
        completion: {
          // fix https://github.com/vuejs/language-tools/issues/1905
          isAdditional: true
        },
        navigation: {
          resolveRenameNewName: shared_1.camelize,
          resolveRenameEditText: getPropRenameApply(prop.name)
        }
      }));
    }
    function* generateArg(options, ctx, prop) {
      const { arg } = prop;
      if ((arg == null ? void 0 : arg.type) !== CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
        return;
      }
      const startOffset = arg.loc.start.offset + arg.loc.source.indexOf(arg.content);
      yield* (0, common_1.wrapWith)(startOffset, startOffset + arg.content.length, ctx.codeFeatures.verification, "arg");
      yield ": ";
      if (arg.isStatic) {
        yield* (0, stringLiteralKey_1.generateStringLiteralKey)(arg.content, startOffset, ctx.codeFeatures.withoutHighlight);
      } else {
        yield* (0, interpolation_1.generateInterpolation)(options, ctx, arg.content, arg.loc, startOffset, ctx.codeFeatures.all, "(", ")");
      }
      yield ", ";
    }
    function* generateModifiers(options, ctx, prop) {
      if (options.vueCompilerOptions.target < 3.5) {
        return;
      }
      yield "modifiers: { ";
      for (const mod of prop.modifiers) {
        yield* (0, objectProperty_1.generateObjectProperty)(options, ctx, mod.content, mod.loc.start.offset, ctx.codeFeatures.withoutHighlight);
        yield ": true, ";
      }
      yield "}, ";
    }
    function* generateValue(options, ctx, prop) {
      var _a;
      if (((_a = prop.exp) == null ? void 0 : _a.type) !== CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
        return;
      }
      yield* (0, common_1.wrapWith)(prop.exp.loc.start.offset, prop.exp.loc.end.offset, ctx.codeFeatures.verification, "value");
      yield ": ";
      yield* (0, common_1.wrapWith)(prop.exp.loc.start.offset, prop.exp.loc.end.offset, ctx.codeFeatures.verification, ...(0, interpolation_1.generateInterpolation)(options, ctx, prop.exp.content, prop.exp.loc, prop.exp.loc.start.offset, ctx.codeFeatures.all, "(", ")"));
    }
    function getPropRenameApply(oldName) {
      return oldName === (0, shared_2.hyphenateAttr)(oldName) ? shared_2.hyphenateAttr : void 0;
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/propertyAccess.js
var require_propertyAccess = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/propertyAccess.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generatePropertyAccess = generatePropertyAccess;
    var common_1 = require_common();
    var interpolation_1 = require_interpolation();
    var stringLiteralKey_1 = require_stringLiteralKey();
    function* generatePropertyAccess(options, ctx, code3, offset, features, astHolder) {
      if (!options.compilerOptions.noPropertyAccessFromIndexSignature && common_1.variableNameRegex.test(code3)) {
        yield `.`;
        yield offset !== void 0 && features ? [code3, "template", offset, features] : code3;
      } else if (code3.startsWith("[") && code3.endsWith("]")) {
        yield* (0, interpolation_1.generateInterpolation)(options, ctx, code3, astHolder, offset, features, "", "");
      } else {
        yield `[`;
        yield* (0, stringLiteralKey_1.generateStringLiteralKey)(code3, offset, features);
        yield `]`;
      }
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/element.js
var require_element = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/element.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateComponent = generateComponent;
    exports.generateElement = generateElement;
    exports.getCanonicalComponentName = getCanonicalComponentName;
    exports.getPossibleOriginalComponentNames = getPossibleOriginalComponentNames;
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var shared_1 = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    var shared_2 = require_shared();
    var common_1 = require_common();
    var camelized_1 = require_camelized();
    var elementChildren_1 = require_elementChildren();
    var elementDirectives_1 = require_elementDirectives();
    var elementEvents_1 = require_elementEvents();
    var elementProps_1 = require_elementProps();
    var interpolation_1 = require_interpolation();
    var propertyAccess_1 = require_propertyAccess();
    var templateChild_1 = require_templateChild();
    var objectProperty_1 = require_objectProperty();
    var inlayHints_1 = require_inlayHints();
    var scriptSetupRanges_1 = require_scriptSetupRanges();
    var colonReg = /:/g;
    function* generateComponent(options, ctx, node2, currentComponent) {
      var _a, _b, _c, _d;
      const startTagOffset = node2.loc.start.offset + options.template.content.substring(node2.loc.start.offset).indexOf(node2.tag);
      const endTagOffset = !node2.isSelfClosing && options.template.lang === "html" ? node2.loc.start.offset + node2.loc.source.lastIndexOf(node2.tag) : void 0;
      const tagOffsets = endTagOffset !== void 0 && endTagOffset > startTagOffset ? [startTagOffset, endTagOffset] : [startTagOffset];
      const propsFailedExps = [];
      const possibleOriginalNames = getPossibleOriginalComponentNames(node2.tag, true);
      const matchImportName = possibleOriginalNames.find((name) => options.scriptSetupImportComponentNames.has(name));
      const var_originalComponent = matchImportName ?? ctx.getInternalVariable();
      const var_functionalComponent = ctx.getInternalVariable();
      const var_componentInstance = ctx.getInternalVariable();
      const var_componentEmit = ctx.getInternalVariable();
      const var_componentEvents = ctx.getInternalVariable();
      const var_defineComponentCtx = ctx.getInternalVariable();
      const isComponentTag2 = node2.tag.toLowerCase() === "component";
      let props = node2.props;
      let dynamicTagInfo;
      if (isComponentTag2) {
        for (const prop of node2.props) {
          if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE && prop.name === "bind" && ((_a = prop.arg) == null ? void 0 : _a.loc.source) === "is" && ((_b = prop.exp) == null ? void 0 : _b.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
            if (prop.arg.loc.end.offset === prop.exp.loc.end.offset) {
              ctx.inlayHints.push((0, inlayHints_1.createVBindShorthandInlayHintInfo)(prop.exp.loc, "is"));
            }
            dynamicTagInfo = {
              tag: prop.exp.content,
              offsets: [prop.exp.loc.start.offset, void 0],
              astHolder: prop.exp.loc
            };
            props = props.filter((p2) => p2 !== prop);
            break;
          }
        }
      } else if (node2.tag.includes(".")) {
        dynamicTagInfo = {
          tag: node2.tag,
          offsets: [startTagOffset, endTagOffset],
          astHolder: node2.loc
        };
      }
      if (matchImportName) {
        yield `// @ts-ignore${common_1.newLine}`;
        yield `[`;
        for (const tagOffset of tagOffsets) {
          if (var_originalComponent === node2.tag) {
            yield [
              var_originalComponent,
              "template",
              tagOffset,
              ctx.codeFeatures.withoutHighlightAndCompletion
            ];
          } else {
            yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(node2.tag), tagOffset, {
              ...ctx.codeFeatures.withoutHighlightAndCompletion,
              navigation: {
                resolveRenameNewName: camelizeComponentName,
                resolveRenameEditText: getTagRenameApply(node2.tag)
              }
            });
          }
          yield `,`;
        }
        yield `]${common_1.endOfLine}`;
      } else if (dynamicTagInfo) {
        yield `const ${var_originalComponent} = (`;
        yield* (0, interpolation_1.generateInterpolation)(options, ctx, dynamicTagInfo.tag, dynamicTagInfo.astHolder, dynamicTagInfo.offsets[0], ctx.codeFeatures.all, "(", ")");
        if (dynamicTagInfo.offsets[1] !== void 0) {
          yield `,`;
          yield* (0, interpolation_1.generateInterpolation)(options, ctx, dynamicTagInfo.tag, dynamicTagInfo.astHolder, dynamicTagInfo.offsets[1], {
            ...ctx.codeFeatures.all,
            completion: false
          }, "(", ")");
        }
        yield `)${common_1.endOfLine}`;
      } else if (!isComponentTag2) {
        yield `const ${var_originalComponent} = __VLS_resolvedLocalAndGlobalComponents.`;
        yield* generateCanonicalComponentName(node2.tag, startTagOffset, {
          // with hover support
          ...ctx.codeFeatures.withoutHighlightAndCompletionAndNavigation,
          ...ctx.codeFeatures.verification
        });
        yield `${common_1.endOfLine}`;
        const camelizedTag = (0, shared_1.camelize)(node2.tag);
        if (common_1.variableNameRegex.test(camelizedTag)) {
          yield `/** @type { [`;
          for (const tagOffset of tagOffsets) {
            for (const shouldCapitalize of node2.tag[0] === node2.tag[0].toUpperCase() ? [false] : [true, false]) {
              const expectName = shouldCapitalize ? (0, shared_1.capitalize)(camelizedTag) : camelizedTag;
              yield `typeof __VLS_components.`;
              yield* (0, camelized_1.generateCamelized)(shouldCapitalize ? (0, shared_1.capitalize)(node2.tag) : node2.tag, tagOffset, {
                navigation: {
                  resolveRenameNewName: node2.tag !== expectName ? camelizeComponentName : void 0,
                  resolveRenameEditText: getTagRenameApply(node2.tag)
                }
              });
              yield `, `;
            }
          }
          yield `] } */${common_1.newLine}`;
          if (options.edited) {
            yield `// @ts-ignore${common_1.newLine}`;
            yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(node2.tag), startTagOffset, {
              completion: {
                isAdditional: true,
                onlyImport: true
              }
            });
            yield `${common_1.endOfLine}`;
          }
        }
      } else {
        yield `const ${var_originalComponent} = {} as any${common_1.endOfLine}`;
      }
      yield `// @ts-ignore${common_1.newLine}`;
      yield `const ${var_functionalComponent} = __VLS_asFunctionalComponent(${var_originalComponent}, new ${var_originalComponent}({`;
      yield* (0, elementProps_1.generateElementProps)(options, ctx, node2, props, false);
      yield `}))${common_1.endOfLine}`;
      yield `const ${var_componentInstance} = ${var_functionalComponent}(`;
      yield* (0, common_1.wrapWith)(startTagOffset, startTagOffset + node2.tag.length, ctx.codeFeatures.verification, `{`, ...(0, elementProps_1.generateElementProps)(options, ctx, node2, props, true, propsFailedExps), `}`);
      yield `, ...__VLS_functionalComponentArgsRest(${var_functionalComponent}))${common_1.endOfLine}`;
      currentComponent = node2;
      for (const failedExp of propsFailedExps) {
        yield* (0, interpolation_1.generateInterpolation)(options, ctx, failedExp.node.loc.source, failedExp.node.loc, failedExp.node.loc.start.offset, ctx.codeFeatures.all, failedExp.prefix, failedExp.suffix);
        yield common_1.endOfLine;
      }
      const [refName, offset] = yield* generateVScope(options, ctx, node2, props);
      const isRootNode = node2 === ctx.singleRootNode;
      if (refName || isRootNode) {
        const varName = ctx.getInternalVariable();
        ctx.usedComponentCtxVars.add(var_defineComponentCtx);
        yield `var ${varName} = {} as (Parameters<NonNullable<typeof ${var_defineComponentCtx}['expose']>>[0] | null)`;
        if (((_c = node2.codegenNode) == null ? void 0 : _c.type) === CompilerDOM.NodeTypes.VNODE_CALL && ((_d = node2.codegenNode.props) == null ? void 0 : _d.type) === CompilerDOM.NodeTypes.JS_OBJECT_EXPRESSION && node2.codegenNode.props.properties.some(({ key: key2 }) => key2.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && key2.content === "ref_for")) {
          yield `[]`;
        }
        yield `${common_1.endOfLine}`;
        if (refName) {
          ctx.templateRefs.set(refName, [varName, offset]);
        }
        if (isRootNode) {
          ctx.singleRootElType = `NonNullable<typeof ${varName}>['$el']`;
        }
      }
      const usedComponentEventsVar = yield* (0, elementEvents_1.generateElementEvents)(options, ctx, node2, var_functionalComponent, var_componentInstance, var_componentEmit, var_componentEvents);
      if (usedComponentEventsVar) {
        ctx.usedComponentCtxVars.add(var_defineComponentCtx);
        yield `let ${var_componentEmit}!: typeof ${var_defineComponentCtx}.emit${common_1.endOfLine}`;
        yield `let ${var_componentEvents}!: __VLS_NormalizeEmits<typeof ${var_componentEmit}>${common_1.endOfLine}`;
      }
      if (options.vueCompilerOptions.fallthroughAttributes && (node2.props.some((prop) => {
        var _a2;
        return prop.type === CompilerDOM.NodeTypes.DIRECTIVE && prop.name === "bind" && ((_a2 = prop.exp) == null ? void 0 : _a2.loc.source) === "$attrs";
      }) || node2 === ctx.singleRootNode)) {
        const varAttrs = ctx.getInternalVariable();
        ctx.inheritedAttrVars.add(varAttrs);
        yield `var ${varAttrs}!: Parameters<typeof ${var_functionalComponent}>[0];
`;
      }
      const slotDir = node2.props.find((p2) => p2.type === CompilerDOM.NodeTypes.DIRECTIVE && p2.name === "slot");
      if (slotDir) {
        yield* generateComponentSlot(options, ctx, node2, slotDir, currentComponent, var_defineComponentCtx);
      } else {
        yield* (0, elementChildren_1.generateElementChildren)(options, ctx, node2, currentComponent, var_defineComponentCtx);
      }
      if (ctx.usedComponentCtxVars.has(var_defineComponentCtx)) {
        yield `var ${var_defineComponentCtx}!: __VLS_PickFunctionalComponentCtx<typeof ${var_originalComponent}, typeof ${var_componentInstance}>${common_1.endOfLine}`;
      }
    }
    function* generateElement(options, ctx, node2, currentComponent, componentCtxVar, isVForChild) {
      const startTagOffset = node2.loc.start.offset + options.template.content.substring(node2.loc.start.offset).indexOf(node2.tag);
      const endTagOffset = !node2.isSelfClosing && options.template.lang === "html" ? node2.loc.start.offset + node2.loc.source.lastIndexOf(node2.tag) : void 0;
      const propsFailedExps = [];
      yield `__VLS_elementAsFunction(__VLS_intrinsicElements`;
      yield* (0, propertyAccess_1.generatePropertyAccess)(options, ctx, node2.tag, startTagOffset, ctx.codeFeatures.withoutHighlightAndCompletion);
      if (endTagOffset !== void 0) {
        yield `, __VLS_intrinsicElements`;
        yield* (0, propertyAccess_1.generatePropertyAccess)(options, ctx, node2.tag, endTagOffset, ctx.codeFeatures.withoutHighlightAndCompletion);
      }
      yield `)(`;
      yield* (0, common_1.wrapWith)(startTagOffset, startTagOffset + node2.tag.length, ctx.codeFeatures.verification, `{`, ...(0, elementProps_1.generateElementProps)(options, ctx, node2, node2.props, true, propsFailedExps), `}`);
      yield `)${common_1.endOfLine}`;
      for (const failedExp of propsFailedExps) {
        yield* (0, interpolation_1.generateInterpolation)(options, ctx, failedExp.node.loc.source, failedExp.node.loc, failedExp.node.loc.start.offset, ctx.codeFeatures.all, failedExp.prefix, failedExp.suffix);
        yield common_1.endOfLine;
      }
      const [refName, offset] = yield* generateVScope(options, ctx, node2, node2.props);
      if (refName) {
        let refValue = `__VLS_nativeElements['${node2.tag}']`;
        if (isVForChild) {
          refValue = `[${refValue}]`;
        }
        ctx.templateRefs.set(refName, [refValue, offset]);
      }
      if (ctx.singleRootNode === node2) {
        ctx.singleRootElType = `typeof __VLS_nativeElements['${node2.tag}']`;
      }
      const slotDir = node2.props.find((p2) => p2.type === CompilerDOM.NodeTypes.DIRECTIVE && p2.name === "slot");
      if (slotDir && componentCtxVar) {
        yield* generateComponentSlot(options, ctx, node2, slotDir, currentComponent, componentCtxVar);
      } else {
        yield* (0, elementChildren_1.generateElementChildren)(options, ctx, node2, currentComponent, componentCtxVar);
      }
      if (options.vueCompilerOptions.fallthroughAttributes && (node2.props.some((prop) => {
        var _a;
        return prop.type === CompilerDOM.NodeTypes.DIRECTIVE && prop.name === "bind" && ((_a = prop.exp) == null ? void 0 : _a.loc.source) === "$attrs";
      }) || node2 === ctx.singleRootNode)) {
        ctx.inheritedAttrVars.add(`__VLS_intrinsicElements.${node2.tag}`);
      }
    }
    function* generateVScope(options, ctx, node2, props) {
      const vScope = props.find((prop) => prop.type === CompilerDOM.NodeTypes.DIRECTIVE && (prop.name === "scope" || prop.name === "data"));
      let inScope = false;
      let originalConditionsNum = ctx.blockConditions.length;
      if ((vScope == null ? void 0 : vScope.type) === CompilerDOM.NodeTypes.DIRECTIVE && vScope.exp) {
        const scopeVar = ctx.getInternalVariable();
        const condition = `__VLS_withScope(__VLS_ctx, ${scopeVar})`;
        yield `const ${scopeVar} = `;
        yield [
          vScope.exp.loc.source,
          "template",
          vScope.exp.loc.start.offset,
          ctx.codeFeatures.all
        ];
        yield common_1.endOfLine;
        yield `if (${condition}) {${common_1.newLine}`;
        ctx.blockConditions.push(condition);
        inScope = true;
      }
      yield* (0, elementDirectives_1.generateElementDirectives)(options, ctx, node2);
      const [refName, offset] = yield* generateReferencesForElements(options, ctx, node2);
      yield* generateReferencesForScopedCssClasses(options, ctx, node2);
      if (inScope) {
        yield `}${common_1.newLine}`;
        ctx.blockConditions.length = originalConditionsNum;
      }
      return [refName, offset];
    }
    function getCanonicalComponentName(tagText) {
      return common_1.variableNameRegex.test(tagText) ? tagText : (0, shared_1.capitalize)((0, shared_1.camelize)(tagText.replace(colonReg, "-")));
    }
    function getPossibleOriginalComponentNames(tagText, deduplicate) {
      const name1 = (0, shared_1.capitalize)((0, shared_1.camelize)(tagText));
      const name2 = (0, shared_1.camelize)(tagText);
      const name3 = tagText;
      const names = [name1];
      if (!deduplicate || name2 !== name1) {
        names.push(name2);
      }
      if (!deduplicate || name3 !== name2) {
        names.push(name3);
      }
      return names;
    }
    function* generateCanonicalComponentName(tagText, offset, features) {
      if (common_1.variableNameRegex.test(tagText)) {
        yield [tagText, "template", offset, features];
      } else {
        yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(tagText.replace(colonReg, "-")), offset, features);
      }
    }
    function* generateComponentSlot(options, ctx, node2, slotDir, currentComponent, componentCtxVar) {
      var _a, _b, _c;
      yield `{${common_1.newLine}`;
      ctx.usedComponentCtxVars.add(componentCtxVar);
      if (currentComponent) {
        ctx.hasSlotElements.add(currentComponent);
      }
      const slotBlockVars = [];
      yield `const {`;
      if (((_a = slotDir == null ? void 0 : slotDir.arg) == null ? void 0 : _a.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && slotDir.arg.content) {
        yield* (0, objectProperty_1.generateObjectProperty)(options, ctx, slotDir.arg.loc.source, slotDir.arg.loc.start.offset, slotDir.arg.isStatic ? ctx.codeFeatures.withoutHighlight : ctx.codeFeatures.all, slotDir.arg.loc, false, true);
        yield ": __VLS_thisSlot";
      } else {
        yield `default: `;
        yield* (0, common_1.wrapWith)(slotDir.loc.start.offset, slotDir.loc.start.offset + (slotDir.loc.source.startsWith("#") ? "#".length : slotDir.loc.source.startsWith("v-slot:") ? "v-slot:".length : 0), ctx.codeFeatures.withoutHighlightAndCompletion, `__VLS_thisSlot`);
      }
      yield `} = __VLS_nonNullable(${componentCtxVar}.slots)${common_1.endOfLine}`;
      if (((_b = slotDir == null ? void 0 : slotDir.exp) == null ? void 0 : _b.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
        const slotAst = (0, common_1.createTsAst)(options.ts, slotDir, `(${slotDir.exp.content}) => {}`);
        (0, common_1.collectVars)(options.ts, slotAst, slotAst, slotBlockVars);
        if (!slotDir.exp.content.includes(":")) {
          yield `const [`;
          yield [
            slotDir.exp.content,
            "template",
            slotDir.exp.loc.start.offset,
            ctx.codeFeatures.all
          ];
          yield `] = __VLS_getSlotParams(__VLS_thisSlot)${common_1.endOfLine}`;
        } else {
          yield `const `;
          yield [
            slotDir.exp.content,
            "template",
            slotDir.exp.loc.start.offset,
            ctx.codeFeatures.all
          ];
          yield ` = __VLS_getSlotParam(__VLS_thisSlot)${common_1.endOfLine}`;
        }
      }
      for (const varName of slotBlockVars) {
        ctx.addLocalVariable(varName);
      }
      yield* ctx.resetDirectiveComments("end of slot children start");
      let prev;
      for (const childNode of node2.children) {
        yield* (0, templateChild_1.generateTemplateChild)(options, ctx, childNode, currentComponent, prev, componentCtxVar);
        prev = childNode;
      }
      for (const varName of slotBlockVars) {
        ctx.removeLocalVariable(varName);
      }
      let isStatic = true;
      if (((_c = slotDir == null ? void 0 : slotDir.arg) == null ? void 0 : _c.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
        isStatic = slotDir.arg.isStatic;
      }
      if (isStatic && slotDir && !slotDir.arg) {
        yield `__VLS_nonNullable(${componentCtxVar}.slots)['`;
        yield [
          "",
          "template",
          slotDir.loc.start.offset + (slotDir.loc.source.startsWith("#") ? "#".length : slotDir.loc.source.startsWith("v-slot:") ? "v-slot:".length : 0),
          ctx.codeFeatures.completion
        ];
        yield `'/* empty slot name completion */]${common_1.newLine}`;
      }
      yield* ctx.generateAutoImportCompletion();
      yield `}${common_1.newLine}`;
    }
    function* generateReferencesForElements(options, ctx, node2) {
      for (const prop of node2.props) {
        if (prop.type === CompilerDOM.NodeTypes.ATTRIBUTE && prop.name === "ref" && prop.value) {
          const [content3, startOffset] = normalizeAttributeValue(prop.value);
          yield `// @ts-ignore navigation for \`const ${content3} = ref()\`${common_1.newLine}`;
          yield `__VLS_ctx`;
          yield* (0, propertyAccess_1.generatePropertyAccess)(options, ctx, content3, startOffset, ctx.codeFeatures.navigation, prop.value.loc);
          yield common_1.endOfLine;
          if (common_1.variableNameRegex.test(content3)) {
            ctx.accessExternalVariable(content3, startOffset);
          }
          return [content3, startOffset];
        }
      }
      return [];
    }
    function* generateReferencesForScopedCssClasses(options, ctx, node2) {
      var _a, _b;
      for (const prop of node2.props) {
        if (prop.type === CompilerDOM.NodeTypes.ATTRIBUTE && prop.name === "class" && prop.value) {
          if (options.template.lang === "pug") {
            const getClassOffset = Reflect.get(prop.value.loc.start, "getClassOffset");
            const content3 = prop.value.loc.source.slice(1, -1);
            let startOffset = 1;
            for (const className of content3.split(" ")) {
              if (className) {
                ctx.scopedClasses.push({
                  source: "template",
                  className,
                  offset: getClassOffset(startOffset)
                });
              }
              startOffset += className.length + 1;
            }
          } else {
            let isWrapped = false;
            const [content3, startOffset] = normalizeAttributeValue(prop.value);
            if (content3) {
              const classes = collectClasses(content3, startOffset + (isWrapped ? 1 : 0));
              ctx.scopedClasses.push(...classes);
            } else {
              ctx.emptyClassOffsets.push(startOffset);
            }
          }
        } else if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE && ((_a = prop.arg) == null ? void 0 : _a.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && ((_b = prop.exp) == null ? void 0 : _b.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && prop.arg.content === "class") {
          let walkArrayLiteral = function(node3) {
            const { elements } = node3;
            for (const element3 of elements) {
              if (ts3.isStringLiteralLike(element3)) {
                literals.push(element3);
              } else if (ts3.isObjectLiteralExpression(element3)) {
                walkObjectLiteral(element3);
              }
            }
          }, walkObjectLiteral = function(node3) {
            const { properties } = node3;
            for (const property2 of properties) {
              if (ts3.isPropertyAssignment(property2)) {
                const { name } = property2;
                if (ts3.isIdentifier(name)) {
                  walkIdentifier(name);
                } else if (ts3.isStringLiteral(name)) {
                  literals.push(name);
                } else if (ts3.isComputedPropertyName(name)) {
                  const { expression } = name;
                  if (ts3.isStringLiteralLike(expression)) {
                    literals.push(expression);
                  }
                }
              } else if (ts3.isShorthandPropertyAssignment(property2)) {
                walkIdentifier(property2.name);
              }
            }
          }, walkIdentifier = function(node3) {
            const text6 = (0, scriptSetupRanges_1.getNodeText)(ts3, node3, ast);
            ctx.scopedClasses.push({
              source: "template",
              className: text6,
              offset: node3.end - text6.length + startOffset
            });
          };
          const content3 = "`${" + prop.exp.content + "}`";
          const startOffset = prop.exp.loc.start.offset - 3;
          const { ts: ts3 } = options;
          const ast = ts3.createSourceFile("", content3, 99);
          const literals = [];
          ts3.forEachChild(ast, (node3) => {
            if (!ts3.isExpressionStatement(node3) || !isTemplateExpression(node3.expression)) {
              return;
            }
            const expression = node3.expression.templateSpans[0].expression;
            if (ts3.isStringLiteralLike(expression)) {
              literals.push(expression);
            }
            if (ts3.isArrayLiteralExpression(expression)) {
              walkArrayLiteral(expression);
            }
            if (ts3.isObjectLiteralExpression(expression)) {
              walkObjectLiteral(expression);
            }
          });
          for (const literal of literals) {
            const classes = collectClasses(literal.text, literal.end - literal.text.length - 1 + startOffset);
            ctx.scopedClasses.push(...classes);
          }
        }
      }
    }
    function camelizeComponentName(newName) {
      return (0, shared_1.camelize)("-" + newName);
    }
    function getTagRenameApply(oldName) {
      return oldName === (0, shared_2.hyphenateTag)(oldName) ? shared_2.hyphenateTag : void 0;
    }
    function normalizeAttributeValue(node2) {
      let offset = node2.loc.start.offset;
      let content3 = node2.loc.source;
      if (content3.startsWith(`'`) && content3.endsWith(`'`) || content3.startsWith(`"`) && content3.endsWith(`"`)) {
        offset++;
        content3 = content3.slice(1, -1);
      }
      return [content3, offset];
    }
    function collectClasses(content3, startOffset = 0) {
      const classes = [];
      let currentClassName = "";
      let offset = 0;
      for (const char of content3 + " ") {
        if (char.trim() === "") {
          if (currentClassName !== "") {
            classes.push({
              source: "template",
              className: currentClassName,
              offset: offset + startOffset
            });
            offset += currentClassName.length;
            currentClassName = "";
          }
          offset += char.length;
        } else {
          currentClassName += char;
        }
      }
      return classes;
    }
    function isTemplateExpression(node2) {
      return node2.kind === 228;
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/styleScopedClasses.js
var require_styleScopedClasses = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/styleScopedClasses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateStyleScopedClasses = generateStyleScopedClasses;
    var common_1 = require_common();
    function* generateStyleScopedClasses(ctx, withDot = false) {
      for (const offset of ctx.emptyClassOffsets) {
        yield `__VLS_styleScopedClasses['`;
        yield [
          "",
          "template",
          offset,
          ctx.codeFeatures.additionalCompletion
        ];
        yield `']${common_1.endOfLine}`;
      }
      for (const { source, className, offset } of ctx.scopedClasses) {
        yield `__VLS_styleScopedClasses[`;
        yield [
          "",
          source,
          offset - (withDot ? 1 : 0),
          ctx.codeFeatures.navigation
        ];
        yield `'`;
        yield* escapeString(source, className, offset, ["\\", "'"]);
        yield `'`;
        yield [
          "",
          source,
          offset + className.length,
          ctx.codeFeatures.navigationWithoutRename
        ];
        yield `]${common_1.endOfLine}`;
      }
      yield common_1.newLine;
      function* escapeString(source, className, offset, escapeTargets) {
        let count = 0;
        const currentEscapeTargets = [...escapeTargets];
        const firstEscapeTarget = currentEscapeTargets.shift();
        const splitted = className.split(firstEscapeTarget);
        for (let i = 0; i < splitted.length; i++) {
          const part = splitted[i];
          const partLength = part.length;
          if (escapeTargets.length > 0) {
            yield* escapeString(source, part, offset + count, [...currentEscapeTargets]);
          } else {
            yield [
              part,
              source,
              offset + count,
              ctx.codeFeatures.navigationAndAdditionalCompletion
            ];
          }
          if (i !== splitted.length - 1) {
            yield "\\";
            yield [
              firstEscapeTarget,
              source,
              offset + count + partLength,
              ctx.codeFeatures.navigationAndAdditionalCompletion
            ];
            count += partLength + 1;
          } else {
            count += partLength;
          }
        }
      }
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/template/index.js
var require_template = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/template/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateTemplate = generateTemplate;
    exports.forEachElementNode = forEachElementNode;
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var common_1 = require_common();
    var context_1 = require_context();
    var element_1 = require_element();
    var objectProperty_1 = require_objectProperty();
    var stringLiteralKey_1 = require_stringLiteralKey();
    var templateChild_1 = require_templateChild();
    var styleScopedClasses_1 = require_styleScopedClasses();
    function* generateTemplate(options) {
      const ctx = (0, context_1.createTemplateCodegenContext)(options);
      if (options.slotsAssignName) {
        ctx.addLocalVariable(options.slotsAssignName);
      }
      if (options.propsAssignName) {
        ctx.addLocalVariable(options.propsAssignName);
      }
      ctx.addLocalVariable("$el");
      ctx.addLocalVariable("$refs");
      yield* generatePreResolveComponents(options);
      if (options.template.ast) {
        yield* (0, templateChild_1.generateTemplateChild)(options, ctx, options.template.ast, void 0, void 0, void 0);
      }
      yield* (0, styleScopedClasses_1.generateStyleScopedClasses)(ctx);
      if (!options.hasDefineSlots) {
        yield `var __VLS_slots!:`;
        yield* generateSlotsType(options, ctx);
        yield common_1.endOfLine;
      }
      yield* ctx.generateAutoImportCompletion();
      yield* generateInheritedAttrs(ctx);
      yield* generateRefs(ctx);
      yield* generateRootEl(ctx);
      return ctx;
    }
    function* generateSlotsType(options, ctx) {
      for (const { expVar, varName } of ctx.dynamicSlots) {
        ctx.hasSlot = true;
        yield `Partial<Record<NonNullable<typeof ${expVar}>, (_: typeof ${varName}) => any>> &${common_1.newLine}`;
      }
      yield `{${common_1.newLine}`;
      for (const slot of ctx.slots) {
        ctx.hasSlot = true;
        if (slot.name && slot.loc !== void 0) {
          yield* (0, objectProperty_1.generateObjectProperty)(options, ctx, slot.name, slot.loc, ctx.codeFeatures.withoutHighlightAndCompletion, slot.nodeLoc);
        } else {
          yield* (0, common_1.wrapWith)(slot.tagRange[0], slot.tagRange[1], ctx.codeFeatures.withoutHighlightAndCompletion, `default`);
        }
        yield `?(_: typeof ${slot.varName}): any,${common_1.newLine}`;
      }
      yield `}`;
    }
    function* generateInheritedAttrs(ctx) {
      yield "var __VLS_inheritedAttrs!: {}";
      for (const varName of ctx.inheritedAttrVars) {
        yield ` & typeof ${varName}`;
      }
      yield common_1.endOfLine;
    }
    function* generateRefs(ctx) {
      yield `const __VLS_refs = {${common_1.newLine}`;
      for (const [name, [varName, offset]] of ctx.templateRefs) {
        yield* (0, stringLiteralKey_1.generateStringLiteralKey)(name, offset, ctx.codeFeatures.navigationAndCompletion);
        yield `: ${varName},${common_1.newLine}`;
      }
      yield `}${common_1.endOfLine}`;
      yield `var $refs!: typeof __VLS_refs${common_1.endOfLine}`;
    }
    function* generateRootEl(ctx) {
      if (ctx.singleRootElType) {
        yield `var $el!: ${ctx.singleRootElType}${common_1.endOfLine}`;
      } else {
        yield `var $el!: any${common_1.endOfLine}`;
      }
    }
    function* generatePreResolveComponents(options) {
      yield `let __VLS_resolvedLocalAndGlobalComponents!: Required<{}`;
      if (options.template.ast) {
        const components = /* @__PURE__ */ new Set();
        for (const node2 of forEachElementNode(options.template.ast)) {
          if (node2.tagType === CompilerDOM.ElementTypes.COMPONENT && node2.tag.toLowerCase() !== "component" && !node2.tag.includes(".")) {
            if (components.has(node2.tag)) {
              continue;
            }
            components.add(node2.tag);
            yield common_1.newLine;
            yield ` & __VLS_WithComponent<'${(0, element_1.getCanonicalComponentName)(node2.tag)}', typeof __VLS_localComponents, `;
            yield (0, element_1.getPossibleOriginalComponentNames)(node2.tag, false).map((name) => `"${name}"`).join(", ");
            yield `>`;
          }
        }
      }
      yield `>${common_1.endOfLine}`;
    }
    function* forEachElementNode(node2) {
      if (node2.type === CompilerDOM.NodeTypes.ROOT) {
        for (const child of node2.children) {
          yield* forEachElementNode(child);
        }
      } else if (node2.type === CompilerDOM.NodeTypes.ELEMENT) {
        const patchForNode = (0, templateChild_1.getVForNode)(node2);
        if (patchForNode) {
          yield* forEachElementNode(patchForNode);
        } else {
          yield node2;
          for (const child of node2.children) {
            yield* forEachElementNode(child);
          }
        }
      } else if (node2.type === CompilerDOM.NodeTypes.IF) {
        for (let i = 0; i < node2.branches.length; i++) {
          const branch = node2.branches[i];
          for (const childNode of branch.children) {
            yield* forEachElementNode(childNode);
          }
        }
      } else if (node2.type === CompilerDOM.NodeTypes.FOR) {
        for (const child of node2.children) {
          yield* forEachElementNode(child);
        }
      }
    }
  }
});

// node_modules/@volar/source-map/lib/binarySearch.js
var require_binarySearch2 = __commonJS({
  "node_modules/@volar/source-map/lib/binarySearch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.binarySearch = binarySearch;
    function binarySearch(values2, searchValue) {
      let low = 0;
      let high = values2.length - 1;
      let match;
      while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const midValue = values2[mid];
        if (midValue < searchValue) {
          low = mid + 1;
        } else if (midValue > searchValue) {
          high = mid - 1;
        } else {
          low = mid;
          high = mid;
          match = mid;
          break;
        }
      }
      const finalLow = Math.max(Math.min(low, high, values2.length - 1), 0);
      const finalHigh = Math.min(Math.max(low, high, 0), values2.length - 1);
      return { low: finalLow, high: finalHigh, match };
    }
  }
});

// node_modules/@volar/source-map/lib/translateOffset.js
var require_translateOffset = __commonJS({
  "node_modules/@volar/source-map/lib/translateOffset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.translateOffset = translateOffset;
    var warned = false;
    function translateOffset(start, fromOffsets, toOffsets, fromLengths, toLengths = fromLengths) {
      const isSorted = fromOffsets.every((value, index2) => index2 === 0 || fromOffsets[index2 - 1] <= value);
      if (!isSorted) {
        for (let i = 0; i < fromOffsets.length; i++) {
          const fromOffset = fromOffsets[i];
          const fromLength = fromLengths[i];
          if (start >= fromOffset && start <= fromOffset + fromLength) {
            const toLength = toLengths[i];
            const toOffset = toOffsets[i];
            let rangeOffset = Math.min(start - fromOffset, toLength);
            return toOffset + rangeOffset;
          }
        }
        if (!warned) {
          warned = true;
          console.warn("fromOffsets should be sorted in ascending order");
        }
      }
      let low = 0;
      let high = fromOffsets.length - 1;
      while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const fromOffset = fromOffsets[mid];
        const fromLength = fromLengths[mid];
        if (start >= fromOffset && start <= fromOffset + fromLength) {
          const toLength = toLengths[mid];
          const toOffset = toOffsets[mid];
          let rangeOffset = Math.min(start - fromOffset, toLength);
          return toOffset + rangeOffset;
        } else if (start < fromOffset) {
          high = mid - 1;
        } else {
          low = mid + 1;
        }
      }
    }
  }
});

// node_modules/@volar/source-map/lib/sourceMap.js
var require_sourceMap = __commonJS({
  "node_modules/@volar/source-map/lib/sourceMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SourceMap = void 0;
    var binarySearch_1 = require_binarySearch2();
    var translateOffset_1 = require_translateOffset();
    var SourceMap = class {
      constructor(mappings) {
        this.mappings = mappings;
      }
      toSourceRange(generatedStart, generatedEnd, fallbackToAnyMatch, filter) {
        return this.findMatchingStartEnd(generatedStart, generatedEnd, fallbackToAnyMatch, "generatedOffsets", filter);
      }
      toGeneratedRange(sourceStart, sourceEnd, fallbackToAnyMatch, filter) {
        return this.findMatchingStartEnd(sourceStart, sourceEnd, fallbackToAnyMatch, "sourceOffsets", filter);
      }
      toSourceLocation(generatedOffset, filter) {
        return this.findMatchingOffsets(generatedOffset, "generatedOffsets", filter);
      }
      toGeneratedLocation(sourceOffset, filter) {
        return this.findMatchingOffsets(sourceOffset, "sourceOffsets", filter);
      }
      *findMatchingOffsets(offset, fromRange, filter) {
        const memo = this.getMemoBasedOnRange(fromRange);
        if (memo.offsets.length === 0) {
          return;
        }
        const { low: start, high: end } = (0, binarySearch_1.binarySearch)(memo.offsets, offset);
        const skip = /* @__PURE__ */ new Set();
        const toRange = fromRange == "sourceOffsets" ? "generatedOffsets" : "sourceOffsets";
        for (let i = start; i <= end; i++) {
          for (const mapping of memo.mappings[i]) {
            if (skip.has(mapping)) {
              continue;
            }
            skip.add(mapping);
            if (filter && !filter(mapping.data)) {
              continue;
            }
            const mapped = (0, translateOffset_1.translateOffset)(offset, mapping[fromRange], mapping[toRange], getLengths(mapping, fromRange), getLengths(mapping, toRange));
            if (mapped !== void 0) {
              yield [mapped, mapping];
            }
          }
        }
      }
      *findMatchingStartEnd(start, end, fallbackToAnyMatch, fromRange, filter) {
        const toRange = fromRange == "sourceOffsets" ? "generatedOffsets" : "sourceOffsets";
        const mappedStarts = [];
        let hadMatch = false;
        for (const [mappedStart, mapping] of this.findMatchingOffsets(start, fromRange)) {
          if (filter && !filter(mapping.data)) {
            continue;
          }
          mappedStarts.push([mappedStart, mapping]);
          const mappedEnd = (0, translateOffset_1.translateOffset)(end, mapping[fromRange], mapping[toRange], getLengths(mapping, fromRange), getLengths(mapping, toRange));
          if (mappedEnd !== void 0) {
            hadMatch = true;
            yield [mappedStart, mappedEnd, mapping, mapping];
          }
        }
        if (!hadMatch && fallbackToAnyMatch) {
          for (const [mappedStart, mappingStart] of mappedStarts) {
            for (const [mappedEnd, mappingEnd] of this.findMatchingOffsets(end, fromRange)) {
              if (filter && !filter(mappingEnd.data) || mappedEnd < mappedStart) {
                continue;
              }
              yield [mappedStart, mappedEnd, mappingStart, mappingEnd];
              break;
            }
            ;
          }
        }
      }
      getMemoBasedOnRange(fromRange) {
        return fromRange === "sourceOffsets" ? this.sourceCodeOffsetsMemo ?? (this.sourceCodeOffsetsMemo = this.createMemo("sourceOffsets")) : this.generatedCodeOffsetsMemo ?? (this.generatedCodeOffsetsMemo = this.createMemo("generatedOffsets"));
      }
      createMemo(key2) {
        const offsetsSet = /* @__PURE__ */ new Set();
        for (const mapping of this.mappings) {
          for (let i = 0; i < mapping[key2].length; i++) {
            offsetsSet.add(mapping[key2][i]);
            offsetsSet.add(mapping[key2][i] + getLengths(mapping, key2)[i]);
          }
        }
        const offsets = [...offsetsSet].sort((a, b) => a - b);
        const mappings = offsets.map(() => /* @__PURE__ */ new Set());
        for (const mapping of this.mappings) {
          for (let i = 0; i < mapping[key2].length; i++) {
            const startIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key2][i]).match;
            const endIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key2][i] + getLengths(mapping, key2)[i]).match;
            for (let i2 = startIndex; i2 <= endIndex; i2++) {
              mappings[i2].add(mapping);
            }
          }
        }
        return { offsets, mappings };
      }
    };
    exports.SourceMap = SourceMap;
    function getLengths(mapping, key2) {
      return key2 == "sourceOffsets" ? mapping.lengths : mapping.generatedLengths ?? mapping.lengths;
    }
  }
});

// node_modules/@volar/source-map/index.js
var require_source_map = __commonJS({
  "node_modules/@volar/source-map/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_sourceMap(), exports);
    __exportStar(require_translateOffset(), exports);
  }
});

// node_modules/@volar/language-core/lib/editor.js
var require_editor = __commonJS({
  "node_modules/@volar/language-core/lib/editor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHoverEnabled = isHoverEnabled;
    exports.isInlayHintsEnabled = isInlayHintsEnabled;
    exports.isCodeLensEnabled = isCodeLensEnabled;
    exports.isMonikerEnabled = isMonikerEnabled;
    exports.isInlineValueEnabled = isInlineValueEnabled;
    exports.isSemanticTokensEnabled = isSemanticTokensEnabled;
    exports.isCallHierarchyEnabled = isCallHierarchyEnabled;
    exports.isTypeHierarchyEnabled = isTypeHierarchyEnabled;
    exports.isRenameEnabled = isRenameEnabled;
    exports.isDefinitionEnabled = isDefinitionEnabled;
    exports.isTypeDefinitionEnabled = isTypeDefinitionEnabled;
    exports.isReferencesEnabled = isReferencesEnabled;
    exports.isImplementationEnabled = isImplementationEnabled;
    exports.isHighlightEnabled = isHighlightEnabled;
    exports.isSymbolsEnabled = isSymbolsEnabled;
    exports.isFoldingRangesEnabled = isFoldingRangesEnabled;
    exports.isSelectionRangesEnabled = isSelectionRangesEnabled;
    exports.isLinkedEditingEnabled = isLinkedEditingEnabled;
    exports.isColorEnabled = isColorEnabled;
    exports.isDocumentLinkEnabled = isDocumentLinkEnabled;
    exports.isDiagnosticsEnabled = isDiagnosticsEnabled;
    exports.isCodeActionsEnabled = isCodeActionsEnabled;
    exports.isFormattingEnabled = isFormattingEnabled;
    exports.isCompletionEnabled = isCompletionEnabled;
    exports.isAutoInsertEnabled = isAutoInsertEnabled;
    exports.isSignatureHelpEnabled = isSignatureHelpEnabled;
    exports.shouldReportDiagnostics = shouldReportDiagnostics;
    exports.resolveRenameNewName = resolveRenameNewName;
    exports.resolveRenameEditText = resolveRenameEditText;
    exports.findOverlapCodeRange = findOverlapCodeRange;
    function isHoverEnabled(info) {
      return !!info.semantic;
    }
    function isInlayHintsEnabled(info) {
      return !!info.semantic;
    }
    function isCodeLensEnabled(info) {
      return !!info.semantic;
    }
    function isMonikerEnabled(info) {
      return !!info.semantic;
    }
    function isInlineValueEnabled(info) {
      return !!info.semantic;
    }
    function isSemanticTokensEnabled(info) {
      var _a, _b;
      return typeof info.semantic === "object" ? ((_b = (_a = info.semantic).shouldHighlight) == null ? void 0 : _b.call(_a)) ?? true : !!info.semantic;
    }
    function isCallHierarchyEnabled(info) {
      return !!info.navigation;
    }
    function isTypeHierarchyEnabled(info) {
      return !!info.navigation;
    }
    function isRenameEnabled(info) {
      var _a, _b;
      return typeof info.navigation === "object" ? ((_b = (_a = info.navigation).shouldRename) == null ? void 0 : _b.call(_a)) ?? true : !!info.navigation;
    }
    function isDefinitionEnabled(info) {
      return !!info.navigation;
    }
    function isTypeDefinitionEnabled(info) {
      return !!info.navigation;
    }
    function isReferencesEnabled(info) {
      return !!info.navigation;
    }
    function isImplementationEnabled(info) {
      return !!info.navigation;
    }
    function isHighlightEnabled(info) {
      return !!info.navigation;
    }
    function isSymbolsEnabled(info) {
      return !!info.structure;
    }
    function isFoldingRangesEnabled(info) {
      return !!info.structure;
    }
    function isSelectionRangesEnabled(info) {
      return !!info.structure;
    }
    function isLinkedEditingEnabled(info) {
      return !!info.structure;
    }
    function isColorEnabled(info) {
      return !!info.structure;
    }
    function isDocumentLinkEnabled(info) {
      return !!info.structure;
    }
    function isDiagnosticsEnabled(info) {
      return !!info.verification;
    }
    function isCodeActionsEnabled(info) {
      return !!info.verification;
    }
    function isFormattingEnabled(info) {
      return !!info.format;
    }
    function isCompletionEnabled(info) {
      return !!info.completion;
    }
    function isAutoInsertEnabled(info) {
      return !!info.completion;
    }
    function isSignatureHelpEnabled(info) {
      return !!info.completion;
    }
    function shouldReportDiagnostics(info, source, code3) {
      var _a, _b;
      return typeof info.verification === "object" ? ((_b = (_a = info.verification).shouldReport) == null ? void 0 : _b.call(_a, source, code3)) ?? true : !!info.verification;
    }
    function resolveRenameNewName(newName, info) {
      var _a, _b;
      return typeof info.navigation === "object" ? ((_b = (_a = info.navigation).resolveRenameNewName) == null ? void 0 : _b.call(_a, newName)) ?? newName : newName;
    }
    function resolveRenameEditText(text6, info) {
      var _a, _b;
      return typeof info.navigation === "object" ? ((_b = (_a = info.navigation).resolveRenameEditText) == null ? void 0 : _b.call(_a, text6)) ?? text6 : text6;
    }
    function findOverlapCodeRange(start, end, map, filter) {
      let mappedStart;
      let mappedEnd;
      for (const [mapped, mapping] of map.toGeneratedLocation(start)) {
        if (filter(mapping.data)) {
          mappedStart = mapped;
          break;
        }
      }
      for (const [mapped, mapping] of map.toGeneratedLocation(end)) {
        if (filter(mapping.data)) {
          mappedEnd = mapped;
          break;
        }
      }
      if (mappedStart === void 0 || mappedEnd === void 0) {
        for (const mapping of map.mappings) {
          if (filter(mapping.data)) {
            const mappingStart = mapping.sourceOffsets[0];
            const mappingEnd = mapping.sourceOffsets[mapping.sourceOffsets.length - 1] + mapping.lengths[mapping.lengths.length - 1];
            const overlap = getOverlapRange(start, end, mappingStart, mappingEnd);
            if (overlap) {
              const curMappedStart = overlap.start - mappingStart + mapping.generatedOffsets[0];
              const lastGeneratedLength = (mapping.generatedLengths ?? mapping.lengths)[mapping.generatedOffsets.length - 1];
              const curMappedEndOffset = Math.min(overlap.end - mapping.sourceOffsets[mapping.sourceOffsets.length - 1], lastGeneratedLength);
              const curMappedEnd = mapping.generatedOffsets[mapping.generatedOffsets.length - 1] + curMappedEndOffset;
              mappedStart = mappedStart === void 0 ? curMappedStart : Math.min(mappedStart, curMappedStart);
              mappedEnd = mappedEnd === void 0 ? curMappedEnd : Math.max(mappedEnd, curMappedEnd);
            }
          }
        }
      }
      if (mappedStart !== void 0 && mappedEnd !== void 0) {
        return {
          start: mappedStart,
          end: mappedEnd
        };
      }
    }
    function getOverlapRange(range1Start, range1End, range2Start, range2End) {
      const start = Math.max(range1Start, range2Start);
      const end = Math.min(range1End, range2End);
      if (start > end) {
        return void 0;
      }
      return {
        start,
        end
      };
    }
  }
});

// node_modules/@volar/language-core/lib/linkedCodeMap.js
var require_linkedCodeMap = __commonJS({
  "node_modules/@volar/language-core/lib/linkedCodeMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedCodeMap = void 0;
    var source_map_1 = require_source_map();
    var LinkedCodeMap = class extends source_map_1.SourceMap {
      *getLinkedOffsets(start) {
        for (const mapped of this.toGeneratedLocation(start)) {
          yield mapped[0];
        }
        for (const mapped of this.toSourceLocation(start)) {
          yield mapped[0];
        }
      }
    };
    exports.LinkedCodeMap = LinkedCodeMap;
  }
});

// node_modules/@volar/language-core/lib/types.js
var require_types2 = __commonJS({
  "node_modules/@volar/language-core/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@volar/language-core/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@volar/language-core/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileMap = void 0;
    var FileMap2 = class extends Map {
      constructor(caseSensitive) {
        super();
        this.caseSensitive = caseSensitive;
        this.originalFileNames = /* @__PURE__ */ new Map();
      }
      keys() {
        return this.originalFileNames.values();
      }
      get(key2) {
        return super.get(this.normalizeId(key2));
      }
      has(key2) {
        return super.has(this.normalizeId(key2));
      }
      set(key2, value) {
        this.originalFileNames.set(this.normalizeId(key2), key2);
        return super.set(this.normalizeId(key2), value);
      }
      delete(key2) {
        this.originalFileNames.delete(this.normalizeId(key2));
        return super.delete(this.normalizeId(key2));
      }
      clear() {
        this.originalFileNames.clear();
        return super.clear();
      }
      normalizeId(id) {
        return this.caseSensitive ? id : id.toLowerCase();
      }
    };
    exports.FileMap = FileMap2;
  }
});

// node_modules/@volar/language-core/index.js
var require_language_core = __commonJS({
  "node_modules/@volar/language-core/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultMapperFactory = exports.SourceMap = void 0;
    exports.createLanguage = createLanguage2;
    exports.forEachEmbeddedCode = forEachEmbeddedCode;
    var source_map_1 = require_source_map();
    Object.defineProperty(exports, "SourceMap", { enumerable: true, get: function() {
      return source_map_1.SourceMap;
    } });
    __exportStar(require_editor(), exports);
    __exportStar(require_linkedCodeMap(), exports);
    __exportStar(require_types2(), exports);
    __exportStar(require_utils(), exports);
    var source_map_2 = require_source_map();
    var linkedCodeMap_1 = require_linkedCodeMap();
    var defaultMapperFactory2 = (mappings) => new source_map_2.SourceMap(mappings);
    exports.defaultMapperFactory = defaultMapperFactory2;
    function createLanguage2(plugins, scriptRegistry, sync, onAssociationDirty) {
      const virtualCodeToSourceScriptMap = /* @__PURE__ */ new WeakMap();
      const virtualCodeToSourceMap = /* @__PURE__ */ new WeakMap();
      const virtualCodeToLinkedCodeMap = /* @__PURE__ */ new WeakMap();
      const language = {
        mapperFactory: exports.defaultMapperFactory,
        plugins,
        scripts: {
          fromVirtualCode(virtualCode) {
            return virtualCodeToSourceScriptMap.get(virtualCode);
          },
          get(id, includeFsFiles = true, shouldRegister = false) {
            sync(id, includeFsFiles, shouldRegister);
            const result = scriptRegistry.get(id);
            if (result == null ? void 0 : result.isAssociationDirty) {
              this.set(id, result.snapshot, result.languageId);
            }
            return scriptRegistry.get(id);
          },
          set(id, snapshot, languageId, _plugins = plugins) {
            var _a, _b, _c;
            if (!languageId) {
              for (const plugin of plugins) {
                languageId = (_a = plugin.getLanguageId) == null ? void 0 : _a.call(plugin, id);
                if (languageId) {
                  break;
                }
              }
            }
            if (!languageId) {
              console.warn(`languageId not found for ${id}`);
              return;
            }
            let associatedOnly = false;
            for (const plugin of plugins) {
              if ((_b = plugin.isAssociatedFileOnly) == null ? void 0 : _b.call(plugin, id, languageId)) {
                associatedOnly = true;
                break;
              }
            }
            if (scriptRegistry.has(id)) {
              const sourceScript = scriptRegistry.get(id);
              if (sourceScript.languageId !== languageId || sourceScript.associatedOnly !== associatedOnly) {
                this.delete(id);
                triggerTargetsDirty(sourceScript);
                return this.set(id, snapshot, languageId);
              } else if (associatedOnly) {
                if (sourceScript.snapshot !== snapshot) {
                  sourceScript.snapshot = snapshot;
                  triggerTargetsDirty(sourceScript);
                }
              } else if (sourceScript.isAssociationDirty || sourceScript.snapshot !== snapshot) {
                if (sourceScript.snapshot !== snapshot) {
                  sourceScript.snapshot = snapshot;
                  triggerTargetsDirty(sourceScript);
                }
                const codegenCtx = prepareCreateVirtualCode(sourceScript);
                if (sourceScript.generated) {
                  const { updateVirtualCode, createVirtualCode } = sourceScript.generated.languagePlugin;
                  const newVirtualCode = updateVirtualCode ? updateVirtualCode(id, sourceScript.generated.root, snapshot, codegenCtx) : createVirtualCode == null ? void 0 : createVirtualCode(id, languageId, snapshot, codegenCtx);
                  if (newVirtualCode) {
                    sourceScript.generated.root = newVirtualCode;
                    sourceScript.generated.embeddedCodes.clear();
                    for (const code3 of forEachEmbeddedCode(sourceScript.generated.root)) {
                      virtualCodeToSourceScriptMap.set(code3, sourceScript);
                      sourceScript.generated.embeddedCodes.set(code3.id, code3);
                    }
                    return sourceScript;
                  } else {
                    this.delete(id);
                    return;
                  }
                }
              } else {
                return sourceScript;
              }
            } else {
              const sourceScript = {
                id,
                languageId,
                snapshot,
                associatedIds: /* @__PURE__ */ new Set(),
                targetIds: /* @__PURE__ */ new Set(),
                associatedOnly
              };
              scriptRegistry.set(id, sourceScript);
              if (associatedOnly) {
                return sourceScript;
              }
              for (const languagePlugin of _plugins) {
                const virtualCode = (_c = languagePlugin.createVirtualCode) == null ? void 0 : _c.call(languagePlugin, id, languageId, snapshot, prepareCreateVirtualCode(sourceScript));
                if (virtualCode) {
                  sourceScript.generated = {
                    root: virtualCode,
                    languagePlugin,
                    embeddedCodes: /* @__PURE__ */ new Map()
                  };
                  for (const code3 of forEachEmbeddedCode(virtualCode)) {
                    virtualCodeToSourceScriptMap.set(code3, sourceScript);
                    sourceScript.generated.embeddedCodes.set(code3.id, code3);
                  }
                  break;
                }
              }
              return sourceScript;
            }
          },
          delete(id) {
            var _a, _b, _c;
            const sourceScript = scriptRegistry.get(id);
            if (sourceScript) {
              (_c = (_a = sourceScript.generated) == null ? void 0 : (_b = _a.languagePlugin).disposeVirtualCode) == null ? void 0 : _c.call(_b, id, sourceScript.generated.root);
              scriptRegistry.delete(id);
              triggerTargetsDirty(sourceScript);
            }
          }
        },
        maps: {
          get(virtualCode, sourceScript) {
            var _a;
            let mapCache = virtualCodeToSourceMap.get(virtualCode.snapshot);
            if (!mapCache) {
              virtualCodeToSourceMap.set(virtualCode.snapshot, mapCache = /* @__PURE__ */ new WeakMap());
            }
            if (!mapCache.has(sourceScript.snapshot)) {
              const mappings = ((_a = virtualCode.associatedScriptMappings) == null ? void 0 : _a.get(sourceScript.id)) ?? virtualCode.mappings;
              mapCache.set(sourceScript.snapshot, language.mapperFactory(mappings));
            }
            return mapCache.get(sourceScript.snapshot);
          },
          *forEach(virtualCode) {
            const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);
            yield [
              sourceScript,
              this.get(virtualCode, sourceScript)
            ];
            if (virtualCode.associatedScriptMappings) {
              for (const [relatedScriptId] of virtualCode.associatedScriptMappings) {
                const relatedSourceScript = scriptRegistry.get(relatedScriptId);
                if (relatedSourceScript) {
                  yield [
                    relatedSourceScript,
                    this.get(virtualCode, relatedSourceScript)
                  ];
                }
              }
            }
          }
        },
        linkedCodeMaps: {
          get(virtualCode) {
            const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);
            let mapCache = virtualCodeToLinkedCodeMap.get(virtualCode.snapshot);
            if ((mapCache == null ? void 0 : mapCache[0]) !== sourceScript.snapshot) {
              virtualCodeToLinkedCodeMap.set(virtualCode.snapshot, mapCache = [
                sourceScript.snapshot,
                virtualCode.linkedCodeMappings ? new linkedCodeMap_1.LinkedCodeMap(virtualCode.linkedCodeMappings) : void 0
              ]);
            }
            return mapCache[1];
          }
        }
      };
      return language;
      function triggerTargetsDirty(sourceScript) {
        sourceScript.targetIds.forEach((id) => {
          const sourceScript2 = scriptRegistry.get(id);
          if (sourceScript2) {
            sourceScript2.isAssociationDirty = true;
            onAssociationDirty == null ? void 0 : onAssociationDirty(sourceScript2.id);
          }
        });
      }
      function prepareCreateVirtualCode(sourceScript) {
        var _a;
        for (const id of sourceScript.associatedIds) {
          (_a = scriptRegistry.get(id)) == null ? void 0 : _a.targetIds.delete(sourceScript.id);
        }
        sourceScript.associatedIds.clear();
        sourceScript.isAssociationDirty = false;
        return {
          getAssociatedScript(id) {
            sync(id, true, true);
            const relatedSourceScript = scriptRegistry.get(id);
            if (relatedSourceScript) {
              relatedSourceScript.targetIds.add(sourceScript.id);
              sourceScript.associatedIds.add(relatedSourceScript.id);
            }
            return relatedSourceScript;
          }
        };
      }
    }
    function* forEachEmbeddedCode(virtualCode) {
      yield virtualCode;
      if (virtualCode.embeddedCodes) {
        for (const embeddedCode of virtualCode.embeddedCodes) {
          yield* forEachEmbeddedCode(embeddedCode);
        }
      }
    }
  }
});

// node_modules/@vue/language-core/lib/plugins/file-html.js
var require_file_html = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/file-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sfcBlockReg = /\<(script|style)\b([\s\S]*?)\>([\s\S]*?)\<\/\1\>/g;
    var langReg = /\blang\s*=\s*(['\"]?)(\S*)\b\1/;
    var plugin = ({ vueCompilerOptions }) => {
      return {
        version: 2.1,
        getLanguageId(fileName) {
          if (vueCompilerOptions.petiteVueExtensions.some((ext) => fileName.endsWith(ext))) {
            return "html";
          }
        },
        isValidFile(_fileName, languageId) {
          return languageId === "html";
        },
        parseSFC2(fileName, languageId, content3) {
          var _a;
          if (languageId !== "html") {
            return;
          }
          let sfc = {
            descriptor: {
              filename: fileName,
              source: content3,
              template: null,
              script: null,
              scriptSetup: null,
              styles: [],
              customBlocks: [],
              cssVars: [],
              shouldForceReload: () => false,
              slotted: false
            },
            errors: []
          };
          let templateContent = content3;
          for (const match of content3.matchAll(sfcBlockReg)) {
            const matchText = match[0];
            const tag = match[1];
            const attrs = match[2];
            const lang = (_a = attrs.match(langReg)) == null ? void 0 : _a[2];
            const content4 = match[3];
            const contentStart = match.index + matchText.indexOf(content4);
            if (tag === "style") {
              sfc.descriptor.styles.push({
                attrs: {},
                content: content4,
                loc: {
                  start: { column: -1, line: -1, offset: contentStart },
                  end: { column: -1, line: -1, offset: contentStart + content4.length },
                  source: content4
                },
                type: "style",
                lang
              });
            } else if (tag === "script" && attrs.indexOf("src=") === -1) {
              let type = attrs.indexOf("type=") >= 0 ? "scriptSetup" : "script";
              sfc.descriptor[type] = {
                attrs: {},
                content: content4,
                loc: {
                  start: { column: -1, line: -1, offset: contentStart },
                  end: { column: -1, line: -1, offset: contentStart + content4.length },
                  source: content4
                },
                type: "script",
                lang
              };
            }
            templateContent = templateContent.substring(0, match.index) + " ".repeat(matchText.length) + templateContent.substring(match.index + matchText.length);
          }
          sfc.descriptor.template = {
            attrs: {},
            content: templateContent,
            loc: {
              start: { column: -1, line: -1, offset: 0 },
              end: { column: -1, line: -1, offset: templateContent.length },
              source: templateContent
            },
            type: "template",
            ast: {}
          };
          return sfc;
        }
      };
    };
    exports.default = plugin;
  }
});

// node_modules/@vue/language-core/lib/utils/buildMappings.js
var require_buildMappings = __commonJS({
  "node_modules/@vue/language-core/lib/utils/buildMappings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildMappings = buildMappings;
    function buildMappings(chunks) {
      let length = 0;
      const mappings = [];
      for (const segment of chunks) {
        if (typeof segment === "string") {
          length += segment.length;
        } else {
          mappings.push({
            sourceOffsets: [segment[2]],
            generatedOffsets: [length],
            lengths: [segment[0].length],
            data: segment[3]
          });
          length += segment[0].length;
        }
      }
      return mappings;
    }
  }
});

// node_modules/@vue/language-core/lib/utils/parseSfc.js
var require_parseSfc = __commonJS({
  "node_modules/@vue/language-core/lib/utils/parseSfc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = parse3;
    var compiler2 = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    function parse3(source) {
      const errors = [];
      const ast = compiler2.parse(source, {
        // there are no components at SFC parsing level
        isNativeTag: () => true,
        // preserve all whitespaces
        isPreTag: () => true,
        parseMode: "sfc",
        onError: (e) => {
          errors.push(e);
        },
        comments: true
      });
      const descriptor = {
        filename: "anonymous.vue",
        source,
        template: null,
        script: null,
        scriptSetup: null,
        styles: [],
        customBlocks: [],
        cssVars: [],
        slotted: false,
        shouldForceReload: () => false
      };
      ast.children.forEach((node2) => {
        if (node2.type !== compiler2.NodeTypes.ELEMENT) {
          return;
        }
        switch (node2.tag) {
          case "template":
            descriptor.template = createBlock(node2, source);
            break;
          case "script":
            const scriptBlock = createBlock(node2, source);
            const isSetup = !!scriptBlock.attrs.setup;
            if (isSetup && !descriptor.scriptSetup) {
              descriptor.scriptSetup = scriptBlock;
              break;
            }
            if (!isSetup && !descriptor.script) {
              descriptor.script = scriptBlock;
              break;
            }
            break;
          case "style":
            const styleBlock = createBlock(node2, source);
            descriptor.styles.push(styleBlock);
            break;
          default:
            descriptor.customBlocks.push(createBlock(node2, source));
            break;
        }
      });
      return {
        descriptor,
        errors
      };
    }
    function createBlock(node2, source) {
      const type = node2.tag;
      let { start, end } = node2.loc;
      let content3 = "";
      if (node2.children.length) {
        start = node2.children[0].loc.start;
        end = node2.children[node2.children.length - 1].loc.end;
        content3 = source.slice(start.offset, end.offset);
      } else {
        const offset = node2.loc.source.indexOf(`</`);
        if (offset > -1) {
          start = {
            line: start.line,
            column: start.column + offset,
            offset: start.offset + offset
          };
        }
        end = Object.assign({}, start);
      }
      const loc = {
        source: content3,
        start,
        end
      };
      const attrs = {};
      const block = {
        type,
        content: content3,
        loc,
        attrs
      };
      node2.props.forEach((p2) => {
        var _a, _b, _c;
        if (p2.type === compiler2.NodeTypes.ATTRIBUTE) {
          attrs[p2.name] = p2.value ? p2.value.content || true : true;
          if (p2.name === "lang") {
            block.lang = p2.value && p2.value.content;
          } else if (p2.name === "src") {
            block.src = p2.value && p2.value.content;
          } else if (type === "style") {
            if (p2.name === "scoped") {
              block.scoped = true;
            } else if (p2.name === "module") {
              block.module = {
                name: ((_a = p2.value) == null ? void 0 : _a.content) ?? "$style",
                offset: ((_b = p2.value) == null ? void 0 : _b.content) ? ((_c = p2.value) == null ? void 0 : _c.loc.start.offset) - node2.loc.start.offset : void 0
              };
            }
          } else if (type === "script" && p2.name === "setup") {
            block.setup = attrs.setup;
          }
        }
      });
      return block;
    }
  }
});

// node_modules/@vue/language-core/lib/plugins/file-md.js
var require_file_md = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/file-md.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var language_core_1 = require_language_core();
    var muggle_string_1 = require_out();
    var buildMappings_1 = require_buildMappings();
    var parseSfc_1 = require_parseSfc();
    var codeblockReg = /(`{3,})[\s\S]+?\1/g;
    var inlineCodeblockReg = /`[^\n`]+?`/g;
    var scriptSetupReg = /\\\<[\s\S]+?\>\n?/g;
    var sfcBlockReg = /\<(script|style)\b[\s\S]*?\>([\s\S]*?)\<\/\1\>/g;
    var angleBracketReg = /\<\S*\:\S*\>/g;
    var linkReg = /\[[\s\S]*?\]\([\s\S]*?\)/g;
    var codeSnippetImportReg = /^\s*<<<\s*.+/gm;
    var plugin = ({ vueCompilerOptions }) => {
      return {
        version: 2.1,
        getLanguageId(fileName) {
          if (vueCompilerOptions.vitePressExtensions.some((ext) => fileName.endsWith(ext))) {
            return "markdown";
          }
        },
        isValidFile(_fileName, languageId) {
          return languageId === "markdown";
        },
        parseSFC2(_fileName, languageId, content3) {
          if (languageId !== "markdown") {
            return;
          }
          content3 = content3.replace(codeblockReg, (match, quotes) => quotes + " ".repeat(match.length - quotes.length * 2) + quotes).replace(inlineCodeblockReg, (match) => `\`${" ".repeat(match.length - 2)}\``).replace(scriptSetupReg, (match) => " ".repeat(match.length)).replace(codeSnippetImportReg, (match) => " ".repeat(match.length));
          const codes2 = [];
          for (const match of content3.matchAll(sfcBlockReg)) {
            if (match.index !== void 0) {
              const matchText = match[0];
              codes2.push([matchText, void 0, match.index]);
              codes2.push("\n\n");
              content3 = content3.substring(0, match.index) + " ".repeat(matchText.length) + content3.substring(match.index + matchText.length);
            }
          }
          content3 = content3.replace(angleBracketReg, (match) => " ".repeat(match.length)).replace(linkReg, (match) => " ".repeat(match.length));
          codes2.push("<template>\n");
          codes2.push([content3, void 0, 0]);
          codes2.push("\n</template>");
          const file2VueSourceMap = (0, language_core_1.defaultMapperFactory)((0, buildMappings_1.buildMappings)(codes2));
          const sfc = (0, parseSfc_1.parse)((0, muggle_string_1.toString)(codes2));
          if (sfc.descriptor.template) {
            sfc.descriptor.template.lang = "md";
            transformRange(sfc.descriptor.template);
          }
          if (sfc.descriptor.script) {
            transformRange(sfc.descriptor.script);
          }
          if (sfc.descriptor.scriptSetup) {
            transformRange(sfc.descriptor.scriptSetup);
          }
          for (const style of sfc.descriptor.styles) {
            transformRange(style);
          }
          for (const customBlock of sfc.descriptor.customBlocks) {
            transformRange(customBlock);
          }
          return sfc;
          function transformRange(block) {
            const { start, end } = block.loc;
            const startOffset = start.offset;
            const endOffset = end.offset;
            start.offset = -1;
            end.offset = -1;
            for (const [offset] of file2VueSourceMap.toSourceLocation(startOffset)) {
              start.offset = offset;
              break;
            }
            for (const [offset] of file2VueSourceMap.toSourceLocation(endOffset)) {
              end.offset = offset;
              break;
            }
          }
        }
      };
    };
    exports.default = plugin;
  }
});

// node_modules/@vue/language-core/lib/plugins/file-vue.js
var require_file_vue = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/file-vue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var parseSfc_1 = require_parseSfc();
    var plugin = ({ vueCompilerOptions }) => {
      return {
        version: 2.1,
        getLanguageId(fileName) {
          if (vueCompilerOptions.extensions.some((ext) => fileName.endsWith(ext))) {
            return "vue";
          }
        },
        isValidFile(_fileName, languageId) {
          return languageId === "vue";
        },
        parseSFC2(_fileName, languageId, content3) {
          if (languageId !== "vue") {
            return;
          }
          return (0, parseSfc_1.parse)(content3);
        },
        updateSFC(sfc, change) {
          const blocks = [
            sfc.descriptor.template,
            sfc.descriptor.script,
            sfc.descriptor.scriptSetup,
            ...sfc.descriptor.styles,
            ...sfc.descriptor.customBlocks
          ].filter((block) => !!block);
          const hitBlock = blocks.find((block) => change.start >= block.loc.start.offset && change.end <= block.loc.end.offset);
          if (!hitBlock) {
            return;
          }
          const oldContent = hitBlock.content;
          const newContent = hitBlock.content = hitBlock.content.substring(0, change.start - hitBlock.loc.start.offset) + change.newText + hitBlock.content.substring(change.end - hitBlock.loc.start.offset);
          const endTagRegex = new RegExp(`</\\s*${hitBlock.type}\\s*>`);
          const insertedEndTag = !!oldContent.match(endTagRegex) !== !!newContent.match(endTagRegex);
          if (insertedEndTag) {
            return;
          }
          const lengthDiff = change.newText.length - (change.end - change.start);
          for (const block of blocks) {
            if (block.loc.start.offset > change.end) {
              block.loc.start.offset += lengthDiff;
            }
            if (block.loc.end.offset >= change.end) {
              block.loc.end.offset += lengthDiff;
            }
          }
          return sfc;
        }
      };
    };
    exports.default = plugin;
  }
});

// node_modules/@vue/language-core/lib/plugins/shared.js
var require_shared2 = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.allCodeFeatures = void 0;
    exports.allCodeFeatures = {
      verification: true,
      completion: true,
      semantic: true,
      navigation: true,
      structure: true,
      format: true
    };
  }
});

// node_modules/@vue/language-core/lib/plugins/vue-root-tags.js
var require_vue_root_tags = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/vue-root-tags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var muggle_string_1 = require_out();
    var shared_1 = require_shared2();
    var plugin = () => {
      return {
        version: 2.1,
        getEmbeddedCodes() {
          return [{
            id: "root_tags",
            lang: "vue-root-tags"
          }];
        },
        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
          if (embeddedFile.id === "root_tags") {
            embeddedFile.content.push([sfc.content, void 0, 0, shared_1.allCodeFeatures]);
            for (const block of [
              sfc.script,
              sfc.scriptSetup,
              sfc.template,
              ...sfc.styles,
              ...sfc.customBlocks
            ]) {
              if (!block) {
                continue;
              }
              let content3 = block.content;
              if (content3.endsWith("\r\n")) {
                content3 = content3.slice(0, -2);
              } else if (content3.endsWith("\n")) {
                content3 = content3.slice(0, -1);
              }
              const offset = content3.lastIndexOf("\n") + 1;
              (0, muggle_string_1.replaceSourceRange)(embeddedFile.content, void 0, block.startTagEnd, block.endTagStart, sfc.content.substring(block.startTagEnd, block.startTagEnd + offset), [
                "",
                void 0,
                block.startTagEnd + offset,
                { structure: true }
              ], sfc.content.substring(block.startTagEnd + offset, block.endTagStart));
            }
          } else {
            embeddedFile.parentCodeId ?? (embeddedFile.parentCodeId = "root_tags");
          }
        }
      };
    };
    exports.default = plugin;
  }
});

// node_modules/@vue/language-core/lib/plugins/vue-script-js.js
var require_vue_script_js = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/vue-script-js.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var plugin = ({ modules }) => {
      return {
        version: 2.1,
        compileSFCScript(lang, script) {
          if (lang === "js" || lang === "ts" || lang === "jsx" || lang === "tsx") {
            const ts3 = modules.typescript;
            return ts3.createSourceFile("test." + lang, script, 99);
          }
        }
      };
    };
    exports.default = plugin;
  }
});

// node_modules/@vue/language-core/lib/plugins/vue-sfc-customblocks.js
var require_vue_sfc_customblocks = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/vue-sfc-customblocks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shared_1 = require_shared2();
    var plugin = () => {
      return {
        version: 2.1,
        getEmbeddedCodes(_fileName, sfc) {
          return sfc.customBlocks.map((customBlock, i) => ({
            id: "custom_block_" + i,
            lang: customBlock.lang
          }));
        },
        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
          if (embeddedFile.id.startsWith("custom_block_")) {
            const index2 = parseInt(embeddedFile.id.slice("custom_block_".length));
            const customBlock = sfc.customBlocks[index2];
            embeddedFile.content.push([
              customBlock.content,
              customBlock.name,
              0,
              shared_1.allCodeFeatures
            ]);
          }
        }
      };
    };
    exports.default = plugin;
  }
});

// node_modules/@vue/language-core/lib/plugins/vue-sfc-scripts.js
var require_vue_sfc_scripts = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/vue-sfc-scripts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var plugin = () => {
      return {
        version: 2.1,
        getEmbeddedCodes(_fileName, sfc) {
          const names = [];
          if (sfc.script) {
            names.push({ id: "script_raw", lang: sfc.script.lang });
          }
          if (sfc.scriptSetup) {
            names.push({ id: "scriptsetup_raw", lang: sfc.scriptSetup.lang });
          }
          return names;
        },
        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
          const script = embeddedFile.id === "script_raw" ? sfc.script : embeddedFile.id === "scriptsetup_raw" ? sfc.scriptSetup : void 0;
          if (script) {
            embeddedFile.content.push([
              script.content,
              script.name,
              0,
              {
                structure: true,
                format: true
              }
            ]);
          }
        }
      };
    };
    exports.default = plugin;
  }
});

// node_modules/@vue/language-core/lib/plugins/vue-sfc-styles.js
var require_vue_sfc_styles = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/vue-sfc-styles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shared_1 = require_shared2();
    var plugin = () => {
      return {
        version: 2.1,
        getEmbeddedCodes(_fileName, sfc) {
          const result = [];
          for (let i = 0; i < sfc.styles.length; i++) {
            const style = sfc.styles[i];
            if (style) {
              result.push({
                id: "style_" + i,
                lang: style.lang
              });
              if (style.cssVars.length) {
                result.push({
                  id: "style_" + i + "_inline_ts",
                  lang: "ts"
                });
              }
            }
          }
          return result;
        },
        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
          if (embeddedFile.id.startsWith("style_")) {
            const index2 = parseInt(embeddedFile.id.split("_")[1]);
            const style = sfc.styles[index2];
            if (embeddedFile.id.endsWith("_inline_ts")) {
              embeddedFile.parentCodeId = "style_" + index2;
              for (const cssVar of style.cssVars) {
                embeddedFile.content.push("(", [
                  cssVar.text,
                  style.name,
                  cssVar.offset,
                  shared_1.allCodeFeatures
                ], ");\n");
              }
            } else {
              embeddedFile.content.push([
                style.content,
                style.name,
                0,
                shared_1.allCodeFeatures
              ]);
            }
          }
        }
      };
    };
    exports.default = plugin;
  }
});

// node_modules/@vue/language-core/lib/plugins/vue-sfc-template.js
var require_vue_sfc_template = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/vue-sfc-template.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shared_1 = require_shared2();
    var plugin = () => {
      return {
        version: 2.1,
        getEmbeddedCodes(_fileName, sfc) {
          var _a;
          if (((_a = sfc.template) == null ? void 0 : _a.lang) === "html") {
            return [{
              id: "template",
              lang: sfc.template.lang
            }];
          }
          return [];
        },
        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
          var _a;
          if (embeddedFile.id === "template" && ((_a = sfc.template) == null ? void 0 : _a.lang) === "html") {
            embeddedFile.content.push([
              sfc.template.content,
              sfc.template.name,
              0,
              shared_1.allCodeFeatures
            ]);
          }
        }
      };
    };
    exports.default = plugin;
  }
});

// node_modules/@vue/language-core/lib/plugins/vue-template-html.js
var require_vue_template_html = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/vue-template-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shouldAddSuffix = new RegExp("(?<=<[^>/]+)$");
    var plugin = ({ modules }) => {
      return {
        version: 2.1,
        compileSFCTemplate(lang, template, options) {
          if (lang === "html" || lang === "md") {
            const compiler2 = modules["@vue/compiler-dom"];
            let addedSuffix = false;
            if (shouldAddSuffix.test(template)) {
              template += ">";
              addedSuffix = true;
            }
            const result = compiler2.compile(template, {
              ...options,
              comments: true
            });
            result.__addedSuffix = addedSuffix;
            return result;
          }
        },
        updateSFCTemplate(oldResult, change) {
          oldResult.code = oldResult.code.slice(0, change.start) + change.newText + oldResult.code.slice(change.end);
          if (oldResult.__addedSuffix) {
            const originalTemplate = oldResult.code.slice(0, -1);
            if (!shouldAddSuffix.test(originalTemplate)) {
              return void 0;
            }
          }
          const CompilerDOM = modules["@vue/compiler-dom"];
          const lengthDiff = change.newText.length - (change.end - change.start);
          let hitNodes = [];
          if (tryUpdateNode(oldResult.ast) && hitNodes.length) {
            hitNodes = hitNodes.sort((a, b) => a.loc.source.length - b.loc.source.length);
            const hitNode = hitNodes[0];
            if (hitNode.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
              return oldResult;
            }
          }
          function tryUpdateNode(node2) {
            if (withinChangeRange(node2.loc)) {
              hitNodes.push(node2);
            }
            if (tryUpdateNodeLoc(node2.loc)) {
              if (node2.type === CompilerDOM.NodeTypes.ROOT) {
                for (const child of node2.children) {
                  if (!tryUpdateNode(child)) {
                    return false;
                  }
                }
              } else if (node2.type === CompilerDOM.NodeTypes.ELEMENT) {
                if (withinChangeRange(node2.loc)) {
                  const start = node2.loc.start.offset + 2;
                  const end = node2.loc.start.offset + node2.loc.source.lastIndexOf("</");
                  if (!withinChangeRange({ start: { offset: start }, end: { offset: end }, source: "" })) {
                    return false;
                  }
                }
                for (const prop of node2.props) {
                  if (!tryUpdateNode(prop)) {
                    return false;
                  }
                }
                for (const child of node2.children) {
                  if (!tryUpdateNode(child)) {
                    return false;
                  }
                }
              } else if (node2.type === CompilerDOM.NodeTypes.ATTRIBUTE) {
                if (node2.value && !tryUpdateNode(node2.value)) {
                  return false;
                }
              } else if (node2.type === CompilerDOM.NodeTypes.DIRECTIVE) {
                if (node2.arg && withinChangeRange(node2.arg.loc) && node2.name === "slot") {
                  return false;
                }
                if (node2.exp && withinChangeRange(node2.exp.loc) && node2.name === "for") {
                  return false;
                }
                if (node2.arg && !tryUpdateNode(node2.arg)) {
                  return false;
                }
                if (node2.exp && !tryUpdateNode(node2.exp)) {
                  return false;
                }
              } else if (node2.type === CompilerDOM.NodeTypes.TEXT_CALL) {
                if (!tryUpdateNode(node2.content)) {
                  return false;
                }
              } else if (node2.type === CompilerDOM.NodeTypes.COMPOUND_EXPRESSION) {
                for (const childNode of node2.children) {
                  if (typeof childNode === "object") {
                    if (!tryUpdateNode(childNode)) {
                      return false;
                    }
                  }
                }
              } else if (node2.type === CompilerDOM.NodeTypes.IF) {
                for (const branch of node2.branches) {
                  if (branch.condition && !tryUpdateNode(branch.condition)) {
                    return false;
                  }
                  for (const child of branch.children) {
                    if (!tryUpdateNode(child)) {
                      return false;
                    }
                  }
                }
              } else if (node2.type === CompilerDOM.NodeTypes.FOR) {
                for (const child of [
                  node2.parseResult.source,
                  node2.parseResult.value,
                  node2.parseResult.key,
                  node2.parseResult.index
                ]) {
                  if (child) {
                    if (!tryUpdateNode(child)) {
                      return false;
                    }
                    if (child.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
                      const content3 = child.content.trim();
                      if (content3.startsWith("(") || content3.endsWith(")")) {
                        return false;
                      }
                    }
                  }
                }
                for (const child of node2.children) {
                  if (!tryUpdateNode(child)) {
                    return false;
                  }
                }
              } else if (node2.type === CompilerDOM.NodeTypes.INTERPOLATION) {
                if (!tryUpdateNode(node2.content)) {
                  return false;
                }
              } else if (node2.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
                if (withinChangeRange(node2.loc)) {
                  if (node2.isStatic) {
                    return false;
                  } else {
                    node2.content = node2.loc.source;
                  }
                }
              }
              return true;
            }
            return false;
          }
          function tryUpdateNodeLoc(loc) {
            delete loc.__endOffset;
            if (withinChangeRange(loc)) {
              loc.source = loc.source.substring(0, change.start - loc.start.offset) + change.newText + loc.source.substring(change.end - loc.start.offset);
              loc.__endOffset = loc.end.offset;
              loc.end.offset += lengthDiff;
              return true;
            } else if (change.end <= loc.start.offset) {
              loc.__endOffset = loc.end.offset;
              loc.start.offset += lengthDiff;
              loc.end.offset += lengthDiff;
              return true;
            } else if (change.start >= loc.end.offset) {
              return true;
            }
            return false;
          }
          function withinChangeRange(loc) {
            const originalLocEnd = loc.__endOffset ?? loc.end.offset;
            return change.start >= loc.start.offset && change.end <= originalLocEnd;
          }
        }
      };
    };
    exports.default = plugin;
  }
});

// node_modules/@vue/language-core/lib/plugins/vue-template-inline-css.js
var require_vue_template_inline_css = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/vue-template-inline-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var template_1 = require_template();
    var shared_1 = require_shared2();
    var codeFeatures = {
      ...shared_1.allCodeFeatures,
      format: false,
      structure: false
    };
    var plugin = () => {
      return {
        version: 2.1,
        getEmbeddedCodes(_fileName, sfc) {
          var _a;
          if (!((_a = sfc.template) == null ? void 0 : _a.ast)) {
            return [];
          }
          return [{ id: "template_inline_css", lang: "css" }];
        },
        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
          var _a;
          if (embeddedFile.id !== "template_inline_css" || !((_a = sfc.template) == null ? void 0 : _a.ast)) {
            return;
          }
          embeddedFile.parentCodeId = "template";
          embeddedFile.content.push(...generate2(sfc.template.ast));
        }
      };
    };
    exports.default = plugin;
    function* generate2(templateAst) {
      var _a, _b;
      for (const node2 of (0, template_1.forEachElementNode)(templateAst)) {
        for (const prop of node2.props) {
          if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE && prop.name === "bind" && ((_a = prop.arg) == null ? void 0 : _a.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && ((_b = prop.exp) == null ? void 0 : _b.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && prop.arg.content === "style" && prop.exp.constType === CompilerDOM.ConstantTypes.CAN_STRINGIFY) {
            const endCrt = prop.arg.loc.source[prop.arg.loc.source.length - 1];
            const start = prop.arg.loc.source.indexOf(endCrt) + 1;
            const end = prop.arg.loc.source.lastIndexOf(endCrt);
            const content3 = prop.arg.loc.source.substring(start, end);
            yield `x { `;
            yield [
              content3,
              "template",
              prop.arg.loc.start.offset + start,
              codeFeatures
            ];
            yield ` }
`;
          }
        }
      }
    }
  }
});

// node_modules/@vue/language-core/lib/plugins/vue-template-inline-ts.js
var require_vue_template_inline_ts = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/vue-template-inline-ts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var common_1 = require_common();
    var elementEvents_1 = require_elementEvents();
    var templateChild_1 = require_templateChild();
    var vFor_1 = require_vFor();
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var codeFeatures = {
      format: true
    };
    var formatBrackets = {
      normal: ["`${", "}`;"],
      if: ["if (", ") { }"],
      for: ["for (", ") { }"],
      // fix https://github.com/vuejs/language-tools/issues/3572
      params: ["(", ") => {};"],
      // fix https://github.com/vuejs/language-tools/issues/1210
      // fix https://github.com/vuejs/language-tools/issues/2305
      curly: ["0 +", "+ 0;"],
      event: ["() => ", ";"]
    };
    var plugin = (ctx) => {
      const parseds = /* @__PURE__ */ new WeakMap();
      return {
        version: 2.1,
        getEmbeddedCodes(_fileName, sfc) {
          var _a;
          if (!((_a = sfc.template) == null ? void 0 : _a.ast)) {
            return [];
          }
          const parsed = parse3(sfc);
          parseds.set(sfc, parsed);
          const result = [];
          for (const [id] of parsed) {
            result.push({ id, lang: "ts" });
          }
          return result;
        },
        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {
          (() => {
            var _a;
            return (_a = sfc.template) == null ? void 0 : _a.content;
          })();
          const parsed = parseds.get(sfc);
          if (parsed) {
            const codes2 = parsed.get(embeddedFile.id);
            if (codes2) {
              embeddedFile.content.push(...codes2);
              embeddedFile.parentCodeId = "template";
            }
          }
        }
      };
      function parse3(sfc) {
        var _a;
        const data = /* @__PURE__ */ new Map();
        if (!((_a = sfc.template) == null ? void 0 : _a.ast)) {
          return data;
        }
        const templateContent = sfc.template.content;
        let i = 0;
        sfc.template.ast.children.forEach(visit2);
        return data;
        function visit2(node2) {
          var _a2, _b, _c, _d, _e, _f;
          if (node2.type === CompilerDOM.NodeTypes.ELEMENT) {
            for (const prop of node2.props) {
              if (prop.type !== CompilerDOM.NodeTypes.DIRECTIVE) {
                continue;
              }
              const isShorthand = ((_a2 = prop.arg) == null ? void 0 : _a2.loc.start.offset) === ((_b = prop.exp) == null ? void 0 : _b.loc.start.offset);
              if (isShorthand) {
                continue;
              }
              if (((_c = prop.arg) == null ? void 0 : _c.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && !prop.arg.isStatic) {
                addFormatCodes(prop.arg.content, prop.arg.loc.start.offset, formatBrackets.normal);
              }
              if (((_d = prop.exp) == null ? void 0 : _d.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && prop.exp.constType !== CompilerDOM.ConstantTypes.CAN_STRINGIFY) {
                if (prop.name === "on" && ((_e = prop.arg) == null ? void 0 : _e.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
                  const ast = (0, common_1.createTsAst)(ctx.modules.typescript, prop.exp, prop.exp.content);
                  addFormatCodes(prop.exp.content, prop.exp.loc.start.offset, (0, elementEvents_1.isCompoundExpression)(ctx.modules.typescript, ast) ? formatBrackets.event : formatBrackets.normal);
                } else {
                  addFormatCodes(prop.exp.content, prop.exp.loc.start.offset, formatBrackets.normal);
                }
              }
            }
            for (const child of node2.children) {
              visit2(child);
            }
          } else if (node2.type === CompilerDOM.NodeTypes.IF) {
            for (let i2 = 0; i2 < node2.branches.length; i2++) {
              const branch = node2.branches[i2];
              if (((_f = branch.condition) == null ? void 0 : _f.type) === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
                addFormatCodes(branch.condition.content, branch.condition.loc.start.offset, formatBrackets.if);
              }
              for (const childNode of branch.children) {
                visit2(childNode);
              }
            }
          } else if (node2.type === CompilerDOM.NodeTypes.FOR) {
            const { leftExpressionRange, leftExpressionText } = (0, vFor_1.parseVForNode)(node2);
            const { source } = node2.parseResult;
            if (leftExpressionRange && leftExpressionText && source.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
              const start = leftExpressionRange.start;
              const end = source.loc.start.offset + source.content.length;
              addFormatCodes(templateContent.substring(start, end), start, formatBrackets.for);
            }
            for (const child of node2.children) {
              visit2(child);
            }
          } else if (node2.type === CompilerDOM.NodeTypes.TEXT_CALL) {
            visit2(node2.content);
          } else if (node2.type === CompilerDOM.NodeTypes.COMPOUND_EXPRESSION) {
            for (const childNode of node2.children) {
              if (typeof childNode === "object") {
                visit2(childNode);
              }
            }
          } else if (node2.type === CompilerDOM.NodeTypes.INTERPOLATION) {
            const [content3, start] = (0, templateChild_1.parseInterpolationNode)(node2, templateContent);
            const lines = content3.split("\n");
            addFormatCodes(content3, start, lines.length <= 1 ? formatBrackets.curly : [
              lines[0].trim() === "" ? "(" : formatBrackets.curly[0],
              lines[lines.length - 1].trim() === "" ? ");" : formatBrackets.curly[1]
            ]);
          }
        }
        function addFormatCodes(code3, offset, wrapper) {
          const id = "template_inline_ts_" + i++;
          data.set(id, [
            wrapper[0],
            [
              code3,
              "template",
              offset,
              codeFeatures
            ],
            wrapper[1]
          ]);
        }
      }
    };
    exports.default = plugin;
  }
});

// node_modules/alien-signals/cjs/system.js
var require_system = __commonJS({
  "node_modules/alien-signals/cjs/system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Subscriber = exports.Dependency = exports.Link = exports.System = void 0;
    exports.startBatch = startBatch;
    exports.endBatch = endBatch;
    var System;
    (function(System2) {
      System2.activeSub = void 0;
      System2.activeTrackId = 0;
      System2.batchDepth = 0;
      System2.lastTrackId = 0;
      System2.queuedEffects = void 0;
      System2.queuedEffectsTail = void 0;
    })(System || (exports.System = System = {}));
    function startBatch() {
      System.batchDepth++;
    }
    function endBatch() {
      System.batchDepth--;
      if (System.batchDepth === 0) {
        while (System.queuedEffects !== void 0) {
          const effect = System.queuedEffects;
          const queuedNext = System.queuedEffects.nextNotify;
          if (queuedNext !== void 0) {
            System.queuedEffects.nextNotify = void 0;
            System.queuedEffects = queuedNext;
          } else {
            System.queuedEffects = void 0;
            System.queuedEffectsTail = void 0;
          }
          effect.notify();
        }
      }
    }
    var Link;
    (function(Link2) {
      let pool = void 0;
      function get2(dep, sub, nextDep) {
        if (pool !== void 0) {
          const newLink = pool;
          pool = newLink.nextDep;
          newLink.nextDep = nextDep;
          newLink.dep = dep;
          newLink.sub = sub;
          newLink.trackId = sub.trackId;
          return newLink;
        } else {
          return {
            dep,
            sub,
            trackId: sub.trackId,
            nextDep,
            prevSub: void 0,
            nextSub: void 0
          };
        }
      }
      Link2.get = get2;
      function release(link3) {
        const dep = link3.dep;
        const nextSub = link3.nextSub;
        const prevSub = link3.prevSub;
        if (nextSub !== void 0) {
          nextSub.prevSub = prevSub;
        }
        if (prevSub !== void 0) {
          prevSub.nextSub = nextSub;
        }
        if (nextSub === void 0) {
          dep.subsTail = prevSub;
        }
        if (prevSub === void 0) {
          dep.subs = nextSub;
        }
        link3.dep = void 0;
        link3.sub = void 0;
        link3.prevSub = void 0;
        link3.nextSub = void 0;
        link3.nextDep = pool;
        pool = link3;
      }
      Link2.release = release;
    })(Link || (exports.Link = Link = {}));
    var Dependency;
    (function(Dependency2) {
      const system = System;
      function linkSubscriber(dep, sub) {
        return link3(dep, sub);
      }
      Dependency2.linkSubscriber = linkSubscriber;
      function link3(dep, sub) {
        const depsTail = sub.depsTail;
        const old = depsTail !== void 0 ? depsTail.nextDep : sub.deps;
        if (old === void 0 || old.dep !== dep) {
          const newLink = Link.get(dep, sub, old);
          if (depsTail === void 0) {
            sub.deps = newLink;
          } else {
            depsTail.nextDep = newLink;
          }
          if (dep.subs === void 0) {
            dep.subs = newLink;
          } else {
            const oldTail = dep.subsTail;
            newLink.prevSub = oldTail;
            oldTail.nextSub = newLink;
          }
          sub.depsTail = newLink;
          dep.subsTail = newLink;
        } else {
          old.trackId = sub.trackId;
          sub.depsTail = old;
        }
      }
      Dependency2.link = link3;
      function propagate(subs) {
        let link4 = subs;
        let dep = subs.dep;
        let dirtyLevel = 3;
        let remainingQuantity = 0;
        do {
          if (link4 !== void 0) {
            const sub = link4.sub;
            const subTrackId = sub.trackId;
            if (subTrackId > 0) {
              if (subTrackId === link4.trackId) {
                const subDirtyLevel = sub.dirtyLevel;
                if (subDirtyLevel < dirtyLevel) {
                  sub.dirtyLevel = dirtyLevel;
                  if (subDirtyLevel === 0) {
                    sub.canPropagate = true;
                    if ("subs" in sub && sub.subs !== void 0) {
                      sub.depsTail.nextDep = link4;
                      dep = sub;
                      link4 = sub.subs;
                      if ("notify" in sub) {
                        dirtyLevel = 1;
                      } else {
                        dirtyLevel = 2;
                      }
                      remainingQuantity++;
                      continue;
                    }
                  }
                }
              }
            } else if (subTrackId === -link4.trackId) {
              const subDirtyLevel = sub.dirtyLevel;
              const notDirty = subDirtyLevel === 0;
              if (subDirtyLevel < dirtyLevel) {
                sub.dirtyLevel = dirtyLevel;
              }
              if (notDirty || sub.canPropagate) {
                if (!notDirty) {
                  sub.canPropagate = false;
                }
                if ("subs" in sub && sub.subs !== void 0) {
                  sub.depsTail.nextDep = link4;
                  dep = sub;
                  link4 = sub.subs;
                  if ("notify" in sub) {
                    dirtyLevel = 1;
                  } else {
                    dirtyLevel = 2;
                  }
                  remainingQuantity++;
                  continue;
                } else if ("notify" in sub) {
                  const queuedEffectsTail = system.queuedEffectsTail;
                  if (queuedEffectsTail !== void 0) {
                    queuedEffectsTail.nextNotify = sub;
                  } else {
                    system.queuedEffects = sub;
                  }
                  system.queuedEffectsTail = sub;
                }
              }
            }
            link4 = link4.nextSub;
            continue;
          }
          if (remainingQuantity !== 0) {
            const depsTail = dep.depsTail;
            const prevLink = depsTail.nextDep;
            const prevSub = prevLink.sub;
            depsTail.nextDep = void 0;
            dep = prevLink.dep;
            link4 = prevLink.nextSub;
            remainingQuantity--;
            if (remainingQuantity === 0) {
              dirtyLevel = 3;
            } else if ("notify" in dep) {
              dirtyLevel = 1;
            } else {
              dirtyLevel = 2;
            }
            if ("notify" in prevSub) {
              const queuedEffectsTail = system.queuedEffectsTail;
              if (queuedEffectsTail !== void 0) {
                queuedEffectsTail.nextNotify = prevSub;
              } else {
                system.queuedEffects = prevSub;
              }
              system.queuedEffectsTail = prevSub;
            }
            continue;
          }
          break;
        } while (true);
      }
      Dependency2.propagate = propagate;
    })(Dependency || (exports.Dependency = Dependency = {}));
    var Subscriber;
    (function(Subscriber2) {
      const system = System;
      function resolveMaybeDirty(sub, depth = 0) {
        let link3 = sub.deps;
        while (link3 !== void 0) {
          const dep = link3.dep;
          if ("update" in dep) {
            let dirtyLevel = dep.dirtyLevel;
            if (dirtyLevel === 2) {
              if (depth >= 4) {
                resolveMaybeDirtyNonRecursive(dep);
              } else {
                resolveMaybeDirty(dep, depth + 1);
              }
              dirtyLevel = dep.dirtyLevel;
            }
            if (dirtyLevel === 3) {
              dep.update();
              if (sub.dirtyLevel === 3) {
                break;
              }
            }
          }
          link3 = link3.nextDep;
        }
        if (sub.dirtyLevel === 2) {
          sub.dirtyLevel = 0;
        }
      }
      Subscriber2.resolveMaybeDirty = resolveMaybeDirty;
      function resolveMaybeDirtyNonRecursive(sub) {
        let link3 = sub.deps;
        let remaining = 0;
        do {
          if (link3 !== void 0) {
            const dep = link3.dep;
            if ("update" in dep) {
              const depDirtyLevel = dep.dirtyLevel;
              if (depDirtyLevel === 2) {
                dep.subs.prevSub = link3;
                sub = dep;
                link3 = dep.deps;
                remaining++;
                continue;
              } else if (depDirtyLevel === 3) {
                dep.update();
                if (sub.dirtyLevel === 3) {
                  if (remaining !== 0) {
                    const subSubs = sub.subs;
                    const prevLink = subSubs.prevSub;
                    sub.update();
                    subSubs.prevSub = void 0;
                    sub = prevLink.sub;
                    link3 = prevLink.nextDep;
                    remaining--;
                    continue;
                  }
                  break;
                }
              }
            }
            link3 = link3.nextDep;
            continue;
          }
          const dirtyLevel = sub.dirtyLevel;
          if (dirtyLevel === 2) {
            sub.dirtyLevel = 0;
            if (remaining !== 0) {
              const subSubs = sub.subs;
              const prevLink = subSubs.prevSub;
              subSubs.prevSub = void 0;
              sub = prevLink.sub;
              link3 = prevLink.nextDep;
              remaining--;
              continue;
            }
          } else if (remaining !== 0) {
            if (dirtyLevel === 3) {
              sub.update();
            }
            const subSubs = sub.subs;
            const prevLink = subSubs.prevSub;
            subSubs.prevSub = void 0;
            sub = prevLink.sub;
            link3 = prevLink.nextDep;
            remaining--;
            continue;
          }
          break;
        } while (true);
      }
      Subscriber2.resolveMaybeDirtyNonRecursive = resolveMaybeDirtyNonRecursive;
      function startTrackDependencies(sub) {
        return startTrack(sub);
      }
      Subscriber2.startTrackDependencies = startTrackDependencies;
      function endTrackDependencies(sub, prevSub) {
        return endTrack(sub, prevSub);
      }
      Subscriber2.endTrackDependencies = endTrackDependencies;
      function startTrack(sub) {
        const newTrackId = system.lastTrackId + 1;
        const prevSub = system.activeSub;
        system.activeSub = sub;
        system.activeTrackId = newTrackId;
        system.lastTrackId = newTrackId;
        sub.depsTail = void 0;
        sub.trackId = newTrackId;
        sub.dirtyLevel = 0;
        return prevSub;
      }
      Subscriber2.startTrack = startTrack;
      function endTrack(sub, prevSub) {
        if (prevSub !== void 0) {
          system.activeSub = prevSub;
          system.activeTrackId = prevSub.trackId;
        } else {
          system.activeSub = void 0;
          system.activeTrackId = 0;
        }
        const depsTail = sub.depsTail;
        if (depsTail !== void 0) {
          if (depsTail.nextDep !== void 0) {
            clearTrack(depsTail.nextDep);
            depsTail.nextDep = void 0;
          }
        } else if (sub.deps !== void 0) {
          clearTrack(sub.deps);
          sub.deps = void 0;
        }
        sub.trackId = -sub.trackId;
      }
      Subscriber2.endTrack = endTrack;
      function clearTrack(link3) {
        do {
          const dep = link3.dep;
          const nextDep = link3.nextDep;
          Link.release(link3);
          if (dep.subs === void 0 && "deps" in dep) {
            if ("notify" in dep) {
              dep.dirtyLevel = 0;
            } else {
              dep.dirtyLevel = 3;
            }
            if (dep.deps !== void 0) {
              link3 = dep.deps;
              dep.depsTail.nextDep = nextDep;
              dep.deps = void 0;
              dep.depsTail = void 0;
              continue;
            }
          }
          link3 = nextDep;
        } while (link3 !== void 0);
      }
      Subscriber2.clearTrack = clearTrack;
    })(Subscriber || (exports.Subscriber = Subscriber = {}));
  }
});

// node_modules/alien-signals/cjs/computed.js
var require_computed = __commonJS({
  "node_modules/alien-signals/cjs/computed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Computed = void 0;
    exports.computed = computed;
    var system_js_1 = require_system();
    function computed(getter) {
      return new Computed(getter);
    }
    var Computed = class {
      constructor(getter) {
        this.getter = getter;
        this.cachedValue = void 0;
        this.subs = void 0;
        this.subsTail = void 0;
        this.deps = void 0;
        this.depsTail = void 0;
        this.trackId = 0;
        this.dirtyLevel = 3;
        this.canPropagate = false;
      }
      get() {
        let dirtyLevel = this.dirtyLevel;
        if (dirtyLevel === 2) {
          system_js_1.Subscriber.resolveMaybeDirty(this);
          dirtyLevel = this.dirtyLevel;
        }
        if (dirtyLevel >= 3) {
          this.update();
        }
        const activeTrackId = system_js_1.System.activeTrackId;
        if (activeTrackId !== 0) {
          const subsTail = this.subsTail;
          if (subsTail === void 0 || subsTail.trackId !== activeTrackId) {
            system_js_1.Dependency.link(this, system_js_1.System.activeSub);
          }
        }
        return this.cachedValue;
      }
      update() {
        const prevSub = system_js_1.Subscriber.startTrack(this);
        const oldValue = this.cachedValue;
        let newValue;
        try {
          newValue = this.getter(oldValue);
        } finally {
          system_js_1.Subscriber.endTrack(this, prevSub);
        }
        if (oldValue !== newValue) {
          this.cachedValue = newValue;
          const subs = this.subs;
          if (subs !== void 0) {
            system_js_1.Dependency.propagate(subs);
          }
        }
      }
    };
    exports.Computed = Computed;
  }
});

// node_modules/alien-signals/cjs/effectScope.js
var require_effectScope = __commonJS({
  "node_modules/alien-signals/cjs/effectScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EffectScope = exports.activeEffectScope = void 0;
    exports.effectScope = effectScope;
    var system_js_1 = require_system();
    exports.activeEffectScope = void 0;
    function effectScope() {
      return new EffectScope();
    }
    var EffectScope = class {
      constructor() {
        this.deps = void 0;
        this.depsTail = void 0;
        this.trackId = -++system_js_1.System.lastTrackId;
        this.dirtyLevel = 0;
        this.canPropagate = false;
      }
      notify() {
        if (this.dirtyLevel !== 0) {
          this.dirtyLevel = 0;
          let link3 = this.deps;
          while (link3 !== void 0) {
            const dep = link3.dep;
            if ("notify" in dep) {
              dep.notify();
            }
            link3 = link3.nextDep;
          }
        }
      }
      run(fn) {
        const prevSub = exports.activeEffectScope;
        exports.activeEffectScope = this;
        this.trackId = Math.abs(this.trackId);
        try {
          return fn();
        } finally {
          exports.activeEffectScope = prevSub;
          this.trackId = -Math.abs(this.trackId);
        }
      }
      stop() {
        if (this.deps !== void 0) {
          system_js_1.Subscriber.clearTrack(this.deps);
          this.deps = void 0;
          this.depsTail = void 0;
        }
        this.dirtyLevel = 0;
      }
    };
    exports.EffectScope = EffectScope;
  }
});

// node_modules/alien-signals/cjs/effect.js
var require_effect = __commonJS({
  "node_modules/alien-signals/cjs/effect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Effect = void 0;
    exports.effect = effect;
    var effectScope_js_1 = require_effectScope();
    var system_js_1 = require_system();
    function effect(fn) {
      const e = new Effect(fn);
      e.run();
      return e;
    }
    var Effect = class {
      constructor(fn) {
        this.fn = fn;
        this.nextNotify = void 0;
        this.subs = void 0;
        this.subsTail = void 0;
        this.deps = void 0;
        this.depsTail = void 0;
        this.trackId = 0;
        this.dirtyLevel = 3;
        this.canPropagate = false;
        const activeTrackId = system_js_1.System.activeTrackId;
        if (activeTrackId !== 0) {
          system_js_1.Dependency.link(this, system_js_1.System.activeSub);
          return;
        }
        if (effectScope_js_1.activeEffectScope !== void 0) {
          const subsTail = this.subsTail;
          if (subsTail === void 0 || subsTail.trackId !== effectScope_js_1.activeEffectScope.trackId) {
            system_js_1.Dependency.link(this, effectScope_js_1.activeEffectScope);
          }
        }
      }
      notify() {
        let dirtyLevel = this.dirtyLevel;
        if (dirtyLevel > 0) {
          if (dirtyLevel === 2) {
            system_js_1.Subscriber.resolveMaybeDirty(this);
            dirtyLevel = this.dirtyLevel;
          }
          if (dirtyLevel === 3) {
            this.run();
          } else {
            this.dirtyLevel = 0;
            let link3 = this.deps;
            while (link3 !== void 0) {
              const dep = link3.dep;
              if ("notify" in dep) {
                dep.notify();
              }
              link3 = link3.nextDep;
            }
          }
        }
      }
      run() {
        const prevSub = system_js_1.Subscriber.startTrack(this);
        try {
          return this.fn();
        } finally {
          system_js_1.Subscriber.endTrack(this, prevSub);
        }
      }
      stop() {
        if (this.deps !== void 0) {
          system_js_1.Subscriber.clearTrack(this.deps);
          this.deps = void 0;
          this.depsTail = void 0;
        }
        this.dirtyLevel = 3;
      }
    };
    exports.Effect = Effect;
  }
});

// node_modules/alien-signals/cjs/signal.js
var require_signal = __commonJS({
  "node_modules/alien-signals/cjs/signal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Signal = void 0;
    exports.signal = signal;
    var system_js_1 = require_system();
    function signal(oldValue) {
      return new Signal(oldValue);
    }
    var Signal = class {
      constructor(currentValue) {
        this.currentValue = currentValue;
        this.subs = void 0;
        this.subsTail = void 0;
      }
      get() {
        const activeTrackId = system_js_1.System.activeTrackId;
        if (activeTrackId !== 0) {
          const subsTail = this.subsTail;
          if (subsTail === void 0 || subsTail.trackId !== activeTrackId) {
            system_js_1.Dependency.link(this, system_js_1.System.activeSub);
          }
        }
        return this.currentValue;
      }
      set(value) {
        if (this.currentValue !== (this.currentValue = value)) {
          const subs = this.subs;
          if (subs !== void 0) {
            (0, system_js_1.startBatch)();
            system_js_1.Dependency.propagate(subs);
            (0, system_js_1.endBatch)();
          }
        }
      }
    };
    exports.Signal = Signal;
  }
});

// node_modules/alien-signals/cjs/unstable/computedArray.js
var require_computedArray = __commonJS({
  "node_modules/alien-signals/cjs/unstable/computedArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computedArray = computedArray;
    var index_js_1 = require_cjs();
    function computedArray(arr, getGetter) {
      const length = (0, index_js_1.computed)(() => arr.get().length);
      const keys2 = (0, index_js_1.computed)(() => {
        const keys3 = [];
        for (let i = 0; i < length.get(); i++) {
          keys3.push(String(i));
        }
        return keys3;
      });
      const items = (0, index_js_1.computed)((array) => {
        array ?? (array = []);
        while (array.length < length.get()) {
          const index2 = array.length;
          const item = (0, index_js_1.computed)(() => arr.get()[index2]);
          array.push((0, index_js_1.computed)(getGetter(item, index2)));
        }
        if (array.length > length.get()) {
          array.length = length.get();
        }
        return array;
      });
      return new Proxy({}, {
        get(_, p2, receiver) {
          var _a;
          if (p2 === "length") {
            return length.get();
          }
          if (typeof p2 === "string" && !isNaN(Number(p2))) {
            return (_a = items.get()[Number(p2)]) == null ? void 0 : _a.get();
          }
          return Reflect.get(items.get(), p2, receiver);
        },
        has(_, p2) {
          return Reflect.has(items.get(), p2);
        },
        ownKeys() {
          return keys2.get();
        }
      });
    }
  }
});

// node_modules/alien-signals/cjs/unstable/computedSet.js
var require_computedSet = __commonJS({
  "node_modules/alien-signals/cjs/unstable/computedSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computedSet = computedSet;
    var index_js_1 = require_cjs();
    function computedSet(source) {
      return (0, index_js_1.computed)((oldValue) => {
        const newValue = source.get();
        if ((oldValue == null ? void 0 : oldValue.size) === newValue.size && [...oldValue].every((c) => newValue.has(c))) {
          return oldValue;
        }
        return newValue;
      });
    }
  }
});

// node_modules/alien-signals/cjs/unstable/equalityComputed.js
var require_equalityComputed = __commonJS({
  "node_modules/alien-signals/cjs/unstable/equalityComputed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EqualityComputed = void 0;
    exports.equalityComputed = equalityComputed;
    var index_js_1 = require_cjs();
    function equalityComputed(getter) {
      return new EqualityComputed(getter);
    }
    var EqualityComputed = class extends index_js_1.Computed {
      constructor(getter) {
        super((oldValue) => {
          const newValue = getter();
          if (this.equals(oldValue, newValue)) {
            return oldValue;
          }
          return newValue;
        });
      }
      equals(a, b) {
        if (a === b) {
          return true;
        }
        if (a === null || b === null || typeof a !== typeof b) {
          return false;
        }
        if (typeof a === "object") {
          if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length !== b.length) {
              return false;
            }
            for (let i = 0; i < a.length; i++) {
              if (!this.equals(a[i], b[i])) {
                return false;
              }
            }
            return true;
          }
          if (!Array.isArray(a) && !Array.isArray(b)) {
            for (const key2 in a) {
              if (a.hasOwnProperty(key2)) {
                if (!b.hasOwnProperty(key2) || !this.equals(a[key2], b[key2])) {
                  return false;
                }
              }
            }
            for (const key2 in b) {
              if (b.hasOwnProperty(key2) && !a.hasOwnProperty(key2)) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        return false;
      }
    };
    exports.EqualityComputed = EqualityComputed;
  }
});

// node_modules/alien-signals/cjs/unstable/index.js
var require_unstable = __commonJS({
  "node_modules/alien-signals/cjs/unstable/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_computedArray(), exports);
    __exportStar(require_computedSet(), exports);
    __exportStar(require_equalityComputed(), exports);
  }
});

// node_modules/alien-signals/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/alien-signals/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Unstable = void 0;
    __exportStar(require_computed(), exports);
    __exportStar(require_effect(), exports);
    __exportStar(require_effectScope(), exports);
    __exportStar(require_signal(), exports);
    __exportStar(require_system(), exports);
    exports.Unstable = require_unstable();
  }
});

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports, module2) {
    "use strict";
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code3;
      for (var i = 0; i <= path.length; ++i) {
        if (i < path.length)
          code3 = path.charCodeAt(i);
        else if (code3 === 47)
          break;
        else
          code3 = 47;
        if (code3 === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i);
            else
              res = path.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code3 === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd2;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path;
          if (i >= 0)
            path = arguments[i];
          else {
            if (cwd2 === void 0)
              cwd2 = process.cwd();
            path = cwd2;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize2(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var isAbsolute = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute) path = ".";
        if (path.length > 0 && trailingSeparator) path += "/";
        if (isAbsolute) return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join2() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var code3 = path.charCodeAt(0);
        var hasRoot = code3 === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path.length - 1; i >= 1; --i) {
          code3 = path.charCodeAt(i);
          if (code3 === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path.slice(0, end);
      },
      basename: function basename(path, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            var code3 = path.charCodeAt(i);
            if (code3 === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code3 === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path.length;
          return path.slice(start, end);
        } else {
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) return "";
          return path.slice(start, end);
        }
      },
      extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path.length - 1; i >= 0; --i) {
          var code3 = path.charCodeAt(i);
          if (code3 === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code3 === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse3(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0) return ret;
        var code3 = path.charCodeAt(0);
        var isAbsolute = code3 === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code3 = path.charCodeAt(i);
          if (code3 === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code3 === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
            else ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module2.exports = posix;
  }
});

// node_modules/@vue/language-core/lib/codegen/script/component.js
var require_component = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/script/component.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateComponent = generateComponent;
    exports.generateComponentSetupReturns = generateComponentSetupReturns;
    exports.generateEmitsOption = generateEmitsOption;
    exports.generatePropsOption = generatePropsOption;
    var common_1 = require_common();
    var index_1 = require_script();
    function* generateComponent(options, ctx, scriptSetup, scriptSetupRanges) {
      var _a, _b, _c, _d;
      if (options.sfc.script && ((_a = options.scriptRanges) == null ? void 0 : _a.exportDefault) && options.scriptRanges.exportDefault.expression.start !== options.scriptRanges.exportDefault.args.start) {
        yield (0, common_1.generateSfcBlockSection)(options.sfc.script, options.scriptRanges.exportDefault.expression.start, options.scriptRanges.exportDefault.args.start, index_1.codeFeatures.all);
        yield `{${common_1.newLine}`;
      } else {
        yield `(await import('${options.vueCompilerOptions.lib}')).defineComponent({${common_1.newLine}`;
      }
      yield `setup() {${common_1.newLine}`;
      yield `return {${common_1.newLine}`;
      if (ctx.bypassDefineComponent) {
        yield* generateComponentSetupReturns(scriptSetupRanges);
      }
      if (scriptSetupRanges.expose.define) {
        yield `...__VLS_exposed,${common_1.newLine}`;
      }
      yield `}${common_1.endOfLine}`;
      yield `},${common_1.newLine}`;
      if (!ctx.bypassDefineComponent) {
        const emitOptionCodes = [...generateEmitsOption(options, scriptSetupRanges)];
        for (const code3 of emitOptionCodes) {
          yield code3;
        }
        yield* generatePropsOption(options, ctx, scriptSetup, scriptSetupRanges, !!emitOptionCodes.length, true);
      }
      if (options.sfc.script && ((_c = (_b = options.scriptRanges) == null ? void 0 : _b.exportDefault) == null ? void 0 : _c.args)) {
        const { args } = options.scriptRanges.exportDefault;
        yield (0, common_1.generateSfcBlockSection)(options.sfc.script, args.start + 1, args.end - 1, index_1.codeFeatures.all);
      }
      if (options.vueCompilerOptions.target >= 3.5 && scriptSetupRanges.templateRefs.length) {
        yield `__typeRefs: {} as __VLS_TemplateResult['refs'],${common_1.newLine}`;
      }
      if (options.vueCompilerOptions.target >= 3.5 && ((_d = options.templateCodegen) == null ? void 0 : _d.singleRootElType)) {
        yield `__typeEl: {} as __VLS_TemplateResult['rootEl'],${common_1.newLine}`;
      }
      yield `})`;
    }
    function* generateComponentSetupReturns(scriptSetupRanges) {
      if (scriptSetupRanges.props.define) {
        yield `$props: __VLS_makeOptional(${scriptSetupRanges.props.name ?? `__VLS_props`}),${common_1.newLine}`;
        yield `...${scriptSetupRanges.props.name ?? `__VLS_props`},${common_1.newLine}`;
      }
      if (scriptSetupRanges.emits.define) {
        yield `$emit: ${scriptSetupRanges.emits.name ?? "__VLS_emit"},${common_1.newLine}`;
      }
    }
    function* generateEmitsOption(options, scriptSetupRanges) {
      const codes2 = [];
      if (scriptSetupRanges.defineProp.some((p2) => p2.isModel)) {
        codes2.push({
          optionExp: `{} as __VLS_NormalizeEmits<typeof __VLS_modelEmit>`,
          typeOptionType: `__VLS_ModelEmit`
        });
      }
      if (scriptSetupRanges.emits.define) {
        const { typeArg, hasUnionTypeArg } = scriptSetupRanges.emits.define;
        codes2.push({
          optionExp: `{} as __VLS_NormalizeEmits<typeof ${scriptSetupRanges.emits.name ?? "__VLS_emit"}>`,
          typeOptionType: typeArg && !hasUnionTypeArg ? `__VLS_Emit` : void 0
        });
      }
      if (options.vueCompilerOptions.target >= 3.5 && codes2.every((code3) => code3.typeOptionType)) {
        if (codes2.length === 1) {
          yield `__typeEmits: {} as `;
          yield codes2[0].typeOptionType;
          yield `,${common_1.newLine}`;
        } else if (codes2.length >= 2) {
          yield `__typeEmits: {} as `;
          yield codes2[0].typeOptionType;
          for (let i = 1; i < codes2.length; i++) {
            yield ` & `;
            yield codes2[i].typeOptionType;
          }
          yield `,${common_1.newLine}`;
        }
      } else if (codes2.every((code3) => code3.optionExp)) {
        if (codes2.length === 1) {
          yield `emits: `;
          yield codes2[0].optionExp;
          yield `,${common_1.newLine}`;
        } else if (codes2.length >= 2) {
          yield `emits: {${common_1.newLine}`;
          for (const code3 of codes2) {
            yield `...`;
            yield code3.optionExp;
            yield `,${common_1.newLine}`;
          }
          yield `},${common_1.newLine}`;
        }
      }
    }
    function* generatePropsOption(options, ctx, scriptSetup, scriptSetupRanges, hasEmitsOption, inheritAttrs) {
      var _a, _b, _c, _d;
      const codes2 = [];
      if (ctx.generatedPropsType) {
        codes2.push({
          optionExp: [
            `{} as `,
            ((_a = scriptSetupRanges.props.withDefaults) == null ? void 0 : _a.arg) ? `${ctx.localTypes.WithDefaults}<` : "",
            `${ctx.localTypes.TypePropsToOption}<__VLS_PublicProps>`,
            ((_b = scriptSetupRanges.props.withDefaults) == null ? void 0 : _b.arg) ? `, typeof __VLS_withDefaultsArg>` : ""
          ].join(""),
          typeOptionExp: `{} as __VLS_PublicProps`
        });
      }
      if ((_c = scriptSetupRanges.props.define) == null ? void 0 : _c.arg) {
        const { arg } = scriptSetupRanges.props.define;
        codes2.push({
          optionExp: (0, common_1.generateSfcBlockSection)(scriptSetup, arg.start, arg.end, index_1.codeFeatures.navigation),
          typeOptionExp: void 0
        });
      }
      if (inheritAttrs && ((_d = options.templateCodegen) == null ? void 0 : _d.inheritedAttrVars.size)) {
        let attrsType = `__VLS_TemplateResult['attrs']`;
        if (hasEmitsOption) {
          attrsType = `Omit<${attrsType}, \`on\${string}\`>`;
        }
        const propsType = `__VLS_PickNotAny<${ctx.localTypes.OmitIndexSignature}<${attrsType}>, {}>`;
        const optionType = `${ctx.localTypes.TypePropsToOption}<${propsType}>`;
        codes2.unshift({
          optionExp: codes2.length ? `{} as ${optionType}` : `{} as keyof ${propsType} extends never ? never: ${optionType}`,
          typeOptionExp: `{} as ${attrsType}`
        });
      }
      const useTypeOption = options.vueCompilerOptions.target >= 3.5 && codes2.every((code3) => code3.typeOptionExp);
      const useOption = !useTypeOption || scriptSetupRanges.props.withDefaults;
      if (useTypeOption) {
        if (codes2.length === 1) {
          yield `__typeProps: `;
          yield codes2[0].typeOptionExp;
          yield `,${common_1.newLine}`;
        } else if (codes2.length >= 2) {
          yield `__typeProps: {${common_1.newLine}`;
          for (const { typeOptionExp } of codes2) {
            yield `...`;
            yield typeOptionExp;
            yield `,${common_1.newLine}`;
          }
          yield `},${common_1.newLine}`;
        }
      }
      if (useOption) {
        if (codes2.length === 1) {
          yield `props: `;
          yield codes2[0].optionExp;
          yield `,${common_1.newLine}`;
        } else if (codes2.length >= 2) {
          yield `props: {${common_1.newLine}`;
          for (const { optionExp } of codes2) {
            yield `...`;
            yield optionExp;
            yield `,${common_1.newLine}`;
          }
          yield `},${common_1.newLine}`;
        }
      }
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/script/template.js
var require_template2 = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/script/template.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateTemplateDirectives = generateTemplateDirectives;
    exports.generateTemplate = generateTemplate;
    exports.generateCssClassProperty = generateCssClassProperty;
    exports.getTemplateUsageVars = getTemplateUsageVars;
    var path = require_path_browserify();
    var shared_1 = require_shared();
    var common_1 = require_common();
    var context_1 = require_context();
    var interpolation_1 = require_interpolation();
    var styleScopedClasses_1 = require_styleScopedClasses();
    var index_1 = require_script();
    function* generateTemplateCtx(options) {
      const exps = [];
      exps.push(`{} as InstanceType<__VLS_PickNotAny<typeof __VLS_self, new () => {}>>`);
      if (options.vueCompilerOptions.petiteVueExtensions.some((ext) => options.fileName.endsWith(ext))) {
        exps.push(`globalThis`);
      }
      if (options.sfc.styles.some((style) => style.module)) {
        exps.push(`{} as __VLS_StyleModules`);
      }
      yield `const __VLS_ctx = `;
      if (exps.length === 1) {
        yield exps[0];
        yield `${common_1.endOfLine}`;
      } else {
        yield `{${common_1.newLine}`;
        for (const exp of exps) {
          yield `...`;
          yield exp;
          yield `,${common_1.newLine}`;
        }
        yield `}${common_1.endOfLine}`;
      }
    }
    function* generateTemplateComponents(options) {
      var _a, _b, _c, _d, _e, _f, _g;
      const exps = [];
      if (options.sfc.script && ((_b = (_a = options.scriptRanges) == null ? void 0 : _a.exportDefault) == null ? void 0 : _b.componentsOption)) {
        const { componentsOption } = options.scriptRanges.exportDefault;
        exps.push([
          options.sfc.script.content.substring(componentsOption.start, componentsOption.end),
          "script",
          componentsOption.start,
          index_1.codeFeatures.navigation
        ]);
      }
      let nameType;
      if (options.sfc.script && ((_d = (_c = options.scriptRanges) == null ? void 0 : _c.exportDefault) == null ? void 0 : _d.nameOption)) {
        const { nameOption } = options.scriptRanges.exportDefault;
        nameType = options.sfc.script.content.substring(nameOption.start, nameOption.end);
      } else if (options.sfc.scriptSetup) {
        const baseName = path.basename(options.fileName);
        nameType = `'${((_e = options.scriptSetupRanges) == null ? void 0 : _e.options.name) ?? baseName.substring(0, baseName.lastIndexOf("."))}'`;
      }
      if (nameType) {
        exps.push(`{} as {
			[K in ${nameType}]: typeof __VLS_self
				& (new () => {
					${(0, shared_1.getSlotsPropertyName)(options.vueCompilerOptions.target)}: typeof ${((_g = (_f = options.scriptSetupRanges) == null ? void 0 : _f.slots) == null ? void 0 : _g.name) ?? "__VLS_slots"}
				})
		}`);
      }
      exps.push(`{} as NonNullable<typeof __VLS_self extends { components: infer C } ? C : {}>`);
      exps.push(`__VLS_ctx`);
      yield `const __VLS_localComponents = {${common_1.newLine}`;
      for (const type of exps) {
        yield `...`;
        yield type;
        yield `,${common_1.newLine}`;
      }
      yield `}${common_1.endOfLine}`;
      yield `let __VLS_components!: typeof __VLS_localComponents & __VLS_GlobalComponents${common_1.endOfLine}`;
    }
    function* generateTemplateDirectives(options) {
      var _a, _b;
      const exps = [];
      if (options.sfc.script && ((_b = (_a = options.scriptRanges) == null ? void 0 : _a.exportDefault) == null ? void 0 : _b.directivesOption)) {
        const { directivesOption } = options.scriptRanges.exportDefault;
        exps.push([
          options.sfc.script.content.substring(directivesOption.start, directivesOption.end),
          "script",
          directivesOption.start,
          index_1.codeFeatures.navigation
        ]);
      }
      exps.push(`{} as NonNullable<typeof __VLS_self extends { directives: infer D } ? D : {}>`);
      exps.push(`__VLS_ctx`);
      yield `const __VLS_localDirectives = {${common_1.newLine}`;
      for (const type of exps) {
        yield `...`;
        yield type;
        yield `,${common_1.newLine}`;
      }
      yield `}${common_1.endOfLine}`;
      yield `let __VLS_directives!: typeof __VLS_localDirectives & __VLS_GlobalDirectives${common_1.endOfLine}`;
    }
    function* generateTemplate(options, ctx) {
      ctx.generatedTemplate = true;
      const templateCodegenCtx = (0, context_1.createTemplateCodegenContext)({
        scriptSetupBindingNames: /* @__PURE__ */ new Set(),
        edited: options.edited
      });
      yield* generateTemplateCtx(options);
      yield* generateTemplateComponents(options);
      yield* generateTemplateDirectives(options);
      yield* generateTemplateBody(options, templateCodegenCtx);
      return templateCodegenCtx;
    }
    function* generateTemplateBody(options, templateCodegenCtx) {
      var _a, _b;
      const firstClasses = /* @__PURE__ */ new Set();
      yield `let __VLS_styleScopedClasses!: {}`;
      for (let i = 0; i < options.sfc.styles.length; i++) {
        const style = options.sfc.styles[i];
        const option2 = options.vueCompilerOptions.experimentalResolveStyleCssClasses;
        if (option2 === "always" || option2 === "scoped" && style.scoped) {
          for (const className of style.classNames) {
            if (firstClasses.has(className.text)) {
              templateCodegenCtx.scopedClasses.push({
                source: "style_" + i,
                className: className.text.slice(1),
                offset: className.offset + 1
              });
              continue;
            }
            firstClasses.add(className.text);
            yield* generateCssClassProperty(i, className.text, className.offset, "boolean", true);
          }
        }
      }
      yield common_1.endOfLine;
      yield* (0, styleScopedClasses_1.generateStyleScopedClasses)(templateCodegenCtx, true);
      yield* generateCssVars(options, templateCodegenCtx);
      if (options.templateCodegen) {
        for (const code3 of options.templateCodegen.codes) {
          yield code3;
        }
      } else {
        yield `// no template${common_1.newLine}`;
        if (!((_a = options.scriptSetupRanges) == null ? void 0 : _a.slots.define)) {
          yield `const __VLS_slots = {}${common_1.endOfLine}`;
        }
        yield `const __VLS_inheritedAttrs = {}${common_1.endOfLine}`;
        yield `const $refs = {}${common_1.endOfLine}`;
        yield `const $el = {} as any${common_1.endOfLine}`;
      }
      yield `return {${common_1.newLine}`;
      yield `	attrs: {} as Partial<typeof __VLS_inheritedAttrs>,${common_1.newLine}`;
      yield `	slots: ${((_b = options.scriptSetupRanges) == null ? void 0 : _b.slots.name) ?? "__VLS_slots"},${common_1.newLine}`;
      yield `	refs: $refs,${common_1.newLine}`;
      yield `	rootEl: $el,${common_1.newLine}`;
      yield `}${common_1.endOfLine}`;
    }
    function* generateCssClassProperty(styleIndex, classNameWithDot, offset, propertyType, optional) {
      yield `${common_1.newLine} & { `;
      yield [
        "",
        "style_" + styleIndex,
        offset,
        index_1.codeFeatures.navigation
      ];
      yield `'`;
      yield [
        classNameWithDot.substring(1),
        "style_" + styleIndex,
        offset + 1,
        index_1.codeFeatures.navigation
      ];
      yield `'`;
      yield [
        "",
        "style_" + styleIndex,
        offset + classNameWithDot.length,
        index_1.codeFeatures.navigationWithoutRename
      ];
      yield `${optional ? "?" : ""}: ${propertyType}`;
      yield ` }`;
    }
    function* generateCssVars(options, ctx) {
      if (!options.sfc.styles.length) {
        return;
      }
      yield `// CSS variable injection ${common_1.newLine}`;
      for (const style of options.sfc.styles) {
        for (const cssBind of style.cssVars) {
          for (const [segment, offset, onlyError] of (0, interpolation_1.forEachInterpolationSegment)(options.ts, void 0, void 0, ctx, cssBind.text, cssBind.offset, options.ts.createSourceFile("/a.txt", cssBind.text, 99))) {
            if (offset === void 0) {
              yield segment;
            } else {
              yield [
                segment,
                style.name,
                cssBind.offset + offset,
                onlyError ? index_1.codeFeatures.navigation : index_1.codeFeatures.all
              ];
            }
          }
          yield common_1.endOfLine;
        }
      }
      yield `// CSS variable injection end ${common_1.newLine}`;
    }
    function getTemplateUsageVars(options, ctx) {
      var _a, _b;
      const usageVars = /* @__PURE__ */ new Set();
      const components = new Set((_b = (_a = options.sfc.template) == null ? void 0 : _a.ast) == null ? void 0 : _b.components);
      if (options.templateCodegen) {
        for (const varName of ctx.bindingNames) {
          if (components.has(varName) || components.has((0, shared_1.hyphenateTag)(varName))) {
            usageVars.add(varName);
          }
        }
        for (const component of components) {
          if (component.indexOf(".") >= 0) {
            usageVars.add(component.split(".")[0]);
          }
        }
        for (const [varName] of options.templateCodegen.accessExternalVariables) {
          usageVars.add(varName);
        }
      }
      return usageVars;
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/script/componentSelf.js
var require_componentSelf = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/script/componentSelf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateComponentSelf = generateComponentSelf;
    var path = require_path_browserify();
    var common_1 = require_common();
    var component_1 = require_component();
    var index_1 = require_script();
    var template_1 = require_template2();
    function* generateComponentSelf(options, ctx, templateCodegenCtx) {
      var _a, _b;
      if (options.sfc.scriptSetup && options.scriptSetupRanges) {
        yield `const __VLS_self = (await import('${options.vueCompilerOptions.lib}')).defineComponent({${common_1.newLine}`;
        yield `setup() {${common_1.newLine}`;
        yield `return {${common_1.newLine}`;
        if (ctx.bypassDefineComponent) {
          yield* (0, component_1.generateComponentSetupReturns)(options.scriptSetupRanges);
        }
        const templateUsageVars = (0, template_1.getTemplateUsageVars)(options, ctx);
        for (const [content3, bindings] of [
          [options.sfc.scriptSetup.content, options.scriptSetupRanges.bindings],
          options.sfc.script && options.scriptRanges ? [options.sfc.script.content, options.scriptRanges.bindings] : ["", []]
        ]) {
          for (const expose of bindings) {
            const varName = content3.substring(expose.start, expose.end);
            if (!templateUsageVars.has(varName) && !templateCodegenCtx.accessExternalVariables.has(varName)) {
              continue;
            }
            const templateOffset = options.getGeneratedLength();
            yield `${varName}: ${varName} as typeof `;
            const scriptOffset = options.getGeneratedLength();
            yield `${varName},${common_1.newLine}`;
            options.linkedCodeMappings.push({
              sourceOffsets: [scriptOffset],
              generatedOffsets: [templateOffset],
              lengths: [varName.length],
              data: void 0
            });
          }
        }
        yield `}${common_1.endOfLine}`;
        yield `},${common_1.newLine}`;
        if (options.sfc.scriptSetup && options.scriptSetupRanges && !ctx.bypassDefineComponent) {
          const emitOptionCodes = [...(0, component_1.generateEmitsOption)(options, options.scriptSetupRanges)];
          for (const code3 of emitOptionCodes) {
            yield code3;
          }
          yield* (0, component_1.generatePropsOption)(options, ctx, options.sfc.scriptSetup, options.scriptSetupRanges, !!emitOptionCodes.length, false);
        }
        if (options.sfc.script && ((_b = (_a = options.scriptRanges) == null ? void 0 : _a.exportDefault) == null ? void 0 : _b.args)) {
          const { args } = options.scriptRanges.exportDefault;
          yield (0, common_1.generateSfcBlockSection)(options.sfc.script, args.start + 1, args.end - 1, index_1.codeFeatures.all);
        }
        yield `})${common_1.endOfLine}`;
      } else if (options.sfc.script) {
        yield `let __VLS_self!: typeof import('./${path.basename(options.fileName)}').default${common_1.endOfLine}`;
      } else {
        yield `const __VLS_self = (await import('${options.vueCompilerOptions.lib}')).defineComponent({})${common_1.endOfLine}`;
      }
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/localTypes.js
var require_localTypes = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/localTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalTypesGenerator = getLocalTypesGenerator;
    var shared_1 = require_shared();
    var common_1 = require_common();
    function getLocalTypesGenerator(compilerOptions, vueCompilerOptions) {
      const used = /* @__PURE__ */ new Set();
      const OmitKeepDiscriminatedUnion = defineHelper(`__VLS_OmitKeepDiscriminatedUnion`, () => `
type __VLS_OmitKeepDiscriminatedUnion<T, K extends keyof any> = T extends any
	? Pick<T, Exclude<keyof T, K>>
	: never;
`.trimStart());
      const WithDefaults = defineHelper(`__VLS_WithDefaults`, () => `
type __VLS_WithDefaults<P, D> = {
	[K in keyof Pick<P, keyof P>]: K extends keyof D
		? ${PrettifyLocal.name}<P[K] & { default: D[K]}>
		: P[K]
};
`.trimStart());
      const PrettifyLocal = defineHelper(`__VLS_PrettifyLocal`, () => `type __VLS_PrettifyLocal<T> = { [K in keyof T]: T[K]; } & {}${common_1.endOfLine}`);
      const WithTemplateSlots = defineHelper(`__VLS_WithTemplateSlots`, () => `
type __VLS_WithTemplateSlots<T, S> = T & {
	new(): {
		${(0, shared_1.getSlotsPropertyName)(vueCompilerOptions.target)}: S;
		${vueCompilerOptions.jsxSlots ? `$props: ${PropsChildren.name}<S>;` : ""}
	}
};
`.trimStart());
      const PropsChildren = defineHelper(`__VLS_PropsChildren`, () => `
type __VLS_PropsChildren<S> = {
	[K in keyof (
		boolean extends (
			// @ts-ignore
			JSX.ElementChildrenAttribute extends never
				? true
				: false
		)
			? never
			// @ts-ignore
			: JSX.ElementChildrenAttribute
	)]?: S;
};
`.trimStart());
      const TypePropsToOption = defineHelper(`__VLS_TypePropsToOption`, () => compilerOptions.exactOptionalPropertyTypes ? `
type __VLS_TypePropsToOption<T> = {
	[K in keyof T]-?: {} extends Pick<T, K>
		? { type: import('${vueCompilerOptions.lib}').PropType<T[K]> }
		: { type: import('${vueCompilerOptions.lib}').PropType<T[K]>, required: true }
};
`.trimStart() : `
type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
type __VLS_TypePropsToOption<T> = {
	[K in keyof T]-?: {} extends Pick<T, K>
		? { type: import('${vueCompilerOptions.lib}').PropType<__VLS_NonUndefinedable<T[K]>> }
		: { type: import('${vueCompilerOptions.lib}').PropType<T[K]>, required: true }
};
`.trimStart());
      const OmitIndexSignature = defineHelper(`__VLS_OmitIndexSignature`, () => `type __VLS_OmitIndexSignature<T> = { [K in keyof T as {} extends Record<K, unknown> ? never : K]: T[K]; }${common_1.endOfLine}`);
      const helpers = {
        [PrettifyLocal.name]: PrettifyLocal,
        [OmitKeepDiscriminatedUnion.name]: OmitKeepDiscriminatedUnion,
        [WithDefaults.name]: WithDefaults,
        [WithTemplateSlots.name]: WithTemplateSlots,
        [PropsChildren.name]: PropsChildren,
        [TypePropsToOption.name]: TypePropsToOption,
        [OmitIndexSignature.name]: OmitIndexSignature
      };
      used.clear();
      return {
        generate: generate2,
        getUsedNames() {
          return used;
        },
        get PrettifyLocal() {
          return PrettifyLocal.name;
        },
        get OmitKeepDiscriminatedUnion() {
          return OmitKeepDiscriminatedUnion.name;
        },
        get WithDefaults() {
          return WithDefaults.name;
        },
        get WithTemplateSlots() {
          return WithTemplateSlots.name;
        },
        get PropsChildren() {
          return PropsChildren.name;
        },
        get TypePropsToOption() {
          return TypePropsToOption.name;
        },
        get OmitIndexSignature() {
          return OmitIndexSignature.name;
        }
      };
      function* generate2(names) {
        const generated = /* @__PURE__ */ new Set();
        while (names.length) {
          used.clear();
          for (const name of names) {
            if (generated.has(name)) {
              continue;
            }
            const helper = helpers[name];
            yield helper.generate();
            generated.add(name);
          }
          names = [...used].filter((name) => !generated.has(name));
        }
      }
      function defineHelper(name, generate3) {
        return {
          get name() {
            used.add(name);
            return name;
          },
          generate: generate3
        };
      }
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/script/context.js
var require_context2 = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/script/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createScriptCodegenContext = createScriptCodegenContext;
    var localTypes_1 = require_localTypes();
    function createScriptCodegenContext(options) {
      var _a, _b;
      const localTypes = (0, localTypes_1.getLocalTypesGenerator)(options.compilerOptions, options.vueCompilerOptions);
      const inlayHints = [];
      return {
        generatedTemplate: false,
        generatedPropsType: false,
        scriptSetupGeneratedOffset: void 0,
        bypassDefineComponent: options.lang === "js" || options.lang === "jsx",
        bindingNames: /* @__PURE__ */ new Set([
          ...((_a = options.scriptRanges) == null ? void 0 : _a.bindings.map((range3) => options.sfc.script.content.substring(range3.start, range3.end))) ?? [],
          ...((_b = options.scriptSetupRanges) == null ? void 0 : _b.bindings.map((range3) => options.sfc.scriptSetup.content.substring(range3.start, range3.end))) ?? []
        ]),
        localTypes,
        inlayHints
      };
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/script/scriptSetup.js
var require_scriptSetup = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/script/scriptSetup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateScriptSetupImports = generateScriptSetupImports;
    exports.generateScriptSetup = generateScriptSetup;
    var common_1 = require_common();
    var component_1 = require_component();
    var componentSelf_1 = require_componentSelf();
    var index_1 = require_script();
    var template_1 = require_template2();
    function* generateScriptSetupImports(scriptSetup, scriptSetupRanges) {
      yield [
        scriptSetup.content.substring(0, Math.max(scriptSetupRanges.importSectionEndOffset, scriptSetupRanges.leadingCommentEndOffset)),
        "scriptSetup",
        0,
        index_1.codeFeatures.all
      ];
      yield common_1.newLine;
    }
    function* generateScriptSetup(options, ctx, scriptSetup, scriptSetupRanges) {
      var _a, _b;
      const definePropMirrors = /* @__PURE__ */ new Map();
      if (scriptSetup.generic) {
        if (!((_a = options.scriptRanges) == null ? void 0 : _a.exportDefault)) {
          if (options.sfc.scriptSetup) {
            yield [
              "",
              "scriptSetup",
              options.sfc.scriptSetup.content.length,
              index_1.codeFeatures.verification
            ];
          }
          yield `export default `;
        }
        yield `(<`;
        yield [
          scriptSetup.generic,
          scriptSetup.name,
          scriptSetup.genericOffset,
          index_1.codeFeatures.all
        ];
        if (!scriptSetup.generic.endsWith(`,`)) {
          yield `,`;
        }
        yield `>(${common_1.newLine}	__VLS_props: NonNullable<Awaited<typeof __VLS_setup>>['props'],${common_1.newLine}	__VLS_ctx?: ${ctx.localTypes.PrettifyLocal}<Pick<NonNullable<Awaited<typeof __VLS_setup>>, 'attrs' | 'emit' | 'slots'>>,${common_1.newLine}	__VLS_expose?: NonNullable<Awaited<typeof __VLS_setup>>['expose'],${common_1.newLine}	__VLS_setup = (async () => {${common_1.newLine}`;
        yield* generateSetupFunction(options, ctx, scriptSetup, scriptSetupRanges, void 0, definePropMirrors);
        const emitTypes = [];
        if (scriptSetupRanges.emits.define) {
          emitTypes.push(`typeof ${scriptSetupRanges.emits.name ?? "__VLS_emit"}`);
        }
        if (scriptSetupRanges.defineProp.some((p2) => p2.isModel)) {
          emitTypes.push(`typeof __VLS_modelEmit`);
        }
        yield `		return {} as {${common_1.newLine}			props: ${ctx.localTypes.PrettifyLocal}<typeof __VLS_functionalComponentProps & __VLS_TemplateResult['attrs'] & __VLS_PublicProps> & __VLS_BuiltInPublicProps,${common_1.newLine}			expose(exposed: import('${options.vueCompilerOptions.lib}').ShallowUnwrapRef<${scriptSetupRanges.expose.define ? "typeof __VLS_exposed" : "{}"}>): void,${common_1.newLine}			attrs: any,${common_1.newLine}			slots: __VLS_TemplateResult['slots'],${common_1.newLine}			emit: ${emitTypes.length ? emitTypes.join(" & ") : `{}`},${common_1.newLine}		}${common_1.endOfLine}`;
        yield `	})(),${common_1.newLine}`;
        yield `) => ({} as import('${options.vueCompilerOptions.lib}').VNode & { __ctx?: Awaited<typeof __VLS_setup> }))`;
      } else if (!options.sfc.script) {
        yield* generateSetupFunction(options, ctx, scriptSetup, scriptSetupRanges, "export default", definePropMirrors);
      } else {
        if (!((_b = options.scriptRanges) == null ? void 0 : _b.exportDefault)) {
          yield `export default `;
        }
        yield `await (async () => {${common_1.newLine}`;
        yield* generateSetupFunction(options, ctx, scriptSetup, scriptSetupRanges, "return", definePropMirrors);
        yield `})()`;
      }
      if (ctx.scriptSetupGeneratedOffset !== void 0) {
        for (const defineProp of scriptSetupRanges.defineProp) {
          if (!defineProp.localName) {
            continue;
          }
          const [_, localName] = getPropAndLocalName(scriptSetup, defineProp);
          const propMirror = definePropMirrors.get(localName);
          if (propMirror !== void 0) {
            options.linkedCodeMappings.push({
              sourceOffsets: [defineProp.localName.start + ctx.scriptSetupGeneratedOffset],
              generatedOffsets: [propMirror],
              lengths: [defineProp.localName.end - defineProp.localName.start],
              data: void 0
            });
          }
        }
      }
    }
    function* generateSetupFunction(options, ctx, scriptSetup, scriptSetupRanges, syntax, definePropMirrors) {
      var _a, _b, _c, _d, _e;
      if (options.vueCompilerOptions.target >= 3.3) {
        yield `const { `;
        for (const macro of Object.keys(options.vueCompilerOptions.macros)) {
          if (!ctx.bindingNames.has(macro) && macro !== "templateRef") {
            yield macro + `, `;
          }
        }
        yield `} = await import('${options.vueCompilerOptions.lib}')${common_1.endOfLine}`;
      }
      ctx.scriptSetupGeneratedOffset = options.getGeneratedLength() - scriptSetupRanges.importSectionEndOffset;
      let setupCodeModifies = [];
      if (scriptSetupRanges.props.define) {
        setupCodeModifies.push(...generateDefineWithType(scriptSetup, scriptSetupRanges.props.name, scriptSetupRanges.props.define, scriptSetupRanges.props.withDefaults ?? scriptSetupRanges.props.define, "__VLS_props", "__VLS_Props"));
      }
      if (scriptSetupRanges.slots.define) {
        if (scriptSetupRanges.slots.isObjectBindingPattern) {
          setupCodeModifies.push([
            [`__VLS_slots;
const __VLS_slots = `],
            scriptSetupRanges.slots.define.start,
            scriptSetupRanges.slots.define.start
          ]);
        } else if (!scriptSetupRanges.slots.name) {
          setupCodeModifies.push([[`const __VLS_slots = `], scriptSetupRanges.slots.define.start, scriptSetupRanges.slots.define.start]);
        }
      }
      if (scriptSetupRanges.emits.define) {
        setupCodeModifies.push(...generateDefineWithType(scriptSetup, scriptSetupRanges.emits.name, scriptSetupRanges.emits.define, scriptSetupRanges.emits.define, "__VLS_emit", "__VLS_Emit"));
      }
      if (scriptSetupRanges.expose.define) {
        if ((_a = scriptSetupRanges.expose.define) == null ? void 0 : _a.typeArg) {
          setupCodeModifies.push([
            [
              `let __VLS_exposed!: `,
              (0, common_1.generateSfcBlockSection)(scriptSetup, scriptSetupRanges.expose.define.typeArg.start, scriptSetupRanges.expose.define.typeArg.end, index_1.codeFeatures.navigation),
              `${common_1.endOfLine}`
            ],
            scriptSetupRanges.expose.define.start,
            scriptSetupRanges.expose.define.start
          ]);
        } else if ((_b = scriptSetupRanges.expose.define) == null ? void 0 : _b.arg) {
          setupCodeModifies.push([
            [
              `const __VLS_exposed = `,
              (0, common_1.generateSfcBlockSection)(scriptSetup, scriptSetupRanges.expose.define.arg.start, scriptSetupRanges.expose.define.arg.end, index_1.codeFeatures.navigation),
              `${common_1.endOfLine}`
            ],
            scriptSetupRanges.expose.define.start,
            scriptSetupRanges.expose.define.start
          ]);
        } else {
          setupCodeModifies.push([
            [`const __VLS_exposed = {}${common_1.endOfLine}`],
            scriptSetupRanges.expose.define.start,
            scriptSetupRanges.expose.define.start
          ]);
        }
      }
      if (scriptSetupRanges.cssModules.length) {
        for (const { define: define2 } of scriptSetupRanges.cssModules) {
          setupCodeModifies.push([
            [`(`],
            define2.start,
            define2.start
          ], [
            define2.arg ? [
              ` as Omit<__VLS_StyleModules, '$style'>[`,
              (0, common_1.generateSfcBlockSection)(scriptSetup, define2.arg.start, define2.arg.end, index_1.codeFeatures.all),
              `])`
            ] : [
              ` as __VLS_StyleModules[`,
              ["", scriptSetup.name, define2.exp.start, index_1.codeFeatures.verification],
              `'$style'`,
              ["", scriptSetup.name, define2.exp.end, index_1.codeFeatures.verification],
              `])`
            ],
            define2.end,
            define2.end
          ]);
        }
      }
      const isTs = options.lang !== "js" && options.lang !== "jsx";
      for (const { define: define2 } of scriptSetupRanges.templateRefs) {
        if (!define2.arg) {
          continue;
        }
        if (isTs) {
          setupCodeModifies.push([
            [
              `<__VLS_TemplateResult['refs'][`,
              (0, common_1.generateSfcBlockSection)(scriptSetup, define2.arg.start, define2.arg.end, index_1.codeFeatures.navigation),
              `], keyof __VLS_TemplateResult['refs']>`
            ],
            define2.exp.end,
            define2.exp.end
          ]);
        } else {
          setupCodeModifies.push([
            [`(`],
            define2.start,
            define2.start
          ], [
            [
              ` as __VLS_UseTemplateRef<__VLS_TemplateResult['refs'][`,
              (0, common_1.generateSfcBlockSection)(scriptSetup, define2.arg.start, define2.arg.end, index_1.codeFeatures.navigation),
              `]>)`
            ],
            define2.end,
            define2.end
          ]);
        }
      }
      setupCodeModifies = setupCodeModifies.sort((a, b) => a[1] - b[1]);
      let nextStart = scriptSetupRanges.importSectionEndOffset;
      for (const [codes2, start, end] of setupCodeModifies) {
        yield (0, common_1.generateSfcBlockSection)(scriptSetup, nextStart, start, index_1.codeFeatures.all);
        for (const code3 of codes2) {
          yield code3;
        }
        nextStart = end;
      }
      yield (0, common_1.generateSfcBlockSection)(scriptSetup, nextStart, scriptSetup.content.length, index_1.codeFeatures.all);
      yield* (0, index_1.generateScriptSectionPartiallyEnding)(scriptSetup.name, scriptSetup.content.length, "#3632/scriptSetup.vue");
      if (((_c = scriptSetupRanges.props.define) == null ? void 0 : _c.typeArg) && ((_d = scriptSetupRanges.props.withDefaults) == null ? void 0 : _d.arg)) {
        yield `const __VLS_withDefaultsArg = (function <T>(t: T) { return t })(`;
        yield (0, common_1.generateSfcBlockSection)(scriptSetup, scriptSetupRanges.props.withDefaults.arg.start, scriptSetupRanges.props.withDefaults.arg.end, index_1.codeFeatures.navigation);
        yield `)${common_1.endOfLine}`;
      }
      yield* generateComponentProps(options, ctx, scriptSetup, scriptSetupRanges, definePropMirrors);
      yield* generateModelEmit(scriptSetup, scriptSetupRanges);
      yield `function __VLS_template() {${common_1.newLine}`;
      const templateCodegenCtx = yield* (0, template_1.generateTemplate)(options, ctx);
      yield `}${common_1.endOfLine}`;
      yield* (0, componentSelf_1.generateComponentSelf)(options, ctx, templateCodegenCtx);
      yield `type __VLS_TemplateResult = ReturnType<typeof __VLS_template>${common_1.endOfLine}`;
      if (syntax) {
        if (!options.vueCompilerOptions.skipTemplateCodegen && (((_e = options.templateCodegen) == null ? void 0 : _e.hasSlot) || (scriptSetupRanges == null ? void 0 : scriptSetupRanges.slots.define))) {
          yield `const __VLS_component = `;
          yield* (0, component_1.generateComponent)(options, ctx, scriptSetup, scriptSetupRanges);
          yield common_1.endOfLine;
          yield `${syntax} `;
          yield `{} as ${ctx.localTypes.WithTemplateSlots}<typeof __VLS_component, __VLS_TemplateResult['slots']>${common_1.endOfLine}`;
        } else {
          yield `${syntax} `;
          yield* (0, component_1.generateComponent)(options, ctx, scriptSetup, scriptSetupRanges);
          yield common_1.endOfLine;
        }
      }
    }
    function* generateDefineWithType(scriptSetup, name, define2, expression, defaultName, typeName) {
      const { statement, typeArg } = define2;
      if (typeArg) {
        yield [[
          `type ${typeName} = `,
          (0, common_1.generateSfcBlockSection)(scriptSetup, typeArg.start, typeArg.end, index_1.codeFeatures.all),
          common_1.endOfLine
        ], statement.start, statement.start];
        yield [[typeName], typeArg.start, typeArg.end];
      }
      if (!name) {
        if (statement.start === expression.start && statement.end === expression.end) {
          yield [[`const ${defaultName} = `], expression.start, expression.start];
        } else if (typeArg) {
          yield [[
            `const ${defaultName} = `,
            (0, common_1.generateSfcBlockSection)(scriptSetup, expression.start, typeArg.start, index_1.codeFeatures.all)
          ], statement.start, typeArg.start];
          yield [[
            (0, common_1.generateSfcBlockSection)(scriptSetup, typeArg.end, expression.end, index_1.codeFeatures.all),
            common_1.endOfLine,
            (0, common_1.generateSfcBlockSection)(scriptSetup, statement.start, expression.start, index_1.codeFeatures.all),
            defaultName
          ], typeArg.end, expression.end];
        } else {
          yield [[
            `const ${defaultName} = `,
            (0, common_1.generateSfcBlockSection)(scriptSetup, expression.start, expression.end, index_1.codeFeatures.all),
            common_1.endOfLine,
            (0, common_1.generateSfcBlockSection)(scriptSetup, statement.start, expression.start, index_1.codeFeatures.all),
            defaultName
          ], statement.start, expression.end];
        }
      }
    }
    function* generateComponentProps(options, ctx, scriptSetup, scriptSetupRanges, definePropMirrors) {
      var _a, _b;
      yield `const __VLS_fnComponent = (await import('${options.vueCompilerOptions.lib}')).defineComponent({${common_1.newLine}`;
      if ((_a = scriptSetupRanges.props.define) == null ? void 0 : _a.arg) {
        yield `props: `;
        yield (0, common_1.generateSfcBlockSection)(scriptSetup, scriptSetupRanges.props.define.arg.start, scriptSetupRanges.props.define.arg.end, index_1.codeFeatures.navigation);
        yield `,${common_1.newLine}`;
      }
      yield* (0, component_1.generateEmitsOption)(options, scriptSetupRanges);
      yield `})${common_1.endOfLine}`;
      yield `type __VLS_BuiltInPublicProps = ${options.vueCompilerOptions.target >= 3.4 ? `import('${options.vueCompilerOptions.lib}').PublicProps;` : options.vueCompilerOptions.target >= 3 ? `import('${options.vueCompilerOptions.lib}').VNodeProps
					& import('${options.vueCompilerOptions.lib}').AllowedComponentProps
					& import('${options.vueCompilerOptions.lib}').ComponentCustomProps;` : `globalThis.JSX.IntrinsicAttributes;`}`;
      yield common_1.endOfLine;
      yield `let __VLS_functionalComponentProps!: `;
      yield `${ctx.localTypes.OmitKeepDiscriminatedUnion}<InstanceType<typeof __VLS_fnComponent>['$props'], keyof __VLS_BuiltInPublicProps>`;
      yield common_1.endOfLine;
      if (scriptSetupRanges.defineProp.length) {
        yield `const __VLS_defaults = {${common_1.newLine}`;
        for (const defineProp of scriptSetupRanges.defineProp) {
          if (defineProp.defaultValue) {
            const [propName, localName] = getPropAndLocalName(scriptSetup, defineProp);
            if (defineProp.name || defineProp.isModel) {
              yield propName;
            } else if (defineProp.localName) {
              yield localName;
            } else {
              continue;
            }
            yield `: `;
            yield getRangeName(scriptSetup, defineProp.defaultValue);
            yield `,${common_1.newLine}`;
          }
        }
        yield `}${common_1.endOfLine}`;
      }
      yield `type __VLS_PublicProps = `;
      if (scriptSetupRanges.slots.define && options.vueCompilerOptions.jsxSlots) {
        if (ctx.generatedPropsType) {
          yield ` & `;
        }
        ctx.generatedPropsType = true;
        yield `${ctx.localTypes.PropsChildren}<typeof __VLS_slots>`;
      }
      if (scriptSetupRanges.defineProp.length) {
        if (ctx.generatedPropsType) {
          yield ` & `;
        }
        ctx.generatedPropsType = true;
        yield `{${common_1.newLine}`;
        for (const defineProp of scriptSetupRanges.defineProp) {
          const [propName, localName] = getPropAndLocalName(scriptSetup, defineProp);
          if (defineProp.isModel && !defineProp.name) {
            yield propName;
          } else if (defineProp.name) {
            yield (0, common_1.generateSfcBlockSection)(scriptSetup, defineProp.name.start, defineProp.name.end, index_1.codeFeatures.navigation);
          } else if (defineProp.localName) {
            definePropMirrors.set(localName, options.getGeneratedLength());
            yield localName;
          } else {
            continue;
          }
          yield defineProp.required ? `: ` : `?: `;
          yield* generateDefinePropType(scriptSetup, propName, localName, defineProp);
          yield `,${common_1.newLine}`;
          if (defineProp.modifierType) {
            let propModifierName = "modelModifiers";
            if (defineProp.name) {
              propModifierName = `${getRangeName(scriptSetup, defineProp.name, true)}Modifiers`;
            }
            const modifierType = getRangeName(scriptSetup, defineProp.modifierType);
            definePropMirrors.set(propModifierName, options.getGeneratedLength());
            yield `${propModifierName}?: Record<${modifierType}, true>,${common_1.endOfLine}`;
          }
        }
        yield `}`;
      }
      if ((_b = scriptSetupRanges.props.define) == null ? void 0 : _b.typeArg) {
        if (ctx.generatedPropsType) {
          yield ` & `;
        }
        ctx.generatedPropsType = true;
        yield `__VLS_Props`;
      }
      if (!ctx.generatedPropsType) {
        yield `{}`;
      }
      yield common_1.endOfLine;
    }
    function* generateModelEmit(scriptSetup, scriptSetupRanges) {
      const defineModels = scriptSetupRanges.defineProp.filter((p2) => p2.isModel);
      if (defineModels.length) {
        yield `type __VLS_ModelEmit = {${common_1.newLine}`;
        for (const defineModel of defineModels) {
          const [propName, localName] = getPropAndLocalName(scriptSetup, defineModel);
          yield `'update:${propName}': [value:`;
          yield* generateDefinePropType(scriptSetup, propName, localName, defineModel);
          yield `]${common_1.endOfLine}`;
        }
        yield `}${common_1.endOfLine}`;
        yield `const __VLS_modelEmit = defineEmits<__VLS_ModelEmit>()${common_1.endOfLine}`;
      }
    }
    function* generateDefinePropType(scriptSetup, propName, localName, defineProp) {
      if (defineProp.type) {
        yield getRangeName(scriptSetup, defineProp.type);
      } else if (defineProp.runtimeType && localName) {
        yield `typeof ${localName}['value']`;
      } else if (defineProp.defaultValue && propName) {
        yield `typeof __VLS_defaults['${propName}']`;
      } else {
        yield `any`;
      }
    }
    function getPropAndLocalName(scriptSetup, defineProp) {
      const localName = defineProp.localName ? getRangeName(scriptSetup, defineProp.localName) : void 0;
      let propName = defineProp.name ? getRangeName(scriptSetup, defineProp.name) : defineProp.isModel ? "modelValue" : localName;
      if (defineProp.name) {
        propName = propName.replace(/['"]+/g, "");
      }
      return [propName, localName];
    }
    function getRangeName(scriptSetup, range3, unwrap = false) {
      const offset = unwrap ? 1 : 0;
      return scriptSetup.content.substring(range3.start + offset, range3.end - offset);
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/script/src.js
var require_src = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/script/src.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateSrc = generateSrc;
    var common_1 = require_common();
    var index_1 = require_script();
    function* generateSrc(script, src) {
      if (src.endsWith(".d.ts")) {
        src = src.substring(0, src.length - ".d.ts".length);
      } else if (src.endsWith(".ts")) {
        src = src.substring(0, src.length - ".ts".length);
      } else if (src.endsWith(".tsx")) {
        src = src.substring(0, src.length - ".tsx".length) + ".jsx";
      }
      if (!src.endsWith(".js") && !src.endsWith(".jsx")) {
        src = src + ".js";
      }
      yield `export * from `;
      yield [
        `'${src}'`,
        "script",
        script.srcOffset - 1,
        {
          ...index_1.codeFeatures.all,
          navigation: src === script.src ? true : {
            shouldRename: () => false,
            resolveRenameEditText(newName) {
              var _a, _b, _c;
              if (newName.endsWith(".jsx") || newName.endsWith(".js")) {
                newName = newName.split(".").slice(0, -1).join(".");
              }
              if ((_a = script == null ? void 0 : script.src) == null ? void 0 : _a.endsWith(".d.ts")) {
                newName = newName + ".d.ts";
              } else if ((_b = script == null ? void 0 : script.src) == null ? void 0 : _b.endsWith(".ts")) {
                newName = newName + ".ts";
              } else if ((_c = script == null ? void 0 : script.src) == null ? void 0 : _c.endsWith(".tsx")) {
                newName = newName + ".tsx";
              }
              return newName;
            }
          }
        }
      ];
      yield common_1.endOfLine;
      yield `export { default } from '${src}'${common_1.endOfLine}`;
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/script/styleModulesType.js
var require_styleModulesType = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/script/styleModulesType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateStyleModulesType = generateStyleModulesType;
    var index_1 = require_script();
    var template_1 = require_template2();
    var common_1 = require_common();
    function* generateStyleModulesType(options, ctx) {
      var _a;
      const styles = options.sfc.styles.map((style, i) => [style, i]).filter(([style]) => style.module);
      if (!styles.length && !((_a = options.scriptSetupRanges) == null ? void 0 : _a.cssModules.length)) {
        return;
      }
      yield `type __VLS_StyleModules = {${common_1.newLine}`;
      for (const [style, i] of styles) {
        const { name, offset } = style.module;
        if (offset) {
          yield [
            name,
            "main",
            offset + 1,
            index_1.codeFeatures.all
          ];
        } else {
          yield name;
        }
        yield `: Record<string, string> & ${ctx.localTypes.PrettifyLocal}<{}`;
        for (const className of style.classNames) {
          yield* (0, template_1.generateCssClassProperty)(i, className.text, className.offset, "string", false);
        }
        yield `>${common_1.endOfLine}`;
      }
      yield `}${common_1.endOfLine}`;
    }
  }
});

// node_modules/@vue/language-core/lib/codegen/script/index.js
var require_script = __commonJS({
  "node_modules/@vue/language-core/lib/codegen/script/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.codeFeatures = void 0;
    exports.generateScript = generateScript;
    exports.generateScriptSectionPartiallyEnding = generateScriptSectionPartiallyEnding;
    var path = require_path_browserify();
    var common_1 = require_common();
    var globalTypes_1 = require_globalTypes();
    var componentSelf_1 = require_componentSelf();
    var context_1 = require_context2();
    var scriptSetup_1 = require_scriptSetup();
    var src_1 = require_src();
    var styleModulesType_1 = require_styleModulesType();
    var template_1 = require_template2();
    exports.codeFeatures = {
      all: {
        verification: true,
        completion: true,
        semantic: true,
        navigation: true
      },
      none: {},
      verification: {
        verification: true
      },
      navigation: {
        navigation: true
      },
      navigationWithoutRename: {
        navigation: {
          shouldRename() {
            return false;
          }
        }
      }
    };
    function* generateScript(options) {
      var _a;
      const ctx = (0, context_1.createScriptCodegenContext)(options);
      if (options.vueCompilerOptions.__setupedGlobalTypes) {
        const globalTypes = options.vueCompilerOptions.__setupedGlobalTypes;
        if (typeof globalTypes === "object") {
          let relativePath = path.relative(path.dirname(options.fileName), globalTypes.absolutePath);
          if (relativePath !== globalTypes.absolutePath && !relativePath.startsWith("./") && !relativePath.startsWith("../")) {
            relativePath = "./" + relativePath;
          }
          yield `/// <reference types="${relativePath}" />${common_1.newLine}`;
        } else {
          yield `/// <reference types=".vue-global-types/${options.vueCompilerOptions.lib}_${options.vueCompilerOptions.target}_${options.vueCompilerOptions.strictTemplates}.d.ts" />${common_1.newLine}`;
        }
      } else {
        yield `/* placeholder */`;
      }
      if ((_a = options.sfc.script) == null ? void 0 : _a.src) {
        yield* (0, src_1.generateSrc)(options.sfc.script, options.sfc.script.src);
      }
      if (options.sfc.script && options.scriptRanges) {
        const { exportDefault, classBlockEnd } = options.scriptRanges;
        const isExportRawObject = exportDefault && options.sfc.script.content[exportDefault.expression.start] === "{";
        if (options.sfc.scriptSetup && options.scriptSetupRanges) {
          yield* (0, scriptSetup_1.generateScriptSetupImports)(options.sfc.scriptSetup, options.scriptSetupRanges);
          yield* generateDefineProp(options, options.sfc.scriptSetup);
          if (exportDefault) {
            yield (0, common_1.generateSfcBlockSection)(options.sfc.script, 0, exportDefault.expression.start, exports.codeFeatures.all);
            yield* (0, scriptSetup_1.generateScriptSetup)(options, ctx, options.sfc.scriptSetup, options.scriptSetupRanges);
            yield (0, common_1.generateSfcBlockSection)(options.sfc.script, exportDefault.expression.end, options.sfc.script.content.length, exports.codeFeatures.all);
          } else {
            yield (0, common_1.generateSfcBlockSection)(options.sfc.script, 0, options.sfc.script.content.length, exports.codeFeatures.all);
            yield* generateScriptSectionPartiallyEnding(options.sfc.script.name, options.sfc.script.content.length, "#3632/both.vue");
            yield* (0, scriptSetup_1.generateScriptSetup)(options, ctx, options.sfc.scriptSetup, options.scriptSetupRanges);
          }
        } else if (exportDefault && isExportRawObject && options.vueCompilerOptions.optionsWrapper.length) {
          ctx.inlayHints.push({
            blockName: options.sfc.script.name,
            offset: exportDefault.expression.start,
            setting: "vue.inlayHints.optionsWrapper",
            label: options.vueCompilerOptions.optionsWrapper.length ? options.vueCompilerOptions.optionsWrapper[0] : "[Missing optionsWrapper[0]]",
            tooltip: [
              "This is virtual code that is automatically wrapped for type support, it does not affect your runtime behavior, you can customize it via `vueCompilerOptions.optionsWrapper` option in tsconfig / jsconfig.",
              'To hide it, you can set `"vue.inlayHints.optionsWrapper": false` in IDE settings.'
            ].join("\n\n")
          }, {
            blockName: options.sfc.script.name,
            offset: exportDefault.expression.end,
            setting: "vue.inlayHints.optionsWrapper",
            label: options.vueCompilerOptions.optionsWrapper.length >= 2 ? options.vueCompilerOptions.optionsWrapper[1] : "[Missing optionsWrapper[1]]"
          });
          yield (0, common_1.generateSfcBlockSection)(options.sfc.script, 0, exportDefault.expression.start, exports.codeFeatures.all);
          yield options.vueCompilerOptions.optionsWrapper[0];
          yield (0, common_1.generateSfcBlockSection)(options.sfc.script, exportDefault.expression.start, exportDefault.expression.end, exports.codeFeatures.all);
          yield options.vueCompilerOptions.optionsWrapper[1];
          yield (0, common_1.generateSfcBlockSection)(options.sfc.script, exportDefault.expression.end, options.sfc.script.content.length, exports.codeFeatures.all);
        } else if (classBlockEnd !== void 0) {
          if (options.vueCompilerOptions.skipTemplateCodegen) {
            yield (0, common_1.generateSfcBlockSection)(options.sfc.script, 0, options.sfc.script.content.length, exports.codeFeatures.all);
          } else {
            yield (0, common_1.generateSfcBlockSection)(options.sfc.script, 0, classBlockEnd, exports.codeFeatures.all);
            yield `__VLS_template = () => {${common_1.newLine}`;
            const templateCodegenCtx = yield* (0, template_1.generateTemplate)(options, ctx);
            yield* (0, componentSelf_1.generateComponentSelf)(options, ctx, templateCodegenCtx);
            yield `}${common_1.endOfLine}`;
            yield (0, common_1.generateSfcBlockSection)(options.sfc.script, classBlockEnd, options.sfc.script.content.length, exports.codeFeatures.all);
          }
        } else {
          yield (0, common_1.generateSfcBlockSection)(options.sfc.script, 0, options.sfc.script.content.length, exports.codeFeatures.all);
        }
      } else if (options.sfc.scriptSetup && options.scriptSetupRanges) {
        yield* (0, scriptSetup_1.generateScriptSetupImports)(options.sfc.scriptSetup, options.scriptSetupRanges);
        yield* generateDefineProp(options, options.sfc.scriptSetup);
        yield* (0, scriptSetup_1.generateScriptSetup)(options, ctx, options.sfc.scriptSetup, options.scriptSetupRanges);
      }
      if (options.sfc.script) {
        yield* generateScriptSectionPartiallyEnding(options.sfc.script.name, options.sfc.script.content.length, "#3632/script.vue");
      }
      if (options.sfc.scriptSetup) {
        yield* generateScriptSectionPartiallyEnding(options.sfc.scriptSetup.name, options.sfc.scriptSetup.content.length, "#4569/main.vue");
      }
      if (!ctx.generatedTemplate) {
        yield `function __VLS_template() {${common_1.newLine}`;
        const templateCodegenCtx = yield* (0, template_1.generateTemplate)(options, ctx);
        yield `}${common_1.endOfLine}`;
        yield* (0, componentSelf_1.generateComponentSelf)(options, ctx, templateCodegenCtx);
      }
      yield* (0, styleModulesType_1.generateStyleModulesType)(options, ctx);
      if (options.edited) {
        yield `type __VLS_IntrinsicElementsCompletion = __VLS_IntrinsicElements${common_1.endOfLine}`;
      }
      yield* ctx.localTypes.generate([...ctx.localTypes.getUsedNames()]);
      if (options.appendGlobalTypes) {
        yield (0, globalTypes_1.generateGlobalTypes)(options.vueCompilerOptions.lib, options.vueCompilerOptions.target, options.vueCompilerOptions.strictTemplates);
      }
      if (options.sfc.scriptSetup) {
        yield ["", "scriptSetup", options.sfc.scriptSetup.content.length, exports.codeFeatures.verification];
      }
      return ctx;
    }
    function* generateScriptSectionPartiallyEnding(source, end, mark2) {
      yield `;`;
      yield ["", source, end, exports.codeFeatures.verification];
      yield `/* PartiallyEnd: ${mark2} */${common_1.newLine}`;
    }
    function* generateDefineProp(options, scriptSetup) {
      const definePropProposalA = scriptSetup.content.trimStart().startsWith("// @experimentalDefinePropProposal=kevinEdition") || options.vueCompilerOptions.experimentalDefinePropProposal === "kevinEdition";
      const definePropProposalB = scriptSetup.content.trimStart().startsWith("// @experimentalDefinePropProposal=johnsonEdition") || options.vueCompilerOptions.experimentalDefinePropProposal === "johnsonEdition";
      if (definePropProposalA || definePropProposalB) {
        yield `type __VLS_PropOptions<T> = Exclude<import('${options.vueCompilerOptions.lib}').Prop<T>, import('${options.vueCompilerOptions.lib}').PropType<T>>${common_1.endOfLine}`;
        if (definePropProposalA) {
          yield `declare function defineProp<T>(name: string, options: ({ required: true } | { default: T }) & __VLS_PropOptions<T>): import('${options.vueCompilerOptions.lib}').ComputedRef<T>${common_1.endOfLine}`;
          yield `declare function defineProp<T>(name?: string, options?: __VLS_PropOptions<T>): import('${options.vueCompilerOptions.lib}').ComputedRef<T | undefined>${common_1.endOfLine}`;
        }
        if (definePropProposalB) {
          yield `declare function defineProp<T>(value: T | (() => T), required?: boolean, options?: __VLS_PropOptions<T>): import('${options.vueCompilerOptions.lib}').ComputedRef<T>${common_1.endOfLine}`;
          yield `declare function defineProp<T>(value: T | (() => T) | undefined, required: true, options?: __VLS_PropOptions<T>): import('${options.vueCompilerOptions.lib}').ComputedRef<T>${common_1.endOfLine}`;
          yield `declare function defineProp<T>(value?: T | (() => T), required?: boolean, options?: __VLS_PropOptions<T>): import('${options.vueCompilerOptions.lib}').ComputedRef<T | undefined>${common_1.endOfLine}`;
        }
      }
    }
  }
});

// node_modules/@vue/language-core/lib/parsers/scriptRanges.js
var require_scriptRanges = __commonJS({
  "node_modules/@vue/language-core/lib/parsers/scriptRanges.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseScriptRanges = parseScriptRanges;
    var scriptSetupRanges_1 = require_scriptSetupRanges();
    function parseScriptRanges(ts3, ast, hasScriptSetup, withNode) {
      let exportDefault;
      let classBlockEnd;
      const bindings = hasScriptSetup ? (0, scriptSetupRanges_1.parseBindingRanges)(ts3, ast) : [];
      ts3.forEachChild(ast, (raw2) => {
        var _a, _b;
        if (ts3.isExportAssignment(raw2)) {
          let node2 = raw2;
          while (isAsExpression(node2.expression) || ts3.isParenthesizedExpression(node2.expression)) {
            node2 = node2.expression;
          }
          let obj;
          if (ts3.isObjectLiteralExpression(node2.expression)) {
            obj = node2.expression;
          } else if (ts3.isCallExpression(node2.expression) && node2.expression.arguments.length) {
            const arg0 = node2.expression.arguments[0];
            if (ts3.isObjectLiteralExpression(arg0)) {
              obj = arg0;
            }
          }
          if (obj) {
            let componentsOptionNode;
            let directivesOptionNode;
            let nameOptionNode;
            let inheritAttrsOption;
            ts3.forEachChild(obj, (node3) => {
              if (ts3.isPropertyAssignment(node3) && ts3.isIdentifier(node3.name)) {
                const name = (0, scriptSetupRanges_1.getNodeText)(ts3, node3.name, ast);
                if (name === "components" && ts3.isObjectLiteralExpression(node3.initializer)) {
                  componentsOptionNode = node3.initializer;
                } else if (name === "directives" && ts3.isObjectLiteralExpression(node3.initializer)) {
                  directivesOptionNode = node3.initializer;
                } else if (name === "name") {
                  nameOptionNode = node3.initializer;
                } else if (name === "inheritAttrs") {
                  inheritAttrsOption = (0, scriptSetupRanges_1.getNodeText)(ts3, node3.initializer, ast);
                }
              }
            });
            exportDefault = {
              ..._getStartEnd(raw2),
              expression: _getStartEnd(node2.expression),
              args: _getStartEnd(obj),
              argsNode: withNode ? obj : void 0,
              componentsOption: componentsOptionNode ? _getStartEnd(componentsOptionNode) : void 0,
              componentsOptionNode: withNode ? componentsOptionNode : void 0,
              directivesOption: directivesOptionNode ? _getStartEnd(directivesOptionNode) : void 0,
              nameOption: nameOptionNode ? _getStartEnd(nameOptionNode) : void 0,
              inheritAttrsOption
            };
          }
        }
        if (ts3.isClassDeclaration(raw2) && ((_a = raw2.modifiers) == null ? void 0 : _a.some((mod) => mod.kind === ts3.SyntaxKind.ExportKeyword)) && ((_b = raw2.modifiers) == null ? void 0 : _b.some((mod) => mod.kind === ts3.SyntaxKind.DefaultKeyword))) {
          classBlockEnd = raw2.end - 1;
        }
      });
      return {
        exportDefault,
        classBlockEnd,
        bindings
      };
      function _getStartEnd(node2) {
        return (0, scriptSetupRanges_1.getStartEnd)(ts3, node2, ast);
      }
      function isAsExpression(node2) {
        return node2.kind === ts3.SyntaxKind.AsExpression;
      }
    }
  }
});

// node_modules/@vue/language-core/lib/plugins/vue-tsx.js
var require_vue_tsx = __commonJS({
  "node_modules/@vue/language-core/lib/plugins/vue-tsx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tsCodegen = void 0;
    var alien_signals_1 = require_cjs();
    var script_1 = require_script();
    var template_1 = require_template();
    var scriptRanges_1 = require_scriptRanges();
    var scriptSetupRanges_1 = require_scriptSetupRanges();
    exports.tsCodegen = /* @__PURE__ */ new WeakMap();
    var fileEditTimes = /* @__PURE__ */ new Map();
    var plugin = (ctx) => {
      let appendedGlobalTypes = false;
      return {
        version: 2.1,
        requiredCompilerOptions: [
          "noPropertyAccessFromIndexSignature",
          "exactOptionalPropertyTypes"
        ],
        getEmbeddedCodes(fileName, sfc) {
          const tsx = useTsx(fileName, sfc);
          const files = [];
          if (["js", "ts", "jsx", "tsx"].includes(tsx.lang.get())) {
            files.push({ id: "script_" + tsx.lang.get(), lang: tsx.lang.get() });
          }
          return files;
        },
        resolveEmbeddedCode(fileName, sfc, embeddedFile) {
          const _tsx = useTsx(fileName, sfc);
          if (/script_(js|jsx|ts|tsx)/.test(embeddedFile.id)) {
            const tsx = _tsx.generatedScript.get();
            if (tsx) {
              const content3 = [...tsx.codes];
              embeddedFile.content = content3;
              embeddedFile.linkedCodeMappings = [...tsx.linkedCodeMappings];
            }
          }
        }
      };
      function useTsx(fileName, sfc) {
        if (!exports.tsCodegen.has(sfc)) {
          let appendGlobalTypes = false;
          if (!ctx.vueCompilerOptions.__setupedGlobalTypes && !appendedGlobalTypes) {
            appendGlobalTypes = true;
            appendedGlobalTypes = true;
          }
          exports.tsCodegen.set(sfc, createTsx(fileName, sfc, ctx, appendGlobalTypes));
        }
        return exports.tsCodegen.get(sfc);
      }
    };
    exports.default = plugin;
    function createTsx(fileName, _sfc, ctx, appendGlobalTypes) {
      const ts3 = ctx.modules.typescript;
      const lang = (0, alien_signals_1.computed)(() => {
        return !_sfc.script && !_sfc.scriptSetup ? "ts" : _sfc.scriptSetup && _sfc.scriptSetup.lang !== "js" ? _sfc.scriptSetup.lang : _sfc.script && _sfc.script.lang !== "js" ? _sfc.script.lang : "js";
      });
      const scriptRanges = (0, alien_signals_1.computed)(() => _sfc.script ? (0, scriptRanges_1.parseScriptRanges)(ts3, _sfc.script.ast, !!_sfc.scriptSetup, false) : void 0);
      const scriptSetupRanges = (0, alien_signals_1.computed)(() => _sfc.scriptSetup ? (0, scriptSetupRanges_1.parseScriptSetupRanges)(ts3, _sfc.scriptSetup.ast, ctx.vueCompilerOptions) : void 0);
      const generatedTemplate = (0, alien_signals_1.computed)(() => {
        if (ctx.vueCompilerOptions.skipTemplateCodegen || !_sfc.template) {
          return;
        }
        const codes2 = [];
        const codegen = (0, template_1.generateTemplate)({
          ts: ts3,
          compilerOptions: ctx.compilerOptions,
          vueCompilerOptions: ctx.vueCompilerOptions,
          template: _sfc.template,
          edited: ctx.vueCompilerOptions.__test || (fileEditTimes.get(fileName) ?? 0) >= 2,
          scriptSetupBindingNames: scriptSetupBindingNames.get(),
          scriptSetupImportComponentNames: scriptSetupImportComponentNames.get(),
          destructuredPropNames: destructuredPropNames.get(),
          templateRefNames: templateRefNames.get(),
          hasDefineSlots: hasDefineSlots.get(),
          slotsAssignName: slotsAssignName.get(),
          propsAssignName: propsAssignName.get(),
          inheritAttrs: inheritAttrs.get()
        });
        let current = codegen.next();
        while (!current.done) {
          const code3 = current.value;
          codes2.push(code3);
          current = codegen.next();
        }
        return {
          ...current.value,
          codes: codes2
        };
      });
      const scriptSetupBindingNames = (0, alien_signals_1.computed)((oldNames) => {
        var _a, _b;
        const newNames = /* @__PURE__ */ new Set();
        const bindings = (_a = scriptSetupRanges.get()) == null ? void 0 : _a.bindings;
        if (_sfc.scriptSetup && bindings) {
          for (const binding of bindings) {
            newNames.add((_b = _sfc.scriptSetup) == null ? void 0 : _b.content.substring(binding.start, binding.end));
          }
        }
        if (newNames && oldNames && twoSetsEqual(newNames, oldNames)) {
          return oldNames;
        }
        return newNames;
      });
      const scriptSetupImportComponentNames = (0, alien_signals_1.computed)((oldNames) => {
        var _a;
        const newNames = ((_a = scriptSetupRanges.get()) == null ? void 0 : _a.importComponentNames) ?? /* @__PURE__ */ new Set();
        if (oldNames && twoSetsEqual(newNames, oldNames)) {
          return oldNames;
        }
        return newNames;
      });
      const destructuredPropNames = (0, alien_signals_1.computed)((oldNames) => {
        var _a, _b;
        const newNames = ((_a = scriptSetupRanges.get()) == null ? void 0 : _a.props.destructured) ?? /* @__PURE__ */ new Set();
        const rest = (_b = scriptSetupRanges.get()) == null ? void 0 : _b.props.destructuredRest;
        if (rest) {
          newNames.add(rest);
        }
        if (oldNames && twoSetsEqual(newNames, oldNames)) {
          return oldNames;
        }
        return newNames;
      });
      const templateRefNames = (0, alien_signals_1.computed)((oldNames) => {
        var _a;
        const newNames = new Set((_a = scriptSetupRanges.get()) == null ? void 0 : _a.templateRefs.map(({ name }) => name).filter((name) => name !== void 0));
        if (oldNames && twoSetsEqual(newNames, oldNames)) {
          return oldNames;
        }
        return newNames;
      });
      const hasDefineSlots = (0, alien_signals_1.computed)(() => {
        var _a;
        return !!((_a = scriptSetupRanges.get()) == null ? void 0 : _a.slots.define);
      });
      const slotsAssignName = (0, alien_signals_1.computed)(() => {
        var _a;
        return (_a = scriptSetupRanges.get()) == null ? void 0 : _a.slots.name;
      });
      const propsAssignName = (0, alien_signals_1.computed)(() => {
        var _a;
        return (_a = scriptSetupRanges.get()) == null ? void 0 : _a.props.name;
      });
      const inheritAttrs = (0, alien_signals_1.computed)(() => {
        var _a, _b, _c;
        const value = ((_a = scriptSetupRanges.get()) == null ? void 0 : _a.options.inheritAttrs) ?? ((_c = (_b = scriptRanges.get()) == null ? void 0 : _b.exportDefault) == null ? void 0 : _c.inheritAttrsOption);
        return value !== "false";
      });
      const generatedScript = (0, alien_signals_1.computed)(() => {
        const codes2 = [];
        const linkedCodeMappings = [];
        let generatedLength = 0;
        const codegen = (0, script_1.generateScript)({
          ts: ts3,
          fileName,
          sfc: _sfc,
          lang: lang.get(),
          scriptRanges: scriptRanges.get(),
          scriptSetupRanges: scriptSetupRanges.get(),
          templateCodegen: generatedTemplate.get(),
          compilerOptions: ctx.compilerOptions,
          vueCompilerOptions: ctx.vueCompilerOptions,
          edited: ctx.vueCompilerOptions.__test || (fileEditTimes.get(fileName) ?? 0) >= 2,
          getGeneratedLength: () => generatedLength,
          linkedCodeMappings,
          appendGlobalTypes
        });
        fileEditTimes.set(fileName, (fileEditTimes.get(fileName) ?? 0) + 1);
        let current = codegen.next();
        while (!current.done) {
          const code3 = current.value;
          codes2.push(code3);
          generatedLength += typeof code3 === "string" ? code3.length : code3[0].length;
          current = codegen.next();
        }
        return {
          ...current.value,
          codes: codes2,
          linkedCodeMappings
        };
      });
      return {
        scriptRanges,
        scriptSetupRanges,
        lang,
        generatedScript,
        generatedTemplate
      };
    }
    function twoSetsEqual(a, b) {
      if (a.size !== b.size) {
        return false;
      }
      for (const file of a) {
        if (!b.has(file)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@vue/language-core/lib/types.js
var require_types3 = __commonJS({
  "node_modules/@vue/language-core/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validVersions = void 0;
    exports.validVersions = [2, 2.1];
  }
});

// node_modules/@vue/language-core/lib/plugins.js
var require_plugins = __commonJS({
  "node_modules/@vue/language-core/lib/plugins.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPlugins = createPlugins;
    var file_html_1 = require_file_html();
    var file_md_1 = require_file_md();
    var file_vue_1 = require_file_vue();
    var vue_root_tags_1 = require_vue_root_tags();
    var vue_script_js_1 = require_vue_script_js();
    var vue_sfc_customblocks_1 = require_vue_sfc_customblocks();
    var vue_sfc_scripts_1 = require_vue_sfc_scripts();
    var vue_sfc_styles_1 = require_vue_sfc_styles();
    var vue_sfc_template_1 = require_vue_sfc_template();
    var vue_template_html_1 = require_vue_template_html();
    var vue_template_inline_css_1 = require_vue_template_inline_css();
    var vue_template_inline_ts_1 = require_vue_template_inline_ts();
    var vue_tsx_1 = require_vue_tsx();
    var types_1 = require_types3();
    __exportStar(require_shared2(), exports);
    function createPlugins(pluginContext) {
      const plugins = [
        file_vue_1.default,
        file_md_1.default,
        file_html_1.default,
        vue_root_tags_1.default,
        vue_script_js_1.default,
        vue_template_html_1.default,
        vue_template_inline_css_1.default,
        vue_template_inline_ts_1.default,
        vue_sfc_styles_1.default,
        vue_sfc_customblocks_1.default,
        vue_sfc_scripts_1.default,
        vue_sfc_template_1.default,
        vue_tsx_1.default,
        ...pluginContext.vueCompilerOptions.plugins
      ];
      const pluginInstances = plugins.flatMap((plugin) => {
        var _a;
        try {
          const instance = plugin(pluginContext);
          const moduleName = plugin.__moduleName;
          if (Array.isArray(instance)) {
            for (let i = 0; i < instance.length; i++) {
              (_a = instance[i]).name ?? (_a.name = `${moduleName} (${i})`);
            }
          } else {
            instance.name ?? (instance.name = moduleName);
          }
          return instance;
        } catch (err) {
          console.warn("[Vue] Failed to create plugin", err);
        }
      }).filter((plugin) => !!plugin).sort((a, b) => {
        const aOrder = a.order ?? 0;
        const bOrder = b.order ?? 0;
        return aOrder - bOrder;
      });
      return pluginInstances.filter((plugin) => {
        if (!types_1.validVersions.includes(plugin.version)) {
          console.warn(`[Vue] Plugin ${plugin.name} is not compatible with the current Vue language tools version. (version: ${plugin.version}, supported versions: ${JSON.stringify(types_1.validVersions)})`);
          return false;
        }
        return true;
      });
    }
  }
});

// node_modules/de-indent/index.js
var require_de_indent = __commonJS({
  "node_modules/de-indent/index.js"(exports, module2) {
    var splitRE = /\r?\n/g;
    var emptyRE = /^\s*$/;
    var needFixRE = /^(\r?\n)*[\t\s]/;
    module2.exports = function deindent(str) {
      if (!needFixRE.test(str)) {
        return str;
      }
      var lines = str.split(splitRE);
      var min = Infinity;
      var type, cur, c;
      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (!emptyRE.test(line)) {
          if (!type) {
            c = line.charAt(0);
            if (c === " " || c === "	") {
              type = c;
              cur = count(line, type);
              if (cur < min) {
                min = cur;
              }
            } else {
              return str;
            }
          } else {
            cur = count(line, type);
            if (cur < min) {
              min = cur;
            }
          }
        }
      }
      return lines.map(function(line2) {
        return line2.slice(min);
      }).join("\n");
    };
    function count(line, type) {
      var i = 0;
      while (line.charAt(i) === type) {
        i++;
      }
      return i;
    }
  }
});

// node_modules/he/he.js
var require_he = __commonJS({
  "node_modules/he/he.js"(exports, module2) {
    (function(root4) {
      var freeExports = typeof exports == "object" && exports;
      var freeModule = typeof module2 == "object" && module2 && module2.exports == freeExports && module2;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root4 = freeGlobal;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = { "­": "shy", "‌": "zwnj", "‍": "zwj", "‎": "lrm", "⁣": "ic", "⁢": "it", "⁡": "af", "‏": "rlm", "​": "ZeroWidthSpace", "⁠": "NoBreak", "̑": "DownBreve", "⃛": "tdot", "⃜": "DotDot", "	": "Tab", "\n": "NewLine", " ": "puncsp", " ": "MediumSpace", " ": "thinsp", " ": "hairsp", " ": "emsp13", " ": "ensp", " ": "emsp14", " ": "emsp", " ": "numsp", " ": "nbsp", "  ": "ThickSpace", "‾": "oline", "_": "lowbar", "‐": "dash", "–": "ndash", "—": "mdash", "―": "horbar", ",": "comma", ";": "semi", "⁏": "bsemi", ":": "colon", "⩴": "Colone", "!": "excl", "¡": "iexcl", "?": "quest", "¿": "iquest", ".": "period", "‥": "nldr", "…": "mldr", "·": "middot", "'": "apos", "‘": "lsquo", "’": "rsquo", "‚": "sbquo", "‹": "lsaquo", "›": "rsaquo", '"': "quot", "“": "ldquo", "”": "rdquo", "„": "bdquo", "«": "laquo", "»": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "⌈": "lceil", "⌉": "rceil", "⌊": "lfloor", "⌋": "rfloor", "⦅": "lopar", "⦆": "ropar", "⦋": "lbrke", "⦌": "rbrke", "⦍": "lbrkslu", "⦎": "rbrksld", "⦏": "lbrksld", "⦐": "rbrkslu", "⦑": "langd", "⦒": "rangd", "⦓": "lparlt", "⦔": "rpargt", "⦕": "gtlPar", "⦖": "ltrPar", "⟦": "lobrk", "⟧": "robrk", "⟨": "lang", "⟩": "rang", "⟪": "Lang", "⟫": "Rang", "⟬": "loang", "⟭": "roang", "❲": "lbbrk", "❳": "rbbrk", "‖": "Vert", "§": "sect", "¶": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "‰": "permil", "‱": "pertenk", "†": "dagger", "‡": "Dagger", "•": "bull", "⁃": "hybull", "′": "prime", "″": "Prime", "‴": "tprime", "⁗": "qprime", "‵": "bprime", "⁁": "caret", "`": "grave", "´": "acute", "˜": "tilde", "^": "Hat", "¯": "macr", "˘": "breve", "˙": "dot", "¨": "die", "˚": "ring", "˝": "dblac", "¸": "cedil", "˛": "ogon", "ˆ": "circ", "ˇ": "caron", "°": "deg", "©": "copy", "®": "reg", "℗": "copysr", "℘": "wp", "℞": "rx", "℧": "mho", "℩": "iiota", "←": "larr", "↚": "nlarr", "→": "rarr", "↛": "nrarr", "↑": "uarr", "↓": "darr", "↔": "harr", "↮": "nharr", "↕": "varr", "↖": "nwarr", "↗": "nearr", "↘": "searr", "↙": "swarr", "↝": "rarrw", "↝̸": "nrarrw", "↞": "Larr", "↟": "Uarr", "↠": "Rarr", "↡": "Darr", "↢": "larrtl", "↣": "rarrtl", "↤": "mapstoleft", "↥": "mapstoup", "↦": "map", "↧": "mapstodown", "↩": "larrhk", "↪": "rarrhk", "↫": "larrlp", "↬": "rarrlp", "↭": "harrw", "↰": "lsh", "↱": "rsh", "↲": "ldsh", "↳": "rdsh", "↵": "crarr", "↶": "cularr", "↷": "curarr", "↺": "olarr", "↻": "orarr", "↼": "lharu", "↽": "lhard", "↾": "uharr", "↿": "uharl", "⇀": "rharu", "⇁": "rhard", "⇂": "dharr", "⇃": "dharl", "⇄": "rlarr", "⇅": "udarr", "⇆": "lrarr", "⇇": "llarr", "⇈": "uuarr", "⇉": "rrarr", "⇊": "ddarr", "⇋": "lrhar", "⇌": "rlhar", "⇐": "lArr", "⇍": "nlArr", "⇑": "uArr", "⇒": "rArr", "⇏": "nrArr", "⇓": "dArr", "⇔": "iff", "⇎": "nhArr", "⇕": "vArr", "⇖": "nwArr", "⇗": "neArr", "⇘": "seArr", "⇙": "swArr", "⇚": "lAarr", "⇛": "rAarr", "⇝": "zigrarr", "⇤": "larrb", "⇥": "rarrb", "⇵": "duarr", "⇽": "loarr", "⇾": "roarr", "⇿": "hoarr", "∀": "forall", "∁": "comp", "∂": "part", "∂̸": "npart", "∃": "exist", "∄": "nexist", "∅": "empty", "∇": "Del", "∈": "in", "∉": "notin", "∋": "ni", "∌": "notni", "϶": "bepsi", "∏": "prod", "∐": "coprod", "∑": "sum", "+": "plus", "±": "pm", "÷": "div", "×": "times", "<": "lt", "≮": "nlt", "<⃒": "nvlt", "=": "equals", "≠": "ne", "=⃥": "bne", "⩵": "Equal", ">": "gt", "≯": "ngt", ">⃒": "nvgt", "¬": "not", "|": "vert", "¦": "brvbar", "−": "minus", "∓": "mp", "∔": "plusdo", "⁄": "frasl", "∖": "setmn", "∗": "lowast", "∘": "compfn", "√": "Sqrt", "∝": "prop", "∞": "infin", "∟": "angrt", "∠": "ang", "∠⃒": "nang", "∡": "angmsd", "∢": "angsph", "∣": "mid", "∤": "nmid", "∥": "par", "∦": "npar", "∧": "and", "∨": "or", "∩": "cap", "∩︀": "caps", "∪": "cup", "∪︀": "cups", "∫": "int", "∬": "Int", "∭": "tint", "⨌": "qint", "∮": "oint", "∯": "Conint", "∰": "Cconint", "∱": "cwint", "∲": "cwconint", "∳": "awconint", "∴": "there4", "∵": "becaus", "∶": "ratio", "∷": "Colon", "∸": "minusd", "∺": "mDDot", "∻": "homtht", "∼": "sim", "≁": "nsim", "∼⃒": "nvsim", "∽": "bsim", "∽̱": "race", "∾": "ac", "∾̳": "acE", "∿": "acd", "≀": "wr", "≂": "esim", "≂̸": "nesim", "≃": "sime", "≄": "nsime", "≅": "cong", "≇": "ncong", "≆": "simne", "≈": "ap", "≉": "nap", "≊": "ape", "≋": "apid", "≋̸": "napid", "≌": "bcong", "≍": "CupCap", "≭": "NotCupCap", "≍⃒": "nvap", "≎": "bump", "≎̸": "nbump", "≏": "bumpe", "≏̸": "nbumpe", "≐": "doteq", "≐̸": "nedot", "≑": "eDot", "≒": "efDot", "≓": "erDot", "≔": "colone", "≕": "ecolon", "≖": "ecir", "≗": "cire", "≙": "wedgeq", "≚": "veeeq", "≜": "trie", "≟": "equest", "≡": "equiv", "≢": "nequiv", "≡⃥": "bnequiv", "≤": "le", "≰": "nle", "≤⃒": "nvle", "≥": "ge", "≱": "nge", "≥⃒": "nvge", "≦": "lE", "≦̸": "nlE", "≧": "gE", "≧̸": "ngE", "≨︀": "lvnE", "≨": "lnE", "≩": "gnE", "≩︀": "gvnE", "≪": "ll", "≪̸": "nLtv", "≪⃒": "nLt", "≫": "gg", "≫̸": "nGtv", "≫⃒": "nGt", "≬": "twixt", "≲": "lsim", "≴": "nlsim", "≳": "gsim", "≵": "ngsim", "≶": "lg", "≸": "ntlg", "≷": "gl", "≹": "ntgl", "≺": "pr", "⊀": "npr", "≻": "sc", "⊁": "nsc", "≼": "prcue", "⋠": "nprcue", "≽": "sccue", "⋡": "nsccue", "≾": "prsim", "≿": "scsim", "≿̸": "NotSucceedsTilde", "⊂": "sub", "⊄": "nsub", "⊂⃒": "vnsub", "⊃": "sup", "⊅": "nsup", "⊃⃒": "vnsup", "⊆": "sube", "⊈": "nsube", "⊇": "supe", "⊉": "nsupe", "⊊︀": "vsubne", "⊊": "subne", "⊋︀": "vsupne", "⊋": "supne", "⊍": "cupdot", "⊎": "uplus", "⊏": "sqsub", "⊏̸": "NotSquareSubset", "⊐": "sqsup", "⊐̸": "NotSquareSuperset", "⊑": "sqsube", "⋢": "nsqsube", "⊒": "sqsupe", "⋣": "nsqsupe", "⊓": "sqcap", "⊓︀": "sqcaps", "⊔": "sqcup", "⊔︀": "sqcups", "⊕": "oplus", "⊖": "ominus", "⊗": "otimes", "⊘": "osol", "⊙": "odot", "⊚": "ocir", "⊛": "oast", "⊝": "odash", "⊞": "plusb", "⊟": "minusb", "⊠": "timesb", "⊡": "sdotb", "⊢": "vdash", "⊬": "nvdash", "⊣": "dashv", "⊤": "top", "⊥": "bot", "⊧": "models", "⊨": "vDash", "⊭": "nvDash", "⊩": "Vdash", "⊮": "nVdash", "⊪": "Vvdash", "⊫": "VDash", "⊯": "nVDash", "⊰": "prurel", "⊲": "vltri", "⋪": "nltri", "⊳": "vrtri", "⋫": "nrtri", "⊴": "ltrie", "⋬": "nltrie", "⊴⃒": "nvltrie", "⊵": "rtrie", "⋭": "nrtrie", "⊵⃒": "nvrtrie", "⊶": "origof", "⊷": "imof", "⊸": "mumap", "⊹": "hercon", "⊺": "intcal", "⊻": "veebar", "⊽": "barvee", "⊾": "angrtvb", "⊿": "lrtri", "⋀": "Wedge", "⋁": "Vee", "⋂": "xcap", "⋃": "xcup", "⋄": "diam", "⋅": "sdot", "⋆": "Star", "⋇": "divonx", "⋈": "bowtie", "⋉": "ltimes", "⋊": "rtimes", "⋋": "lthree", "⋌": "rthree", "⋍": "bsime", "⋎": "cuvee", "⋏": "cuwed", "⋐": "Sub", "⋑": "Sup", "⋒": "Cap", "⋓": "Cup", "⋔": "fork", "⋕": "epar", "⋖": "ltdot", "⋗": "gtdot", "⋘": "Ll", "⋘̸": "nLl", "⋙": "Gg", "⋙̸": "nGg", "⋚︀": "lesg", "⋚": "leg", "⋛": "gel", "⋛︀": "gesl", "⋞": "cuepr", "⋟": "cuesc", "⋦": "lnsim", "⋧": "gnsim", "⋨": "prnsim", "⋩": "scnsim", "⋮": "vellip", "⋯": "ctdot", "⋰": "utdot", "⋱": "dtdot", "⋲": "disin", "⋳": "isinsv", "⋴": "isins", "⋵": "isindot", "⋵̸": "notindot", "⋶": "notinvc", "⋷": "notinvb", "⋹": "isinE", "⋹̸": "notinE", "⋺": "nisd", "⋻": "xnis", "⋼": "nis", "⋽": "notnivc", "⋾": "notnivb", "⌅": "barwed", "⌆": "Barwed", "⌌": "drcrop", "⌍": "dlcrop", "⌎": "urcrop", "⌏": "ulcrop", "⌐": "bnot", "⌒": "profline", "⌓": "profsurf", "⌕": "telrec", "⌖": "target", "⌜": "ulcorn", "⌝": "urcorn", "⌞": "dlcorn", "⌟": "drcorn", "⌢": "frown", "⌣": "smile", "⌭": "cylcty", "⌮": "profalar", "⌶": "topbot", "⌽": "ovbar", "⌿": "solbar", "⍼": "angzarr", "⎰": "lmoust", "⎱": "rmoust", "⎴": "tbrk", "⎵": "bbrk", "⎶": "bbrktbrk", "⏜": "OverParenthesis", "⏝": "UnderParenthesis", "⏞": "OverBrace", "⏟": "UnderBrace", "⏢": "trpezium", "⏧": "elinters", "␣": "blank", "─": "boxh", "│": "boxv", "┌": "boxdr", "┐": "boxdl", "└": "boxur", "┘": "boxul", "├": "boxvr", "┤": "boxvl", "┬": "boxhd", "┴": "boxhu", "┼": "boxvh", "═": "boxH", "║": "boxV", "╒": "boxdR", "╓": "boxDr", "╔": "boxDR", "╕": "boxdL", "╖": "boxDl", "╗": "boxDL", "╘": "boxuR", "╙": "boxUr", "╚": "boxUR", "╛": "boxuL", "╜": "boxUl", "╝": "boxUL", "╞": "boxvR", "╟": "boxVr", "╠": "boxVR", "╡": "boxvL", "╢": "boxVl", "╣": "boxVL", "╤": "boxHd", "╥": "boxhD", "╦": "boxHD", "╧": "boxHu", "╨": "boxhU", "╩": "boxHU", "╪": "boxvH", "╫": "boxVh", "╬": "boxVH", "▀": "uhblk", "▄": "lhblk", "█": "block", "░": "blk14", "▒": "blk12", "▓": "blk34", "□": "squ", "▪": "squf", "▫": "EmptyVerySmallSquare", "▭": "rect", "▮": "marker", "▱": "fltns", "△": "xutri", "▴": "utrif", "▵": "utri", "▸": "rtrif", "▹": "rtri", "▽": "xdtri", "▾": "dtrif", "▿": "dtri", "◂": "ltrif", "◃": "ltri", "◊": "loz", "○": "cir", "◬": "tridot", "◯": "xcirc", "◸": "ultri", "◹": "urtri", "◺": "lltri", "◻": "EmptySmallSquare", "◼": "FilledSmallSquare", "★": "starf", "☆": "star", "☎": "phone", "♀": "female", "♂": "male", "♠": "spades", "♣": "clubs", "♥": "hearts", "♦": "diams", "♪": "sung", "✓": "check", "✗": "cross", "✠": "malt", "✶": "sext", "❘": "VerticalSeparator", "⟈": "bsolhsub", "⟉": "suphsol", "⟵": "xlarr", "⟶": "xrarr", "⟷": "xharr", "⟸": "xlArr", "⟹": "xrArr", "⟺": "xhArr", "⟼": "xmap", "⟿": "dzigrarr", "⤂": "nvlArr", "⤃": "nvrArr", "⤄": "nvHarr", "⤅": "Map", "⤌": "lbarr", "⤍": "rbarr", "⤎": "lBarr", "⤏": "rBarr", "⤐": "RBarr", "⤑": "DDotrahd", "⤒": "UpArrowBar", "⤓": "DownArrowBar", "⤖": "Rarrtl", "⤙": "latail", "⤚": "ratail", "⤛": "lAtail", "⤜": "rAtail", "⤝": "larrfs", "⤞": "rarrfs", "⤟": "larrbfs", "⤠": "rarrbfs", "⤣": "nwarhk", "⤤": "nearhk", "⤥": "searhk", "⤦": "swarhk", "⤧": "nwnear", "⤨": "toea", "⤩": "tosa", "⤪": "swnwar", "⤳": "rarrc", "⤳̸": "nrarrc", "⤵": "cudarrr", "⤶": "ldca", "⤷": "rdca", "⤸": "cudarrl", "⤹": "larrpl", "⤼": "curarrm", "⤽": "cularrp", "⥅": "rarrpl", "⥈": "harrcir", "⥉": "Uarrocir", "⥊": "lurdshar", "⥋": "ldrushar", "⥎": "LeftRightVector", "⥏": "RightUpDownVector", "⥐": "DownLeftRightVector", "⥑": "LeftUpDownVector", "⥒": "LeftVectorBar", "⥓": "RightVectorBar", "⥔": "RightUpVectorBar", "⥕": "RightDownVectorBar", "⥖": "DownLeftVectorBar", "⥗": "DownRightVectorBar", "⥘": "LeftUpVectorBar", "⥙": "LeftDownVectorBar", "⥚": "LeftTeeVector", "⥛": "RightTeeVector", "⥜": "RightUpTeeVector", "⥝": "RightDownTeeVector", "⥞": "DownLeftTeeVector", "⥟": "DownRightTeeVector", "⥠": "LeftUpTeeVector", "⥡": "LeftDownTeeVector", "⥢": "lHar", "⥣": "uHar", "⥤": "rHar", "⥥": "dHar", "⥦": "luruhar", "⥧": "ldrdhar", "⥨": "ruluhar", "⥩": "rdldhar", "⥪": "lharul", "⥫": "llhard", "⥬": "rharul", "⥭": "lrhard", "⥮": "udhar", "⥯": "duhar", "⥰": "RoundImplies", "⥱": "erarr", "⥲": "simrarr", "⥳": "larrsim", "⥴": "rarrsim", "⥵": "rarrap", "⥶": "ltlarr", "⥸": "gtrarr", "⥹": "subrarr", "⥻": "suplarr", "⥼": "lfisht", "⥽": "rfisht", "⥾": "ufisht", "⥿": "dfisht", "⦚": "vzigzag", "⦜": "vangrt", "⦝": "angrtvbd", "⦤": "ange", "⦥": "range", "⦦": "dwangle", "⦧": "uwangle", "⦨": "angmsdaa", "⦩": "angmsdab", "⦪": "angmsdac", "⦫": "angmsdad", "⦬": "angmsdae", "⦭": "angmsdaf", "⦮": "angmsdag", "⦯": "angmsdah", "⦰": "bemptyv", "⦱": "demptyv", "⦲": "cemptyv", "⦳": "raemptyv", "⦴": "laemptyv", "⦵": "ohbar", "⦶": "omid", "⦷": "opar", "⦹": "operp", "⦻": "olcross", "⦼": "odsold", "⦾": "olcir", "⦿": "ofcir", "⧀": "olt", "⧁": "ogt", "⧂": "cirscir", "⧃": "cirE", "⧄": "solb", "⧅": "bsolb", "⧉": "boxbox", "⧍": "trisb", "⧎": "rtriltri", "⧏": "LeftTriangleBar", "⧏̸": "NotLeftTriangleBar", "⧐": "RightTriangleBar", "⧐̸": "NotRightTriangleBar", "⧜": "iinfin", "⧝": "infintie", "⧞": "nvinfin", "⧣": "eparsl", "⧤": "smeparsl", "⧥": "eqvparsl", "⧫": "lozf", "⧴": "RuleDelayed", "⧶": "dsol", "⨀": "xodot", "⨁": "xoplus", "⨂": "xotime", "⨄": "xuplus", "⨆": "xsqcup", "⨍": "fpartint", "⨐": "cirfnint", "⨑": "awint", "⨒": "rppolint", "⨓": "scpolint", "⨔": "npolint", "⨕": "pointint", "⨖": "quatint", "⨗": "intlarhk", "⨢": "pluscir", "⨣": "plusacir", "⨤": "simplus", "⨥": "plusdu", "⨦": "plussim", "⨧": "plustwo", "⨩": "mcomma", "⨪": "minusdu", "⨭": "loplus", "⨮": "roplus", "⨯": "Cross", "⨰": "timesd", "⨱": "timesbar", "⨳": "smashp", "⨴": "lotimes", "⨵": "rotimes", "⨶": "otimesas", "⨷": "Otimes", "⨸": "odiv", "⨹": "triplus", "⨺": "triminus", "⨻": "tritime", "⨼": "iprod", "⨿": "amalg", "⩀": "capdot", "⩂": "ncup", "⩃": "ncap", "⩄": "capand", "⩅": "cupor", "⩆": "cupcap", "⩇": "capcup", "⩈": "cupbrcap", "⩉": "capbrcup", "⩊": "cupcup", "⩋": "capcap", "⩌": "ccups", "⩍": "ccaps", "⩐": "ccupssm", "⩓": "And", "⩔": "Or", "⩕": "andand", "⩖": "oror", "⩗": "orslope", "⩘": "andslope", "⩚": "andv", "⩛": "orv", "⩜": "andd", "⩝": "ord", "⩟": "wedbar", "⩦": "sdote", "⩪": "simdot", "⩭": "congdot", "⩭̸": "ncongdot", "⩮": "easter", "⩯": "apacir", "⩰": "apE", "⩰̸": "napE", "⩱": "eplus", "⩲": "pluse", "⩳": "Esim", "⩷": "eDDot", "⩸": "equivDD", "⩹": "ltcir", "⩺": "gtcir", "⩻": "ltquest", "⩼": "gtquest", "⩽": "les", "⩽̸": "nles", "⩾": "ges", "⩾̸": "nges", "⩿": "lesdot", "⪀": "gesdot", "⪁": "lesdoto", "⪂": "gesdoto", "⪃": "lesdotor", "⪄": "gesdotol", "⪅": "lap", "⪆": "gap", "⪇": "lne", "⪈": "gne", "⪉": "lnap", "⪊": "gnap", "⪋": "lEg", "⪌": "gEl", "⪍": "lsime", "⪎": "gsime", "⪏": "lsimg", "⪐": "gsiml", "⪑": "lgE", "⪒": "glE", "⪓": "lesges", "⪔": "gesles", "⪕": "els", "⪖": "egs", "⪗": "elsdot", "⪘": "egsdot", "⪙": "el", "⪚": "eg", "⪝": "siml", "⪞": "simg", "⪟": "simlE", "⪠": "simgE", "⪡": "LessLess", "⪡̸": "NotNestedLessLess", "⪢": "GreaterGreater", "⪢̸": "NotNestedGreaterGreater", "⪤": "glj", "⪥": "gla", "⪦": "ltcc", "⪧": "gtcc", "⪨": "lescc", "⪩": "gescc", "⪪": "smt", "⪫": "lat", "⪬": "smte", "⪬︀": "smtes", "⪭": "late", "⪭︀": "lates", "⪮": "bumpE", "⪯": "pre", "⪯̸": "npre", "⪰": "sce", "⪰̸": "nsce", "⪳": "prE", "⪴": "scE", "⪵": "prnE", "⪶": "scnE", "⪷": "prap", "⪸": "scap", "⪹": "prnap", "⪺": "scnap", "⪻": "Pr", "⪼": "Sc", "⪽": "subdot", "⪾": "supdot", "⪿": "subplus", "⫀": "supplus", "⫁": "submult", "⫂": "supmult", "⫃": "subedot", "⫄": "supedot", "⫅": "subE", "⫅̸": "nsubE", "⫆": "supE", "⫆̸": "nsupE", "⫇": "subsim", "⫈": "supsim", "⫋︀": "vsubnE", "⫋": "subnE", "⫌︀": "vsupnE", "⫌": "supnE", "⫏": "csub", "⫐": "csup", "⫑": "csube", "⫒": "csupe", "⫓": "subsup", "⫔": "supsub", "⫕": "subsub", "⫖": "supsup", "⫗": "suphsub", "⫘": "supdsub", "⫙": "forkv", "⫚": "topfork", "⫛": "mlcp", "⫤": "Dashv", "⫦": "Vdashl", "⫧": "Barv", "⫨": "vBar", "⫩": "vBarv", "⫫": "Vbar", "⫬": "Not", "⫭": "bNot", "⫮": "rnmid", "⫯": "cirmid", "⫰": "midcir", "⫱": "topcir", "⫲": "nhpar", "⫳": "parsim", "⫽": "parsl", "⫽⃥": "nparsl", "♭": "flat", "♮": "natur", "♯": "sharp", "¤": "curren", "¢": "cent", "$": "dollar", "£": "pound", "¥": "yen", "€": "euro", "¹": "sup1", "½": "half", "⅓": "frac13", "¼": "frac14", "⅕": "frac15", "⅙": "frac16", "⅛": "frac18", "²": "sup2", "⅔": "frac23", "⅖": "frac25", "³": "sup3", "¾": "frac34", "⅗": "frac35", "⅜": "frac38", "⅘": "frac45", "⅚": "frac56", "⅝": "frac58", "⅞": "frac78", "𝒶": "ascr", "𝕒": "aopf", "𝔞": "afr", "𝔸": "Aopf", "𝔄": "Afr", "𝒜": "Ascr", "ª": "ordf", "á": "aacute", "Á": "Aacute", "à": "agrave", "À": "Agrave", "ă": "abreve", "Ă": "Abreve", "â": "acirc", "Â": "Acirc", "å": "aring", "Å": "angst", "ä": "auml", "Ä": "Auml", "ã": "atilde", "Ã": "Atilde", "ą": "aogon", "Ą": "Aogon", "ā": "amacr", "Ā": "Amacr", "æ": "aelig", "Æ": "AElig", "𝒷": "bscr", "𝕓": "bopf", "𝔟": "bfr", "𝔹": "Bopf", "ℬ": "Bscr", "𝔅": "Bfr", "𝔠": "cfr", "𝒸": "cscr", "𝕔": "copf", "ℭ": "Cfr", "𝒞": "Cscr", "ℂ": "Copf", "ć": "cacute", "Ć": "Cacute", "ĉ": "ccirc", "Ĉ": "Ccirc", "č": "ccaron", "Č": "Ccaron", "ċ": "cdot", "Ċ": "Cdot", "ç": "ccedil", "Ç": "Ccedil", "℅": "incare", "𝔡": "dfr", "ⅆ": "dd", "𝕕": "dopf", "𝒹": "dscr", "𝒟": "Dscr", "𝔇": "Dfr", "ⅅ": "DD", "𝔻": "Dopf", "ď": "dcaron", "Ď": "Dcaron", "đ": "dstrok", "Đ": "Dstrok", "ð": "eth", "Ð": "ETH", "ⅇ": "ee", "ℯ": "escr", "𝔢": "efr", "𝕖": "eopf", "ℰ": "Escr", "𝔈": "Efr", "𝔼": "Eopf", "é": "eacute", "É": "Eacute", "è": "egrave", "È": "Egrave", "ê": "ecirc", "Ê": "Ecirc", "ě": "ecaron", "Ě": "Ecaron", "ë": "euml", "Ë": "Euml", "ė": "edot", "Ė": "Edot", "ę": "eogon", "Ę": "Eogon", "ē": "emacr", "Ē": "Emacr", "𝔣": "ffr", "𝕗": "fopf", "𝒻": "fscr", "𝔉": "Ffr", "𝔽": "Fopf", "ℱ": "Fscr", "ﬀ": "fflig", "ﬃ": "ffilig", "ﬄ": "ffllig", "ﬁ": "filig", "fj": "fjlig", "ﬂ": "fllig", "ƒ": "fnof", "ℊ": "gscr", "𝕘": "gopf", "𝔤": "gfr", "𝒢": "Gscr", "𝔾": "Gopf", "𝔊": "Gfr", "ǵ": "gacute", "ğ": "gbreve", "Ğ": "Gbreve", "ĝ": "gcirc", "Ĝ": "Gcirc", "ġ": "gdot", "Ġ": "Gdot", "Ģ": "Gcedil", "𝔥": "hfr", "ℎ": "planckh", "𝒽": "hscr", "𝕙": "hopf", "ℋ": "Hscr", "ℌ": "Hfr", "ℍ": "Hopf", "ĥ": "hcirc", "Ĥ": "Hcirc", "ℏ": "hbar", "ħ": "hstrok", "Ħ": "Hstrok", "𝕚": "iopf", "𝔦": "ifr", "𝒾": "iscr", "ⅈ": "ii", "𝕀": "Iopf", "ℐ": "Iscr", "ℑ": "Im", "í": "iacute", "Í": "Iacute", "ì": "igrave", "Ì": "Igrave", "î": "icirc", "Î": "Icirc", "ï": "iuml", "Ï": "Iuml", "ĩ": "itilde", "Ĩ": "Itilde", "İ": "Idot", "į": "iogon", "Į": "Iogon", "ī": "imacr", "Ī": "Imacr", "ĳ": "ijlig", "Ĳ": "IJlig", "ı": "imath", "𝒿": "jscr", "𝕛": "jopf", "𝔧": "jfr", "𝒥": "Jscr", "𝔍": "Jfr", "𝕁": "Jopf", "ĵ": "jcirc", "Ĵ": "Jcirc", "ȷ": "jmath", "𝕜": "kopf", "𝓀": "kscr", "𝔨": "kfr", "𝒦": "Kscr", "𝕂": "Kopf", "𝔎": "Kfr", "ķ": "kcedil", "Ķ": "Kcedil", "𝔩": "lfr", "𝓁": "lscr", "ℓ": "ell", "𝕝": "lopf", "ℒ": "Lscr", "𝔏": "Lfr", "𝕃": "Lopf", "ĺ": "lacute", "Ĺ": "Lacute", "ľ": "lcaron", "Ľ": "Lcaron", "ļ": "lcedil", "Ļ": "Lcedil", "ł": "lstrok", "Ł": "Lstrok", "ŀ": "lmidot", "Ŀ": "Lmidot", "𝔪": "mfr", "𝕞": "mopf", "𝓂": "mscr", "𝔐": "Mfr", "𝕄": "Mopf", "ℳ": "Mscr", "𝔫": "nfr", "𝕟": "nopf", "𝓃": "nscr", "ℕ": "Nopf", "𝒩": "Nscr", "𝔑": "Nfr", "ń": "nacute", "Ń": "Nacute", "ň": "ncaron", "Ň": "Ncaron", "ñ": "ntilde", "Ñ": "Ntilde", "ņ": "ncedil", "Ņ": "Ncedil", "№": "numero", "ŋ": "eng", "Ŋ": "ENG", "𝕠": "oopf", "𝔬": "ofr", "ℴ": "oscr", "𝒪": "Oscr", "𝔒": "Ofr", "𝕆": "Oopf", "º": "ordm", "ó": "oacute", "Ó": "Oacute", "ò": "ograve", "Ò": "Ograve", "ô": "ocirc", "Ô": "Ocirc", "ö": "ouml", "Ö": "Ouml", "ő": "odblac", "Ő": "Odblac", "õ": "otilde", "Õ": "Otilde", "ø": "oslash", "Ø": "Oslash", "ō": "omacr", "Ō": "Omacr", "œ": "oelig", "Œ": "OElig", "𝔭": "pfr", "𝓅": "pscr", "𝕡": "popf", "ℙ": "Popf", "𝔓": "Pfr", "𝒫": "Pscr", "𝕢": "qopf", "𝔮": "qfr", "𝓆": "qscr", "𝒬": "Qscr", "𝔔": "Qfr", "ℚ": "Qopf", "ĸ": "kgreen", "𝔯": "rfr", "𝕣": "ropf", "𝓇": "rscr", "ℛ": "Rscr", "ℜ": "Re", "ℝ": "Ropf", "ŕ": "racute", "Ŕ": "Racute", "ř": "rcaron", "Ř": "Rcaron", "ŗ": "rcedil", "Ŗ": "Rcedil", "𝕤": "sopf", "𝓈": "sscr", "𝔰": "sfr", "𝕊": "Sopf", "𝔖": "Sfr", "𝒮": "Sscr", "Ⓢ": "oS", "ś": "sacute", "Ś": "Sacute", "ŝ": "scirc", "Ŝ": "Scirc", "š": "scaron", "Š": "Scaron", "ş": "scedil", "Ş": "Scedil", "ß": "szlig", "𝔱": "tfr", "𝓉": "tscr", "𝕥": "topf", "𝒯": "Tscr", "𝔗": "Tfr", "𝕋": "Topf", "ť": "tcaron", "Ť": "Tcaron", "ţ": "tcedil", "Ţ": "Tcedil", "™": "trade", "ŧ": "tstrok", "Ŧ": "Tstrok", "𝓊": "uscr", "𝕦": "uopf", "𝔲": "ufr", "𝕌": "Uopf", "𝔘": "Ufr", "𝒰": "Uscr", "ú": "uacute", "Ú": "Uacute", "ù": "ugrave", "Ù": "Ugrave", "ŭ": "ubreve", "Ŭ": "Ubreve", "û": "ucirc", "Û": "Ucirc", "ů": "uring", "Ů": "Uring", "ü": "uuml", "Ü": "Uuml", "ű": "udblac", "Ű": "Udblac", "ũ": "utilde", "Ũ": "Utilde", "ų": "uogon", "Ų": "Uogon", "ū": "umacr", "Ū": "Umacr", "𝔳": "vfr", "𝕧": "vopf", "𝓋": "vscr", "𝔙": "Vfr", "𝕍": "Vopf", "𝒱": "Vscr", "𝕨": "wopf", "𝓌": "wscr", "𝔴": "wfr", "𝒲": "Wscr", "𝕎": "Wopf", "𝔚": "Wfr", "ŵ": "wcirc", "Ŵ": "Wcirc", "𝔵": "xfr", "𝓍": "xscr", "𝕩": "xopf", "𝕏": "Xopf", "𝔛": "Xfr", "𝒳": "Xscr", "𝔶": "yfr", "𝓎": "yscr", "𝕪": "yopf", "𝒴": "Yscr", "𝔜": "Yfr", "𝕐": "Yopf", "ý": "yacute", "Ý": "Yacute", "ŷ": "ycirc", "Ŷ": "Ycirc", "ÿ": "yuml", "Ÿ": "Yuml", "𝓏": "zscr", "𝔷": "zfr", "𝕫": "zopf", "ℨ": "Zfr", "ℤ": "Zopf", "𝒵": "Zscr", "ź": "zacute", "Ź": "Zacute", "ž": "zcaron", "Ž": "Zcaron", "ż": "zdot", "Ż": "Zdot", "Ƶ": "imped", "þ": "thorn", "Þ": "THORN", "ŉ": "napos", "α": "alpha", "Α": "Alpha", "β": "beta", "Β": "Beta", "γ": "gamma", "Γ": "Gamma", "δ": "delta", "Δ": "Delta", "ε": "epsi", "ϵ": "epsiv", "Ε": "Epsilon", "ϝ": "gammad", "Ϝ": "Gammad", "ζ": "zeta", "Ζ": "Zeta", "η": "eta", "Η": "Eta", "θ": "theta", "ϑ": "thetav", "Θ": "Theta", "ι": "iota", "Ι": "Iota", "κ": "kappa", "ϰ": "kappav", "Κ": "Kappa", "λ": "lambda", "Λ": "Lambda", "μ": "mu", "µ": "micro", "Μ": "Mu", "ν": "nu", "Ν": "Nu", "ξ": "xi", "Ξ": "Xi", "ο": "omicron", "Ο": "Omicron", "π": "pi", "ϖ": "piv", "Π": "Pi", "ρ": "rho", "ϱ": "rhov", "Ρ": "Rho", "σ": "sigma", "Σ": "Sigma", "ς": "sigmaf", "τ": "tau", "Τ": "Tau", "υ": "upsi", "Υ": "Upsilon", "ϒ": "Upsi", "φ": "phi", "ϕ": "phiv", "Φ": "Phi", "χ": "chi", "Χ": "Chi", "ψ": "psi", "Ψ": "Psi", "ω": "omega", "Ω": "ohm", "а": "acy", "А": "Acy", "б": "bcy", "Б": "Bcy", "в": "vcy", "В": "Vcy", "г": "gcy", "Г": "Gcy", "ѓ": "gjcy", "Ѓ": "GJcy", "д": "dcy", "Д": "Dcy", "ђ": "djcy", "Ђ": "DJcy", "е": "iecy", "Е": "IEcy", "ё": "iocy", "Ё": "IOcy", "є": "jukcy", "Є": "Jukcy", "ж": "zhcy", "Ж": "ZHcy", "з": "zcy", "З": "Zcy", "ѕ": "dscy", "Ѕ": "DScy", "и": "icy", "И": "Icy", "і": "iukcy", "І": "Iukcy", "ї": "yicy", "Ї": "YIcy", "й": "jcy", "Й": "Jcy", "ј": "jsercy", "Ј": "Jsercy", "к": "kcy", "К": "Kcy", "ќ": "kjcy", "Ќ": "KJcy", "л": "lcy", "Л": "Lcy", "љ": "ljcy", "Љ": "LJcy", "м": "mcy", "М": "Mcy", "н": "ncy", "Н": "Ncy", "њ": "njcy", "Њ": "NJcy", "о": "ocy", "О": "Ocy", "п": "pcy", "П": "Pcy", "р": "rcy", "Р": "Rcy", "с": "scy", "С": "Scy", "т": "tcy", "Т": "Tcy", "ћ": "tshcy", "Ћ": "TSHcy", "у": "ucy", "У": "Ucy", "ў": "ubrcy", "Ў": "Ubrcy", "ф": "fcy", "Ф": "Fcy", "х": "khcy", "Х": "KHcy", "ц": "tscy", "Ц": "TScy", "ч": "chcy", "Ч": "CHcy", "џ": "dzcy", "Џ": "DZcy", "ш": "shcy", "Ш": "SHcy", "щ": "shchcy", "Щ": "SHCHcy", "ъ": "hardcy", "Ъ": "HARDcy", "ы": "ycy", "Ы": "Ycy", "ь": "softcy", "Ь": "SOFTcy", "э": "ecy", "Э": "Ecy", "ю": "yucy", "Ю": "YUcy", "я": "yacy", "Я": "YAcy", "ℵ": "aleph", "ℶ": "beth", "ℷ": "gimel", "ℸ": "daleth" };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless it’s part of a tag or an
        // unquoted attribute value. We’re only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer ≤ 8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;"
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = { "aacute": "á", "Aacute": "Á", "abreve": "ă", "Abreve": "Ă", "ac": "∾", "acd": "∿", "acE": "∾̳", "acirc": "â", "Acirc": "Â", "acute": "´", "acy": "а", "Acy": "А", "aelig": "æ", "AElig": "Æ", "af": "⁡", "afr": "𝔞", "Afr": "𝔄", "agrave": "à", "Agrave": "À", "alefsym": "ℵ", "aleph": "ℵ", "alpha": "α", "Alpha": "Α", "amacr": "ā", "Amacr": "Ā", "amalg": "⨿", "amp": "&", "AMP": "&", "and": "∧", "And": "⩓", "andand": "⩕", "andd": "⩜", "andslope": "⩘", "andv": "⩚", "ang": "∠", "ange": "⦤", "angle": "∠", "angmsd": "∡", "angmsdaa": "⦨", "angmsdab": "⦩", "angmsdac": "⦪", "angmsdad": "⦫", "angmsdae": "⦬", "angmsdaf": "⦭", "angmsdag": "⦮", "angmsdah": "⦯", "angrt": "∟", "angrtvb": "⊾", "angrtvbd": "⦝", "angsph": "∢", "angst": "Å", "angzarr": "⍼", "aogon": "ą", "Aogon": "Ą", "aopf": "𝕒", "Aopf": "𝔸", "ap": "≈", "apacir": "⩯", "ape": "≊", "apE": "⩰", "apid": "≋", "apos": "'", "ApplyFunction": "⁡", "approx": "≈", "approxeq": "≊", "aring": "å", "Aring": "Å", "ascr": "𝒶", "Ascr": "𝒜", "Assign": "≔", "ast": "*", "asymp": "≈", "asympeq": "≍", "atilde": "ã", "Atilde": "Ã", "auml": "ä", "Auml": "Ä", "awconint": "∳", "awint": "⨑", "backcong": "≌", "backepsilon": "϶", "backprime": "‵", "backsim": "∽", "backsimeq": "⋍", "Backslash": "∖", "Barv": "⫧", "barvee": "⊽", "barwed": "⌅", "Barwed": "⌆", "barwedge": "⌅", "bbrk": "⎵", "bbrktbrk": "⎶", "bcong": "≌", "bcy": "б", "Bcy": "Б", "bdquo": "„", "becaus": "∵", "because": "∵", "Because": "∵", "bemptyv": "⦰", "bepsi": "϶", "bernou": "ℬ", "Bernoullis": "ℬ", "beta": "β", "Beta": "Β", "beth": "ℶ", "between": "≬", "bfr": "𝔟", "Bfr": "𝔅", "bigcap": "⋂", "bigcirc": "◯", "bigcup": "⋃", "bigodot": "⨀", "bigoplus": "⨁", "bigotimes": "⨂", "bigsqcup": "⨆", "bigstar": "★", "bigtriangledown": "▽", "bigtriangleup": "△", "biguplus": "⨄", "bigvee": "⋁", "bigwedge": "⋀", "bkarow": "⤍", "blacklozenge": "⧫", "blacksquare": "▪", "blacktriangle": "▴", "blacktriangledown": "▾", "blacktriangleleft": "◂", "blacktriangleright": "▸", "blank": "␣", "blk12": "▒", "blk14": "░", "blk34": "▓", "block": "█", "bne": "=⃥", "bnequiv": "≡⃥", "bnot": "⌐", "bNot": "⫭", "bopf": "𝕓", "Bopf": "𝔹", "bot": "⊥", "bottom": "⊥", "bowtie": "⋈", "boxbox": "⧉", "boxdl": "┐", "boxdL": "╕", "boxDl": "╖", "boxDL": "╗", "boxdr": "┌", "boxdR": "╒", "boxDr": "╓", "boxDR": "╔", "boxh": "─", "boxH": "═", "boxhd": "┬", "boxhD": "╥", "boxHd": "╤", "boxHD": "╦", "boxhu": "┴", "boxhU": "╨", "boxHu": "╧", "boxHU": "╩", "boxminus": "⊟", "boxplus": "⊞", "boxtimes": "⊠", "boxul": "┘", "boxuL": "╛", "boxUl": "╜", "boxUL": "╝", "boxur": "└", "boxuR": "╘", "boxUr": "╙", "boxUR": "╚", "boxv": "│", "boxV": "║", "boxvh": "┼", "boxvH": "╪", "boxVh": "╫", "boxVH": "╬", "boxvl": "┤", "boxvL": "╡", "boxVl": "╢", "boxVL": "╣", "boxvr": "├", "boxvR": "╞", "boxVr": "╟", "boxVR": "╠", "bprime": "‵", "breve": "˘", "Breve": "˘", "brvbar": "¦", "bscr": "𝒷", "Bscr": "ℬ", "bsemi": "⁏", "bsim": "∽", "bsime": "⋍", "bsol": "\\", "bsolb": "⧅", "bsolhsub": "⟈", "bull": "•", "bullet": "•", "bump": "≎", "bumpe": "≏", "bumpE": "⪮", "bumpeq": "≏", "Bumpeq": "≎", "cacute": "ć", "Cacute": "Ć", "cap": "∩", "Cap": "⋒", "capand": "⩄", "capbrcup": "⩉", "capcap": "⩋", "capcup": "⩇", "capdot": "⩀", "CapitalDifferentialD": "ⅅ", "caps": "∩︀", "caret": "⁁", "caron": "ˇ", "Cayleys": "ℭ", "ccaps": "⩍", "ccaron": "č", "Ccaron": "Č", "ccedil": "ç", "Ccedil": "Ç", "ccirc": "ĉ", "Ccirc": "Ĉ", "Cconint": "∰", "ccups": "⩌", "ccupssm": "⩐", "cdot": "ċ", "Cdot": "Ċ", "cedil": "¸", "Cedilla": "¸", "cemptyv": "⦲", "cent": "¢", "centerdot": "·", "CenterDot": "·", "cfr": "𝔠", "Cfr": "ℭ", "chcy": "ч", "CHcy": "Ч", "check": "✓", "checkmark": "✓", "chi": "χ", "Chi": "Χ", "cir": "○", "circ": "ˆ", "circeq": "≗", "circlearrowleft": "↺", "circlearrowright": "↻", "circledast": "⊛", "circledcirc": "⊚", "circleddash": "⊝", "CircleDot": "⊙", "circledR": "®", "circledS": "Ⓢ", "CircleMinus": "⊖", "CirclePlus": "⊕", "CircleTimes": "⊗", "cire": "≗", "cirE": "⧃", "cirfnint": "⨐", "cirmid": "⫯", "cirscir": "⧂", "ClockwiseContourIntegral": "∲", "CloseCurlyDoubleQuote": "”", "CloseCurlyQuote": "’", "clubs": "♣", "clubsuit": "♣", "colon": ":", "Colon": "∷", "colone": "≔", "Colone": "⩴", "coloneq": "≔", "comma": ",", "commat": "@", "comp": "∁", "compfn": "∘", "complement": "∁", "complexes": "ℂ", "cong": "≅", "congdot": "⩭", "Congruent": "≡", "conint": "∮", "Conint": "∯", "ContourIntegral": "∮", "copf": "𝕔", "Copf": "ℂ", "coprod": "∐", "Coproduct": "∐", "copy": "©", "COPY": "©", "copysr": "℗", "CounterClockwiseContourIntegral": "∳", "crarr": "↵", "cross": "✗", "Cross": "⨯", "cscr": "𝒸", "Cscr": "𝒞", "csub": "⫏", "csube": "⫑", "csup": "⫐", "csupe": "⫒", "ctdot": "⋯", "cudarrl": "⤸", "cudarrr": "⤵", "cuepr": "⋞", "cuesc": "⋟", "cularr": "↶", "cularrp": "⤽", "cup": "∪", "Cup": "⋓", "cupbrcap": "⩈", "cupcap": "⩆", "CupCap": "≍", "cupcup": "⩊", "cupdot": "⊍", "cupor": "⩅", "cups": "∪︀", "curarr": "↷", "curarrm": "⤼", "curlyeqprec": "⋞", "curlyeqsucc": "⋟", "curlyvee": "⋎", "curlywedge": "⋏", "curren": "¤", "curvearrowleft": "↶", "curvearrowright": "↷", "cuvee": "⋎", "cuwed": "⋏", "cwconint": "∲", "cwint": "∱", "cylcty": "⌭", "dagger": "†", "Dagger": "‡", "daleth": "ℸ", "darr": "↓", "dArr": "⇓", "Darr": "↡", "dash": "‐", "dashv": "⊣", "Dashv": "⫤", "dbkarow": "⤏", "dblac": "˝", "dcaron": "ď", "Dcaron": "Ď", "dcy": "д", "Dcy": "Д", "dd": "ⅆ", "DD": "ⅅ", "ddagger": "‡", "ddarr": "⇊", "DDotrahd": "⤑", "ddotseq": "⩷", "deg": "°", "Del": "∇", "delta": "δ", "Delta": "Δ", "demptyv": "⦱", "dfisht": "⥿", "dfr": "𝔡", "Dfr": "𝔇", "dHar": "⥥", "dharl": "⇃", "dharr": "⇂", "DiacriticalAcute": "´", "DiacriticalDot": "˙", "DiacriticalDoubleAcute": "˝", "DiacriticalGrave": "`", "DiacriticalTilde": "˜", "diam": "⋄", "diamond": "⋄", "Diamond": "⋄", "diamondsuit": "♦", "diams": "♦", "die": "¨", "DifferentialD": "ⅆ", "digamma": "ϝ", "disin": "⋲", "div": "÷", "divide": "÷", "divideontimes": "⋇", "divonx": "⋇", "djcy": "ђ", "DJcy": "Ђ", "dlcorn": "⌞", "dlcrop": "⌍", "dollar": "$", "dopf": "𝕕", "Dopf": "𝔻", "dot": "˙", "Dot": "¨", "DotDot": "⃜", "doteq": "≐", "doteqdot": "≑", "DotEqual": "≐", "dotminus": "∸", "dotplus": "∔", "dotsquare": "⊡", "doublebarwedge": "⌆", "DoubleContourIntegral": "∯", "DoubleDot": "¨", "DoubleDownArrow": "⇓", "DoubleLeftArrow": "⇐", "DoubleLeftRightArrow": "⇔", "DoubleLeftTee": "⫤", "DoubleLongLeftArrow": "⟸", "DoubleLongLeftRightArrow": "⟺", "DoubleLongRightArrow": "⟹", "DoubleRightArrow": "⇒", "DoubleRightTee": "⊨", "DoubleUpArrow": "⇑", "DoubleUpDownArrow": "⇕", "DoubleVerticalBar": "∥", "downarrow": "↓", "Downarrow": "⇓", "DownArrow": "↓", "DownArrowBar": "⤓", "DownArrowUpArrow": "⇵", "DownBreve": "̑", "downdownarrows": "⇊", "downharpoonleft": "⇃", "downharpoonright": "⇂", "DownLeftRightVector": "⥐", "DownLeftTeeVector": "⥞", "DownLeftVector": "↽", "DownLeftVectorBar": "⥖", "DownRightTeeVector": "⥟", "DownRightVector": "⇁", "DownRightVectorBar": "⥗", "DownTee": "⊤", "DownTeeArrow": "↧", "drbkarow": "⤐", "drcorn": "⌟", "drcrop": "⌌", "dscr": "𝒹", "Dscr": "𝒟", "dscy": "ѕ", "DScy": "Ѕ", "dsol": "⧶", "dstrok": "đ", "Dstrok": "Đ", "dtdot": "⋱", "dtri": "▿", "dtrif": "▾", "duarr": "⇵", "duhar": "⥯", "dwangle": "⦦", "dzcy": "џ", "DZcy": "Џ", "dzigrarr": "⟿", "eacute": "é", "Eacute": "É", "easter": "⩮", "ecaron": "ě", "Ecaron": "Ě", "ecir": "≖", "ecirc": "ê", "Ecirc": "Ê", "ecolon": "≕", "ecy": "э", "Ecy": "Э", "eDDot": "⩷", "edot": "ė", "eDot": "≑", "Edot": "Ė", "ee": "ⅇ", "efDot": "≒", "efr": "𝔢", "Efr": "𝔈", "eg": "⪚", "egrave": "è", "Egrave": "È", "egs": "⪖", "egsdot": "⪘", "el": "⪙", "Element": "∈", "elinters": "⏧", "ell": "ℓ", "els": "⪕", "elsdot": "⪗", "emacr": "ē", "Emacr": "Ē", "empty": "∅", "emptyset": "∅", "EmptySmallSquare": "◻", "emptyv": "∅", "EmptyVerySmallSquare": "▫", "emsp": " ", "emsp13": " ", "emsp14": " ", "eng": "ŋ", "ENG": "Ŋ", "ensp": " ", "eogon": "ę", "Eogon": "Ę", "eopf": "𝕖", "Eopf": "𝔼", "epar": "⋕", "eparsl": "⧣", "eplus": "⩱", "epsi": "ε", "epsilon": "ε", "Epsilon": "Ε", "epsiv": "ϵ", "eqcirc": "≖", "eqcolon": "≕", "eqsim": "≂", "eqslantgtr": "⪖", "eqslantless": "⪕", "Equal": "⩵", "equals": "=", "EqualTilde": "≂", "equest": "≟", "Equilibrium": "⇌", "equiv": "≡", "equivDD": "⩸", "eqvparsl": "⧥", "erarr": "⥱", "erDot": "≓", "escr": "ℯ", "Escr": "ℰ", "esdot": "≐", "esim": "≂", "Esim": "⩳", "eta": "η", "Eta": "Η", "eth": "ð", "ETH": "Ð", "euml": "ë", "Euml": "Ë", "euro": "€", "excl": "!", "exist": "∃", "Exists": "∃", "expectation": "ℰ", "exponentiale": "ⅇ", "ExponentialE": "ⅇ", "fallingdotseq": "≒", "fcy": "ф", "Fcy": "Ф", "female": "♀", "ffilig": "ﬃ", "fflig": "ﬀ", "ffllig": "ﬄ", "ffr": "𝔣", "Ffr": "𝔉", "filig": "ﬁ", "FilledSmallSquare": "◼", "FilledVerySmallSquare": "▪", "fjlig": "fj", "flat": "♭", "fllig": "ﬂ", "fltns": "▱", "fnof": "ƒ", "fopf": "𝕗", "Fopf": "𝔽", "forall": "∀", "ForAll": "∀", "fork": "⋔", "forkv": "⫙", "Fouriertrf": "ℱ", "fpartint": "⨍", "frac12": "½", "frac13": "⅓", "frac14": "¼", "frac15": "⅕", "frac16": "⅙", "frac18": "⅛", "frac23": "⅔", "frac25": "⅖", "frac34": "¾", "frac35": "⅗", "frac38": "⅜", "frac45": "⅘", "frac56": "⅚", "frac58": "⅝", "frac78": "⅞", "frasl": "⁄", "frown": "⌢", "fscr": "𝒻", "Fscr": "ℱ", "gacute": "ǵ", "gamma": "γ", "Gamma": "Γ", "gammad": "ϝ", "Gammad": "Ϝ", "gap": "⪆", "gbreve": "ğ", "Gbreve": "Ğ", "Gcedil": "Ģ", "gcirc": "ĝ", "Gcirc": "Ĝ", "gcy": "г", "Gcy": "Г", "gdot": "ġ", "Gdot": "Ġ", "ge": "≥", "gE": "≧", "gel": "⋛", "gEl": "⪌", "geq": "≥", "geqq": "≧", "geqslant": "⩾", "ges": "⩾", "gescc": "⪩", "gesdot": "⪀", "gesdoto": "⪂", "gesdotol": "⪄", "gesl": "⋛︀", "gesles": "⪔", "gfr": "𝔤", "Gfr": "𝔊", "gg": "≫", "Gg": "⋙", "ggg": "⋙", "gimel": "ℷ", "gjcy": "ѓ", "GJcy": "Ѓ", "gl": "≷", "gla": "⪥", "glE": "⪒", "glj": "⪤", "gnap": "⪊", "gnapprox": "⪊", "gne": "⪈", "gnE": "≩", "gneq": "⪈", "gneqq": "≩", "gnsim": "⋧", "gopf": "𝕘", "Gopf": "𝔾", "grave": "`", "GreaterEqual": "≥", "GreaterEqualLess": "⋛", "GreaterFullEqual": "≧", "GreaterGreater": "⪢", "GreaterLess": "≷", "GreaterSlantEqual": "⩾", "GreaterTilde": "≳", "gscr": "ℊ", "Gscr": "𝒢", "gsim": "≳", "gsime": "⪎", "gsiml": "⪐", "gt": ">", "Gt": "≫", "GT": ">", "gtcc": "⪧", "gtcir": "⩺", "gtdot": "⋗", "gtlPar": "⦕", "gtquest": "⩼", "gtrapprox": "⪆", "gtrarr": "⥸", "gtrdot": "⋗", "gtreqless": "⋛", "gtreqqless": "⪌", "gtrless": "≷", "gtrsim": "≳", "gvertneqq": "≩︀", "gvnE": "≩︀", "Hacek": "ˇ", "hairsp": " ", "half": "½", "hamilt": "ℋ", "hardcy": "ъ", "HARDcy": "Ъ", "harr": "↔", "hArr": "⇔", "harrcir": "⥈", "harrw": "↭", "Hat": "^", "hbar": "ℏ", "hcirc": "ĥ", "Hcirc": "Ĥ", "hearts": "♥", "heartsuit": "♥", "hellip": "…", "hercon": "⊹", "hfr": "𝔥", "Hfr": "ℌ", "HilbertSpace": "ℋ", "hksearow": "⤥", "hkswarow": "⤦", "hoarr": "⇿", "homtht": "∻", "hookleftarrow": "↩", "hookrightarrow": "↪", "hopf": "𝕙", "Hopf": "ℍ", "horbar": "―", "HorizontalLine": "─", "hscr": "𝒽", "Hscr": "ℋ", "hslash": "ℏ", "hstrok": "ħ", "Hstrok": "Ħ", "HumpDownHump": "≎", "HumpEqual": "≏", "hybull": "⁃", "hyphen": "‐", "iacute": "í", "Iacute": "Í", "ic": "⁣", "icirc": "î", "Icirc": "Î", "icy": "и", "Icy": "И", "Idot": "İ", "iecy": "е", "IEcy": "Е", "iexcl": "¡", "iff": "⇔", "ifr": "𝔦", "Ifr": "ℑ", "igrave": "ì", "Igrave": "Ì", "ii": "ⅈ", "iiiint": "⨌", "iiint": "∭", "iinfin": "⧜", "iiota": "℩", "ijlig": "ĳ", "IJlig": "Ĳ", "Im": "ℑ", "imacr": "ī", "Imacr": "Ī", "image": "ℑ", "ImaginaryI": "ⅈ", "imagline": "ℐ", "imagpart": "ℑ", "imath": "ı", "imof": "⊷", "imped": "Ƶ", "Implies": "⇒", "in": "∈", "incare": "℅", "infin": "∞", "infintie": "⧝", "inodot": "ı", "int": "∫", "Int": "∬", "intcal": "⊺", "integers": "ℤ", "Integral": "∫", "intercal": "⊺", "Intersection": "⋂", "intlarhk": "⨗", "intprod": "⨼", "InvisibleComma": "⁣", "InvisibleTimes": "⁢", "iocy": "ё", "IOcy": "Ё", "iogon": "į", "Iogon": "Į", "iopf": "𝕚", "Iopf": "𝕀", "iota": "ι", "Iota": "Ι", "iprod": "⨼", "iquest": "¿", "iscr": "𝒾", "Iscr": "ℐ", "isin": "∈", "isindot": "⋵", "isinE": "⋹", "isins": "⋴", "isinsv": "⋳", "isinv": "∈", "it": "⁢", "itilde": "ĩ", "Itilde": "Ĩ", "iukcy": "і", "Iukcy": "І", "iuml": "ï", "Iuml": "Ï", "jcirc": "ĵ", "Jcirc": "Ĵ", "jcy": "й", "Jcy": "Й", "jfr": "𝔧", "Jfr": "𝔍", "jmath": "ȷ", "jopf": "𝕛", "Jopf": "𝕁", "jscr": "𝒿", "Jscr": "𝒥", "jsercy": "ј", "Jsercy": "Ј", "jukcy": "є", "Jukcy": "Є", "kappa": "κ", "Kappa": "Κ", "kappav": "ϰ", "kcedil": "ķ", "Kcedil": "Ķ", "kcy": "к", "Kcy": "К", "kfr": "𝔨", "Kfr": "𝔎", "kgreen": "ĸ", "khcy": "х", "KHcy": "Х", "kjcy": "ќ", "KJcy": "Ќ", "kopf": "𝕜", "Kopf": "𝕂", "kscr": "𝓀", "Kscr": "𝒦", "lAarr": "⇚", "lacute": "ĺ", "Lacute": "Ĺ", "laemptyv": "⦴", "lagran": "ℒ", "lambda": "λ", "Lambda": "Λ", "lang": "⟨", "Lang": "⟪", "langd": "⦑", "langle": "⟨", "lap": "⪅", "Laplacetrf": "ℒ", "laquo": "«", "larr": "←", "lArr": "⇐", "Larr": "↞", "larrb": "⇤", "larrbfs": "⤟", "larrfs": "⤝", "larrhk": "↩", "larrlp": "↫", "larrpl": "⤹", "larrsim": "⥳", "larrtl": "↢", "lat": "⪫", "latail": "⤙", "lAtail": "⤛", "late": "⪭", "lates": "⪭︀", "lbarr": "⤌", "lBarr": "⤎", "lbbrk": "❲", "lbrace": "{", "lbrack": "[", "lbrke": "⦋", "lbrksld": "⦏", "lbrkslu": "⦍", "lcaron": "ľ", "Lcaron": "Ľ", "lcedil": "ļ", "Lcedil": "Ļ", "lceil": "⌈", "lcub": "{", "lcy": "л", "Lcy": "Л", "ldca": "⤶", "ldquo": "“", "ldquor": "„", "ldrdhar": "⥧", "ldrushar": "⥋", "ldsh": "↲", "le": "≤", "lE": "≦", "LeftAngleBracket": "⟨", "leftarrow": "←", "Leftarrow": "⇐", "LeftArrow": "←", "LeftArrowBar": "⇤", "LeftArrowRightArrow": "⇆", "leftarrowtail": "↢", "LeftCeiling": "⌈", "LeftDoubleBracket": "⟦", "LeftDownTeeVector": "⥡", "LeftDownVector": "⇃", "LeftDownVectorBar": "⥙", "LeftFloor": "⌊", "leftharpoondown": "↽", "leftharpoonup": "↼", "leftleftarrows": "⇇", "leftrightarrow": "↔", "Leftrightarrow": "⇔", "LeftRightArrow": "↔", "leftrightarrows": "⇆", "leftrightharpoons": "⇋", "leftrightsquigarrow": "↭", "LeftRightVector": "⥎", "LeftTee": "⊣", "LeftTeeArrow": "↤", "LeftTeeVector": "⥚", "leftthreetimes": "⋋", "LeftTriangle": "⊲", "LeftTriangleBar": "⧏", "LeftTriangleEqual": "⊴", "LeftUpDownVector": "⥑", "LeftUpTeeVector": "⥠", "LeftUpVector": "↿", "LeftUpVectorBar": "⥘", "LeftVector": "↼", "LeftVectorBar": "⥒", "leg": "⋚", "lEg": "⪋", "leq": "≤", "leqq": "≦", "leqslant": "⩽", "les": "⩽", "lescc": "⪨", "lesdot": "⩿", "lesdoto": "⪁", "lesdotor": "⪃", "lesg": "⋚︀", "lesges": "⪓", "lessapprox": "⪅", "lessdot": "⋖", "lesseqgtr": "⋚", "lesseqqgtr": "⪋", "LessEqualGreater": "⋚", "LessFullEqual": "≦", "LessGreater": "≶", "lessgtr": "≶", "LessLess": "⪡", "lesssim": "≲", "LessSlantEqual": "⩽", "LessTilde": "≲", "lfisht": "⥼", "lfloor": "⌊", "lfr": "𝔩", "Lfr": "𝔏", "lg": "≶", "lgE": "⪑", "lHar": "⥢", "lhard": "↽", "lharu": "↼", "lharul": "⥪", "lhblk": "▄", "ljcy": "љ", "LJcy": "Љ", "ll": "≪", "Ll": "⋘", "llarr": "⇇", "llcorner": "⌞", "Lleftarrow": "⇚", "llhard": "⥫", "lltri": "◺", "lmidot": "ŀ", "Lmidot": "Ŀ", "lmoust": "⎰", "lmoustache": "⎰", "lnap": "⪉", "lnapprox": "⪉", "lne": "⪇", "lnE": "≨", "lneq": "⪇", "lneqq": "≨", "lnsim": "⋦", "loang": "⟬", "loarr": "⇽", "lobrk": "⟦", "longleftarrow": "⟵", "Longleftarrow": "⟸", "LongLeftArrow": "⟵", "longleftrightarrow": "⟷", "Longleftrightarrow": "⟺", "LongLeftRightArrow": "⟷", "longmapsto": "⟼", "longrightarrow": "⟶", "Longrightarrow": "⟹", "LongRightArrow": "⟶", "looparrowleft": "↫", "looparrowright": "↬", "lopar": "⦅", "lopf": "𝕝", "Lopf": "𝕃", "loplus": "⨭", "lotimes": "⨴", "lowast": "∗", "lowbar": "_", "LowerLeftArrow": "↙", "LowerRightArrow": "↘", "loz": "◊", "lozenge": "◊", "lozf": "⧫", "lpar": "(", "lparlt": "⦓", "lrarr": "⇆", "lrcorner": "⌟", "lrhar": "⇋", "lrhard": "⥭", "lrm": "‎", "lrtri": "⊿", "lsaquo": "‹", "lscr": "𝓁", "Lscr": "ℒ", "lsh": "↰", "Lsh": "↰", "lsim": "≲", "lsime": "⪍", "lsimg": "⪏", "lsqb": "[", "lsquo": "‘", "lsquor": "‚", "lstrok": "ł", "Lstrok": "Ł", "lt": "<", "Lt": "≪", "LT": "<", "ltcc": "⪦", "ltcir": "⩹", "ltdot": "⋖", "lthree": "⋋", "ltimes": "⋉", "ltlarr": "⥶", "ltquest": "⩻", "ltri": "◃", "ltrie": "⊴", "ltrif": "◂", "ltrPar": "⦖", "lurdshar": "⥊", "luruhar": "⥦", "lvertneqq": "≨︀", "lvnE": "≨︀", "macr": "¯", "male": "♂", "malt": "✠", "maltese": "✠", "map": "↦", "Map": "⤅", "mapsto": "↦", "mapstodown": "↧", "mapstoleft": "↤", "mapstoup": "↥", "marker": "▮", "mcomma": "⨩", "mcy": "м", "Mcy": "М", "mdash": "—", "mDDot": "∺", "measuredangle": "∡", "MediumSpace": " ", "Mellintrf": "ℳ", "mfr": "𝔪", "Mfr": "𝔐", "mho": "℧", "micro": "µ", "mid": "∣", "midast": "*", "midcir": "⫰", "middot": "·", "minus": "−", "minusb": "⊟", "minusd": "∸", "minusdu": "⨪", "MinusPlus": "∓", "mlcp": "⫛", "mldr": "…", "mnplus": "∓", "models": "⊧", "mopf": "𝕞", "Mopf": "𝕄", "mp": "∓", "mscr": "𝓂", "Mscr": "ℳ", "mstpos": "∾", "mu": "μ", "Mu": "Μ", "multimap": "⊸", "mumap": "⊸", "nabla": "∇", "nacute": "ń", "Nacute": "Ń", "nang": "∠⃒", "nap": "≉", "napE": "⩰̸", "napid": "≋̸", "napos": "ŉ", "napprox": "≉", "natur": "♮", "natural": "♮", "naturals": "ℕ", "nbsp": " ", "nbump": "≎̸", "nbumpe": "≏̸", "ncap": "⩃", "ncaron": "ň", "Ncaron": "Ň", "ncedil": "ņ", "Ncedil": "Ņ", "ncong": "≇", "ncongdot": "⩭̸", "ncup": "⩂", "ncy": "н", "Ncy": "Н", "ndash": "–", "ne": "≠", "nearhk": "⤤", "nearr": "↗", "neArr": "⇗", "nearrow": "↗", "nedot": "≐̸", "NegativeMediumSpace": "​", "NegativeThickSpace": "​", "NegativeThinSpace": "​", "NegativeVeryThinSpace": "​", "nequiv": "≢", "nesear": "⤨", "nesim": "≂̸", "NestedGreaterGreater": "≫", "NestedLessLess": "≪", "NewLine": "\n", "nexist": "∄", "nexists": "∄", "nfr": "𝔫", "Nfr": "𝔑", "nge": "≱", "ngE": "≧̸", "ngeq": "≱", "ngeqq": "≧̸", "ngeqslant": "⩾̸", "nges": "⩾̸", "nGg": "⋙̸", "ngsim": "≵", "ngt": "≯", "nGt": "≫⃒", "ngtr": "≯", "nGtv": "≫̸", "nharr": "↮", "nhArr": "⇎", "nhpar": "⫲", "ni": "∋", "nis": "⋼", "nisd": "⋺", "niv": "∋", "njcy": "њ", "NJcy": "Њ", "nlarr": "↚", "nlArr": "⇍", "nldr": "‥", "nle": "≰", "nlE": "≦̸", "nleftarrow": "↚", "nLeftarrow": "⇍", "nleftrightarrow": "↮", "nLeftrightarrow": "⇎", "nleq": "≰", "nleqq": "≦̸", "nleqslant": "⩽̸", "nles": "⩽̸", "nless": "≮", "nLl": "⋘̸", "nlsim": "≴", "nlt": "≮", "nLt": "≪⃒", "nltri": "⋪", "nltrie": "⋬", "nLtv": "≪̸", "nmid": "∤", "NoBreak": "⁠", "NonBreakingSpace": " ", "nopf": "𝕟", "Nopf": "ℕ", "not": "¬", "Not": "⫬", "NotCongruent": "≢", "NotCupCap": "≭", "NotDoubleVerticalBar": "∦", "NotElement": "∉", "NotEqual": "≠", "NotEqualTilde": "≂̸", "NotExists": "∄", "NotGreater": "≯", "NotGreaterEqual": "≱", "NotGreaterFullEqual": "≧̸", "NotGreaterGreater": "≫̸", "NotGreaterLess": "≹", "NotGreaterSlantEqual": "⩾̸", "NotGreaterTilde": "≵", "NotHumpDownHump": "≎̸", "NotHumpEqual": "≏̸", "notin": "∉", "notindot": "⋵̸", "notinE": "⋹̸", "notinva": "∉", "notinvb": "⋷", "notinvc": "⋶", "NotLeftTriangle": "⋪", "NotLeftTriangleBar": "⧏̸", "NotLeftTriangleEqual": "⋬", "NotLess": "≮", "NotLessEqual": "≰", "NotLessGreater": "≸", "NotLessLess": "≪̸", "NotLessSlantEqual": "⩽̸", "NotLessTilde": "≴", "NotNestedGreaterGreater": "⪢̸", "NotNestedLessLess": "⪡̸", "notni": "∌", "notniva": "∌", "notnivb": "⋾", "notnivc": "⋽", "NotPrecedes": "⊀", "NotPrecedesEqual": "⪯̸", "NotPrecedesSlantEqual": "⋠", "NotReverseElement": "∌", "NotRightTriangle": "⋫", "NotRightTriangleBar": "⧐̸", "NotRightTriangleEqual": "⋭", "NotSquareSubset": "⊏̸", "NotSquareSubsetEqual": "⋢", "NotSquareSuperset": "⊐̸", "NotSquareSupersetEqual": "⋣", "NotSubset": "⊂⃒", "NotSubsetEqual": "⊈", "NotSucceeds": "⊁", "NotSucceedsEqual": "⪰̸", "NotSucceedsSlantEqual": "⋡", "NotSucceedsTilde": "≿̸", "NotSuperset": "⊃⃒", "NotSupersetEqual": "⊉", "NotTilde": "≁", "NotTildeEqual": "≄", "NotTildeFullEqual": "≇", "NotTildeTilde": "≉", "NotVerticalBar": "∤", "npar": "∦", "nparallel": "∦", "nparsl": "⫽⃥", "npart": "∂̸", "npolint": "⨔", "npr": "⊀", "nprcue": "⋠", "npre": "⪯̸", "nprec": "⊀", "npreceq": "⪯̸", "nrarr": "↛", "nrArr": "⇏", "nrarrc": "⤳̸", "nrarrw": "↝̸", "nrightarrow": "↛", "nRightarrow": "⇏", "nrtri": "⋫", "nrtrie": "⋭", "nsc": "⊁", "nsccue": "⋡", "nsce": "⪰̸", "nscr": "𝓃", "Nscr": "𝒩", "nshortmid": "∤", "nshortparallel": "∦", "nsim": "≁", "nsime": "≄", "nsimeq": "≄", "nsmid": "∤", "nspar": "∦", "nsqsube": "⋢", "nsqsupe": "⋣", "nsub": "⊄", "nsube": "⊈", "nsubE": "⫅̸", "nsubset": "⊂⃒", "nsubseteq": "⊈", "nsubseteqq": "⫅̸", "nsucc": "⊁", "nsucceq": "⪰̸", "nsup": "⊅", "nsupe": "⊉", "nsupE": "⫆̸", "nsupset": "⊃⃒", "nsupseteq": "⊉", "nsupseteqq": "⫆̸", "ntgl": "≹", "ntilde": "ñ", "Ntilde": "Ñ", "ntlg": "≸", "ntriangleleft": "⋪", "ntrianglelefteq": "⋬", "ntriangleright": "⋫", "ntrianglerighteq": "⋭", "nu": "ν", "Nu": "Ν", "num": "#", "numero": "№", "numsp": " ", "nvap": "≍⃒", "nvdash": "⊬", "nvDash": "⊭", "nVdash": "⊮", "nVDash": "⊯", "nvge": "≥⃒", "nvgt": ">⃒", "nvHarr": "⤄", "nvinfin": "⧞", "nvlArr": "⤂", "nvle": "≤⃒", "nvlt": "<⃒", "nvltrie": "⊴⃒", "nvrArr": "⤃", "nvrtrie": "⊵⃒", "nvsim": "∼⃒", "nwarhk": "⤣", "nwarr": "↖", "nwArr": "⇖", "nwarrow": "↖", "nwnear": "⤧", "oacute": "ó", "Oacute": "Ó", "oast": "⊛", "ocir": "⊚", "ocirc": "ô", "Ocirc": "Ô", "ocy": "о", "Ocy": "О", "odash": "⊝", "odblac": "ő", "Odblac": "Ő", "odiv": "⨸", "odot": "⊙", "odsold": "⦼", "oelig": "œ", "OElig": "Œ", "ofcir": "⦿", "ofr": "𝔬", "Ofr": "𝔒", "ogon": "˛", "ograve": "ò", "Ograve": "Ò", "ogt": "⧁", "ohbar": "⦵", "ohm": "Ω", "oint": "∮", "olarr": "↺", "olcir": "⦾", "olcross": "⦻", "oline": "‾", "olt": "⧀", "omacr": "ō", "Omacr": "Ō", "omega": "ω", "Omega": "Ω", "omicron": "ο", "Omicron": "Ο", "omid": "⦶", "ominus": "⊖", "oopf": "𝕠", "Oopf": "𝕆", "opar": "⦷", "OpenCurlyDoubleQuote": "“", "OpenCurlyQuote": "‘", "operp": "⦹", "oplus": "⊕", "or": "∨", "Or": "⩔", "orarr": "↻", "ord": "⩝", "order": "ℴ", "orderof": "ℴ", "ordf": "ª", "ordm": "º", "origof": "⊶", "oror": "⩖", "orslope": "⩗", "orv": "⩛", "oS": "Ⓢ", "oscr": "ℴ", "Oscr": "𝒪", "oslash": "ø", "Oslash": "Ø", "osol": "⊘", "otilde": "õ", "Otilde": "Õ", "otimes": "⊗", "Otimes": "⨷", "otimesas": "⨶", "ouml": "ö", "Ouml": "Ö", "ovbar": "⌽", "OverBar": "‾", "OverBrace": "⏞", "OverBracket": "⎴", "OverParenthesis": "⏜", "par": "∥", "para": "¶", "parallel": "∥", "parsim": "⫳", "parsl": "⫽", "part": "∂", "PartialD": "∂", "pcy": "п", "Pcy": "П", "percnt": "%", "period": ".", "permil": "‰", "perp": "⊥", "pertenk": "‱", "pfr": "𝔭", "Pfr": "𝔓", "phi": "φ", "Phi": "Φ", "phiv": "ϕ", "phmmat": "ℳ", "phone": "☎", "pi": "π", "Pi": "Π", "pitchfork": "⋔", "piv": "ϖ", "planck": "ℏ", "planckh": "ℎ", "plankv": "ℏ", "plus": "+", "plusacir": "⨣", "plusb": "⊞", "pluscir": "⨢", "plusdo": "∔", "plusdu": "⨥", "pluse": "⩲", "PlusMinus": "±", "plusmn": "±", "plussim": "⨦", "plustwo": "⨧", "pm": "±", "Poincareplane": "ℌ", "pointint": "⨕", "popf": "𝕡", "Popf": "ℙ", "pound": "£", "pr": "≺", "Pr": "⪻", "prap": "⪷", "prcue": "≼", "pre": "⪯", "prE": "⪳", "prec": "≺", "precapprox": "⪷", "preccurlyeq": "≼", "Precedes": "≺", "PrecedesEqual": "⪯", "PrecedesSlantEqual": "≼", "PrecedesTilde": "≾", "preceq": "⪯", "precnapprox": "⪹", "precneqq": "⪵", "precnsim": "⋨", "precsim": "≾", "prime": "′", "Prime": "″", "primes": "ℙ", "prnap": "⪹", "prnE": "⪵", "prnsim": "⋨", "prod": "∏", "Product": "∏", "profalar": "⌮", "profline": "⌒", "profsurf": "⌓", "prop": "∝", "Proportion": "∷", "Proportional": "∝", "propto": "∝", "prsim": "≾", "prurel": "⊰", "pscr": "𝓅", "Pscr": "𝒫", "psi": "ψ", "Psi": "Ψ", "puncsp": " ", "qfr": "𝔮", "Qfr": "𝔔", "qint": "⨌", "qopf": "𝕢", "Qopf": "ℚ", "qprime": "⁗", "qscr": "𝓆", "Qscr": "𝒬", "quaternions": "ℍ", "quatint": "⨖", "quest": "?", "questeq": "≟", "quot": '"', "QUOT": '"', "rAarr": "⇛", "race": "∽̱", "racute": "ŕ", "Racute": "Ŕ", "radic": "√", "raemptyv": "⦳", "rang": "⟩", "Rang": "⟫", "rangd": "⦒", "range": "⦥", "rangle": "⟩", "raquo": "»", "rarr": "→", "rArr": "⇒", "Rarr": "↠", "rarrap": "⥵", "rarrb": "⇥", "rarrbfs": "⤠", "rarrc": "⤳", "rarrfs": "⤞", "rarrhk": "↪", "rarrlp": "↬", "rarrpl": "⥅", "rarrsim": "⥴", "rarrtl": "↣", "Rarrtl": "⤖", "rarrw": "↝", "ratail": "⤚", "rAtail": "⤜", "ratio": "∶", "rationals": "ℚ", "rbarr": "⤍", "rBarr": "⤏", "RBarr": "⤐", "rbbrk": "❳", "rbrace": "}", "rbrack": "]", "rbrke": "⦌", "rbrksld": "⦎", "rbrkslu": "⦐", "rcaron": "ř", "Rcaron": "Ř", "rcedil": "ŗ", "Rcedil": "Ŗ", "rceil": "⌉", "rcub": "}", "rcy": "р", "Rcy": "Р", "rdca": "⤷", "rdldhar": "⥩", "rdquo": "”", "rdquor": "”", "rdsh": "↳", "Re": "ℜ", "real": "ℜ", "realine": "ℛ", "realpart": "ℜ", "reals": "ℝ", "rect": "▭", "reg": "®", "REG": "®", "ReverseElement": "∋", "ReverseEquilibrium": "⇋", "ReverseUpEquilibrium": "⥯", "rfisht": "⥽", "rfloor": "⌋", "rfr": "𝔯", "Rfr": "ℜ", "rHar": "⥤", "rhard": "⇁", "rharu": "⇀", "rharul": "⥬", "rho": "ρ", "Rho": "Ρ", "rhov": "ϱ", "RightAngleBracket": "⟩", "rightarrow": "→", "Rightarrow": "⇒", "RightArrow": "→", "RightArrowBar": "⇥", "RightArrowLeftArrow": "⇄", "rightarrowtail": "↣", "RightCeiling": "⌉", "RightDoubleBracket": "⟧", "RightDownTeeVector": "⥝", "RightDownVector": "⇂", "RightDownVectorBar": "⥕", "RightFloor": "⌋", "rightharpoondown": "⇁", "rightharpoonup": "⇀", "rightleftarrows": "⇄", "rightleftharpoons": "⇌", "rightrightarrows": "⇉", "rightsquigarrow": "↝", "RightTee": "⊢", "RightTeeArrow": "↦", "RightTeeVector": "⥛", "rightthreetimes": "⋌", "RightTriangle": "⊳", "RightTriangleBar": "⧐", "RightTriangleEqual": "⊵", "RightUpDownVector": "⥏", "RightUpTeeVector": "⥜", "RightUpVector": "↾", "RightUpVectorBar": "⥔", "RightVector": "⇀", "RightVectorBar": "⥓", "ring": "˚", "risingdotseq": "≓", "rlarr": "⇄", "rlhar": "⇌", "rlm": "‏", "rmoust": "⎱", "rmoustache": "⎱", "rnmid": "⫮", "roang": "⟭", "roarr": "⇾", "robrk": "⟧", "ropar": "⦆", "ropf": "𝕣", "Ropf": "ℝ", "roplus": "⨮", "rotimes": "⨵", "RoundImplies": "⥰", "rpar": ")", "rpargt": "⦔", "rppolint": "⨒", "rrarr": "⇉", "Rrightarrow": "⇛", "rsaquo": "›", "rscr": "𝓇", "Rscr": "ℛ", "rsh": "↱", "Rsh": "↱", "rsqb": "]", "rsquo": "’", "rsquor": "’", "rthree": "⋌", "rtimes": "⋊", "rtri": "▹", "rtrie": "⊵", "rtrif": "▸", "rtriltri": "⧎", "RuleDelayed": "⧴", "ruluhar": "⥨", "rx": "℞", "sacute": "ś", "Sacute": "Ś", "sbquo": "‚", "sc": "≻", "Sc": "⪼", "scap": "⪸", "scaron": "š", "Scaron": "Š", "sccue": "≽", "sce": "⪰", "scE": "⪴", "scedil": "ş", "Scedil": "Ş", "scirc": "ŝ", "Scirc": "Ŝ", "scnap": "⪺", "scnE": "⪶", "scnsim": "⋩", "scpolint": "⨓", "scsim": "≿", "scy": "с", "Scy": "С", "sdot": "⋅", "sdotb": "⊡", "sdote": "⩦", "searhk": "⤥", "searr": "↘", "seArr": "⇘", "searrow": "↘", "sect": "§", "semi": ";", "seswar": "⤩", "setminus": "∖", "setmn": "∖", "sext": "✶", "sfr": "𝔰", "Sfr": "𝔖", "sfrown": "⌢", "sharp": "♯", "shchcy": "щ", "SHCHcy": "Щ", "shcy": "ш", "SHcy": "Ш", "ShortDownArrow": "↓", "ShortLeftArrow": "←", "shortmid": "∣", "shortparallel": "∥", "ShortRightArrow": "→", "ShortUpArrow": "↑", "shy": "­", "sigma": "σ", "Sigma": "Σ", "sigmaf": "ς", "sigmav": "ς", "sim": "∼", "simdot": "⩪", "sime": "≃", "simeq": "≃", "simg": "⪞", "simgE": "⪠", "siml": "⪝", "simlE": "⪟", "simne": "≆", "simplus": "⨤", "simrarr": "⥲", "slarr": "←", "SmallCircle": "∘", "smallsetminus": "∖", "smashp": "⨳", "smeparsl": "⧤", "smid": "∣", "smile": "⌣", "smt": "⪪", "smte": "⪬", "smtes": "⪬︀", "softcy": "ь", "SOFTcy": "Ь", "sol": "/", "solb": "⧄", "solbar": "⌿", "sopf": "𝕤", "Sopf": "𝕊", "spades": "♠", "spadesuit": "♠", "spar": "∥", "sqcap": "⊓", "sqcaps": "⊓︀", "sqcup": "⊔", "sqcups": "⊔︀", "Sqrt": "√", "sqsub": "⊏", "sqsube": "⊑", "sqsubset": "⊏", "sqsubseteq": "⊑", "sqsup": "⊐", "sqsupe": "⊒", "sqsupset": "⊐", "sqsupseteq": "⊒", "squ": "□", "square": "□", "Square": "□", "SquareIntersection": "⊓", "SquareSubset": "⊏", "SquareSubsetEqual": "⊑", "SquareSuperset": "⊐", "SquareSupersetEqual": "⊒", "SquareUnion": "⊔", "squarf": "▪", "squf": "▪", "srarr": "→", "sscr": "𝓈", "Sscr": "𝒮", "ssetmn": "∖", "ssmile": "⌣", "sstarf": "⋆", "star": "☆", "Star": "⋆", "starf": "★", "straightepsilon": "ϵ", "straightphi": "ϕ", "strns": "¯", "sub": "⊂", "Sub": "⋐", "subdot": "⪽", "sube": "⊆", "subE": "⫅", "subedot": "⫃", "submult": "⫁", "subne": "⊊", "subnE": "⫋", "subplus": "⪿", "subrarr": "⥹", "subset": "⊂", "Subset": "⋐", "subseteq": "⊆", "subseteqq": "⫅", "SubsetEqual": "⊆", "subsetneq": "⊊", "subsetneqq": "⫋", "subsim": "⫇", "subsub": "⫕", "subsup": "⫓", "succ": "≻", "succapprox": "⪸", "succcurlyeq": "≽", "Succeeds": "≻", "SucceedsEqual": "⪰", "SucceedsSlantEqual": "≽", "SucceedsTilde": "≿", "succeq": "⪰", "succnapprox": "⪺", "succneqq": "⪶", "succnsim": "⋩", "succsim": "≿", "SuchThat": "∋", "sum": "∑", "Sum": "∑", "sung": "♪", "sup": "⊃", "Sup": "⋑", "sup1": "¹", "sup2": "²", "sup3": "³", "supdot": "⪾", "supdsub": "⫘", "supe": "⊇", "supE": "⫆", "supedot": "⫄", "Superset": "⊃", "SupersetEqual": "⊇", "suphsol": "⟉", "suphsub": "⫗", "suplarr": "⥻", "supmult": "⫂", "supne": "⊋", "supnE": "⫌", "supplus": "⫀", "supset": "⊃", "Supset": "⋑", "supseteq": "⊇", "supseteqq": "⫆", "supsetneq": "⊋", "supsetneqq": "⫌", "supsim": "⫈", "supsub": "⫔", "supsup": "⫖", "swarhk": "⤦", "swarr": "↙", "swArr": "⇙", "swarrow": "↙", "swnwar": "⤪", "szlig": "ß", "Tab": "	", "target": "⌖", "tau": "τ", "Tau": "Τ", "tbrk": "⎴", "tcaron": "ť", "Tcaron": "Ť", "tcedil": "ţ", "Tcedil": "Ţ", "tcy": "т", "Tcy": "Т", "tdot": "⃛", "telrec": "⌕", "tfr": "𝔱", "Tfr": "𝔗", "there4": "∴", "therefore": "∴", "Therefore": "∴", "theta": "θ", "Theta": "Θ", "thetasym": "ϑ", "thetav": "ϑ", "thickapprox": "≈", "thicksim": "∼", "ThickSpace": "  ", "thinsp": " ", "ThinSpace": " ", "thkap": "≈", "thksim": "∼", "thorn": "þ", "THORN": "Þ", "tilde": "˜", "Tilde": "∼", "TildeEqual": "≃", "TildeFullEqual": "≅", "TildeTilde": "≈", "times": "×", "timesb": "⊠", "timesbar": "⨱", "timesd": "⨰", "tint": "∭", "toea": "⤨", "top": "⊤", "topbot": "⌶", "topcir": "⫱", "topf": "𝕥", "Topf": "𝕋", "topfork": "⫚", "tosa": "⤩", "tprime": "‴", "trade": "™", "TRADE": "™", "triangle": "▵", "triangledown": "▿", "triangleleft": "◃", "trianglelefteq": "⊴", "triangleq": "≜", "triangleright": "▹", "trianglerighteq": "⊵", "tridot": "◬", "trie": "≜", "triminus": "⨺", "TripleDot": "⃛", "triplus": "⨹", "trisb": "⧍", "tritime": "⨻", "trpezium": "⏢", "tscr": "𝓉", "Tscr": "𝒯", "tscy": "ц", "TScy": "Ц", "tshcy": "ћ", "TSHcy": "Ћ", "tstrok": "ŧ", "Tstrok": "Ŧ", "twixt": "≬", "twoheadleftarrow": "↞", "twoheadrightarrow": "↠", "uacute": "ú", "Uacute": "Ú", "uarr": "↑", "uArr": "⇑", "Uarr": "↟", "Uarrocir": "⥉", "ubrcy": "ў", "Ubrcy": "Ў", "ubreve": "ŭ", "Ubreve": "Ŭ", "ucirc": "û", "Ucirc": "Û", "ucy": "у", "Ucy": "У", "udarr": "⇅", "udblac": "ű", "Udblac": "Ű", "udhar": "⥮", "ufisht": "⥾", "ufr": "𝔲", "Ufr": "𝔘", "ugrave": "ù", "Ugrave": "Ù", "uHar": "⥣", "uharl": "↿", "uharr": "↾", "uhblk": "▀", "ulcorn": "⌜", "ulcorner": "⌜", "ulcrop": "⌏", "ultri": "◸", "umacr": "ū", "Umacr": "Ū", "uml": "¨", "UnderBar": "_", "UnderBrace": "⏟", "UnderBracket": "⎵", "UnderParenthesis": "⏝", "Union": "⋃", "UnionPlus": "⊎", "uogon": "ų", "Uogon": "Ų", "uopf": "𝕦", "Uopf": "𝕌", "uparrow": "↑", "Uparrow": "⇑", "UpArrow": "↑", "UpArrowBar": "⤒", "UpArrowDownArrow": "⇅", "updownarrow": "↕", "Updownarrow": "⇕", "UpDownArrow": "↕", "UpEquilibrium": "⥮", "upharpoonleft": "↿", "upharpoonright": "↾", "uplus": "⊎", "UpperLeftArrow": "↖", "UpperRightArrow": "↗", "upsi": "υ", "Upsi": "ϒ", "upsih": "ϒ", "upsilon": "υ", "Upsilon": "Υ", "UpTee": "⊥", "UpTeeArrow": "↥", "upuparrows": "⇈", "urcorn": "⌝", "urcorner": "⌝", "urcrop": "⌎", "uring": "ů", "Uring": "Ů", "urtri": "◹", "uscr": "𝓊", "Uscr": "𝒰", "utdot": "⋰", "utilde": "ũ", "Utilde": "Ũ", "utri": "▵", "utrif": "▴", "uuarr": "⇈", "uuml": "ü", "Uuml": "Ü", "uwangle": "⦧", "vangrt": "⦜", "varepsilon": "ϵ", "varkappa": "ϰ", "varnothing": "∅", "varphi": "ϕ", "varpi": "ϖ", "varpropto": "∝", "varr": "↕", "vArr": "⇕", "varrho": "ϱ", "varsigma": "ς", "varsubsetneq": "⊊︀", "varsubsetneqq": "⫋︀", "varsupsetneq": "⊋︀", "varsupsetneqq": "⫌︀", "vartheta": "ϑ", "vartriangleleft": "⊲", "vartriangleright": "⊳", "vBar": "⫨", "Vbar": "⫫", "vBarv": "⫩", "vcy": "в", "Vcy": "В", "vdash": "⊢", "vDash": "⊨", "Vdash": "⊩", "VDash": "⊫", "Vdashl": "⫦", "vee": "∨", "Vee": "⋁", "veebar": "⊻", "veeeq": "≚", "vellip": "⋮", "verbar": "|", "Verbar": "‖", "vert": "|", "Vert": "‖", "VerticalBar": "∣", "VerticalLine": "|", "VerticalSeparator": "❘", "VerticalTilde": "≀", "VeryThinSpace": " ", "vfr": "𝔳", "Vfr": "𝔙", "vltri": "⊲", "vnsub": "⊂⃒", "vnsup": "⊃⃒", "vopf": "𝕧", "Vopf": "𝕍", "vprop": "∝", "vrtri": "⊳", "vscr": "𝓋", "Vscr": "𝒱", "vsubne": "⊊︀", "vsubnE": "⫋︀", "vsupne": "⊋︀", "vsupnE": "⫌︀", "Vvdash": "⊪", "vzigzag": "⦚", "wcirc": "ŵ", "Wcirc": "Ŵ", "wedbar": "⩟", "wedge": "∧", "Wedge": "⋀", "wedgeq": "≙", "weierp": "℘", "wfr": "𝔴", "Wfr": "𝔚", "wopf": "𝕨", "Wopf": "𝕎", "wp": "℘", "wr": "≀", "wreath": "≀", "wscr": "𝓌", "Wscr": "𝒲", "xcap": "⋂", "xcirc": "◯", "xcup": "⋃", "xdtri": "▽", "xfr": "𝔵", "Xfr": "𝔛", "xharr": "⟷", "xhArr": "⟺", "xi": "ξ", "Xi": "Ξ", "xlarr": "⟵", "xlArr": "⟸", "xmap": "⟼", "xnis": "⋻", "xodot": "⨀", "xopf": "𝕩", "Xopf": "𝕏", "xoplus": "⨁", "xotime": "⨂", "xrarr": "⟶", "xrArr": "⟹", "xscr": "𝓍", "Xscr": "𝒳", "xsqcup": "⨆", "xuplus": "⨄", "xutri": "△", "xvee": "⋁", "xwedge": "⋀", "yacute": "ý", "Yacute": "Ý", "yacy": "я", "YAcy": "Я", "ycirc": "ŷ", "Ycirc": "Ŷ", "ycy": "ы", "Ycy": "Ы", "yen": "¥", "yfr": "𝔶", "Yfr": "𝔜", "yicy": "ї", "YIcy": "Ї", "yopf": "𝕪", "Yopf": "𝕐", "yscr": "𝓎", "Yscr": "𝒴", "yucy": "ю", "YUcy": "Ю", "yuml": "ÿ", "Yuml": "Ÿ", "zacute": "ź", "Zacute": "Ź", "zcaron": "ž", "Zcaron": "Ž", "zcy": "з", "Zcy": "З", "zdot": "ż", "Zdot": "Ż", "zeetrf": "ℨ", "ZeroWidthSpace": "​", "zeta": "ζ", "Zeta": "Ζ", "zfr": "𝔷", "Zfr": "ℨ", "zhcy": "ж", "ZHcy": "Ж", "zigrarr": "⇝", "zopf": "𝕫", "Zopf": "ℤ", "zscr": "𝓏", "Zscr": "𝒵", "zwj": "‍", "zwnj": "‌" };
      var decodeMapLegacy = { "aacute": "á", "Aacute": "Á", "acirc": "â", "Acirc": "Â", "acute": "´", "aelig": "æ", "AElig": "Æ", "agrave": "à", "Agrave": "À", "amp": "&", "AMP": "&", "aring": "å", "Aring": "Å", "atilde": "ã", "Atilde": "Ã", "auml": "ä", "Auml": "Ä", "brvbar": "¦", "ccedil": "ç", "Ccedil": "Ç", "cedil": "¸", "cent": "¢", "copy": "©", "COPY": "©", "curren": "¤", "deg": "°", "divide": "÷", "eacute": "é", "Eacute": "É", "ecirc": "ê", "Ecirc": "Ê", "egrave": "è", "Egrave": "È", "eth": "ð", "ETH": "Ð", "euml": "ë", "Euml": "Ë", "frac12": "½", "frac14": "¼", "frac34": "¾", "gt": ">", "GT": ">", "iacute": "í", "Iacute": "Í", "icirc": "î", "Icirc": "Î", "iexcl": "¡", "igrave": "ì", "Igrave": "Ì", "iquest": "¿", "iuml": "ï", "Iuml": "Ï", "laquo": "«", "lt": "<", "LT": "<", "macr": "¯", "micro": "µ", "middot": "·", "nbsp": " ", "not": "¬", "ntilde": "ñ", "Ntilde": "Ñ", "oacute": "ó", "Oacute": "Ó", "ocirc": "ô", "Ocirc": "Ô", "ograve": "ò", "Ograve": "Ò", "ordf": "ª", "ordm": "º", "oslash": "ø", "Oslash": "Ø", "otilde": "õ", "Otilde": "Õ", "ouml": "ö", "Ouml": "Ö", "para": "¶", "plusmn": "±", "pound": "£", "quot": '"', "QUOT": '"', "raquo": "»", "reg": "®", "REG": "®", "sect": "§", "shy": "­", "sup1": "¹", "sup2": "²", "sup3": "³", "szlig": "ß", "thorn": "þ", "THORN": "Þ", "times": "×", "uacute": "ú", "Uacute": "Ú", "ucirc": "û", "Ucirc": "Û", "ugrave": "ù", "Ugrave": "Ù", "uml": "¨", "uuml": "ü", "Uuml": "Ü", "yacute": "ý", "Yacute": "Ý", "yen": "¥", "yuml": "ÿ" };
      var decodeMapNumeric = { "0": "�", "128": "€", "130": "‚", "131": "ƒ", "132": "„", "133": "…", "134": "†", "135": "‡", "136": "ˆ", "137": "‰", "138": "Š", "139": "‹", "140": "Œ", "142": "Ž", "145": "‘", "146": "’", "147": "“", "148": "”", "149": "•", "150": "–", "151": "—", "152": "˜", "153": "™", "154": "š", "155": "›", "156": "œ", "158": "ž", "159": "Ÿ" };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty4 = object.hasOwnProperty;
      var has = function(object2, propertyName) {
        return hasOwnProperty4.call(object2, propertyName);
      };
      var contains = function(array, value) {
        var index2 = -1;
        var length = array.length;
        while (++index2 < length) {
          if (array[index2] == value) {
            return true;
          }
        }
        return false;
      };
      var merge2 = function(options, defaults2) {
        if (!options) {
          return defaults2;
        }
        var result = {};
        var key3;
        for (key3 in defaults2) {
          result[key3] = has(options, key3) ? options[key3] : defaults2[key3];
        }
        return result;
      };
      var codePointToSymbol = function(codePoint, strict) {
        var output = "";
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          if (strict) {
            parseError("character reference outside the permissible Unicode range");
          }
          return "�";
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError("disallowed character reference");
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError("disallowed character reference");
        }
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function(codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      };
      var decEscape = function(codePoint) {
        return "&#" + codePoint + ";";
      };
      var parseError = function(message) {
        throw Error("Parse error: " + message);
      };
      var encode2 = function(string4, options) {
        options = merge2(options, encode2.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string4)) {
          parseError("forbidden code point");
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function(symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
          string4 = string4.replace(regexAsciiWhitelist, function(symbol) {
            if (useNamedReferences && has(encodeMap, symbol)) {
              return "&" + encodeMap[symbol] + ";";
            }
            return escapeBmpSymbol(symbol);
          });
          if (useNamedReferences) {
            string4 = string4.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
          }
          if (useNamedReferences) {
            string4 = string4.replace(regexEncodeNonAscii, function(string5) {
              return "&" + encodeMap[string5] + ";";
            });
          }
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) {
            string4 = string4.replace(regexEscape, function(string5) {
              return "&" + encodeMap[string5] + ";";
            });
          }
          string4 = string4.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
          string4 = string4.replace(regexEncodeNonAscii, function(string5) {
            return "&" + encodeMap[string5] + ";";
          });
        } else if (!allowUnsafeSymbols) {
          string4 = string4.replace(regexEscape, escapeBmpSymbol);
        }
        return string4.replace(regexAstralSymbols, function($0) {
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
          return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      encode2.options = {
        "allowUnsafeSymbols": false,
        "encodeEverything": false,
        "strict": false,
        "useNamedReferences": false,
        "decimal": false
      };
      var decode2 = function(html7, options) {
        options = merge2(options, decode2.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html7)) {
          parseError("malformed character reference");
        }
        return html7.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;
          if ($1) {
            reference = $1;
            return decodeMap[reference];
          }
          if ($2) {
            reference = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == "=") {
                parseError("`&` did not start a character reference");
              }
              return $0;
            } else {
              if (strict) {
                parseError(
                  "named character reference was not terminated by a semicolon"
                );
              }
              return decodeMapLegacy[reference] + (next || "");
            }
          }
          if ($4) {
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }
          if (strict) {
            parseError(
              "named character reference was not terminated by a semicolon"
            );
          }
          return $0;
        });
      };
      decode2.options = {
        "isAttributeValue": false,
        "strict": false
      };
      var escape = function(string4) {
        return string4.replace(regexEscape, function($0) {
          return escapeMap[$0];
        });
      };
      var he = {
        "version": "1.2.0",
        "encode": encode2,
        "decode": decode2,
        "escape": escape,
        "unescape": decode2
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define(function() {
          return he;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = he;
        } else {
          for (var key2 in he) {
            has(he, key2) && (freeExports[key2] = he[key2]);
          }
        }
      } else {
        root4.he = he;
      }
    })(exports);
  }
});

// node_modules/@vue/compiler-vue2/build.js
var require_build = __commonJS({
  "node_modules/@vue/compiler-vue2/build.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var deindent = require_de_indent();
    var he = require_he();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var deindent__default = _interopDefaultLegacy(deindent);
    var he__default = _interopDefaultLegacy(he);
    var emptyObject = Object.freeze({});
    var isArray2 = Array.isArray;
    function isUndef(v) {
      return v === void 0 || v === null;
    }
    function isDef(v) {
      return v !== void 0 && v !== null;
    }
    function isTrue(v) {
      return v === true;
    }
    function isFalse(v) {
      return v === false;
    }
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || // $flow-disable-line
      typeof value === "symbol" || typeof value === "boolean";
    }
    function isFunction2(value) {
      return typeof value === "function";
    }
    function isObject2(obj) {
      return obj !== null && typeof obj === "object";
    }
    var _toString = Object.prototype.toString;
    function toRawType2(value) {
      return _toString.call(value).slice(8, -1);
    }
    function isPlainObject2(obj) {
      return _toString.call(obj) === "[object Object]";
    }
    function isValidArrayIndex(val) {
      const n = parseFloat(String(val));
      return n >= 0 && Math.floor(n) === n && isFinite(val);
    }
    function isPromise2(val) {
      return isDef(val) && typeof val.then === "function" && typeof val.catch === "function";
    }
    function toString3(val) {
      return val == null ? "" : Array.isArray(val) || isPlainObject2(val) && val.toString === _toString ? JSON.stringify(val, replacer2, 2) : String(val);
    }
    function replacer2(_key, val) {
      if (val && val.__v_isRef) {
        return val.value;
      }
      return val;
    }
    function toNumber2(val) {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    }
    function makeMap2(str2, expectsLowerCase) {
      const map = /* @__PURE__ */ Object.create(null);
      const list4 = str2.split(",");
      for (let i = 0; i < list4.length; i++) {
        map[list4[i]] = true;
      }
      return expectsLowerCase ? (val) => map[val.toLowerCase()] : (val) => map[val];
    }
    var isBuiltInTag = makeMap2("slot,component", true);
    var isReservedAttribute = makeMap2("key,ref,slot,slot-scope,is");
    var hasOwnProperty4 = Object.prototype.hasOwnProperty;
    function hasOwn2(obj, key2) {
      return hasOwnProperty4.call(obj, key2);
    }
    function cached(fn) {
      const cache = /* @__PURE__ */ Object.create(null);
      return function cachedFn(str2) {
        const hit = cache[str2];
        return hit || (cache[str2] = fn(str2));
      };
    }
    var camelizeRE2 = /-(\w)/g;
    var camelize2 = cached((str2) => {
      return str2.replace(camelizeRE2, (_, c) => c ? c.toUpperCase() : "");
    });
    var capitalize2 = cached((str2) => {
      return str2.charAt(0).toUpperCase() + str2.slice(1);
    });
    var hyphenateRE2 = /\B([A-Z])/g;
    var hyphenate2 = cached((str2) => {
      return str2.replace(hyphenateRE2, "-$1").toLowerCase();
    });
    function extend3(to, _from) {
      for (const key2 in _from) {
        to[key2] = _from[key2];
      }
      return to;
    }
    function toObject(arr) {
      const res = {};
      for (let i = 0; i < arr.length; i++) {
        if (arr[i]) {
          extend3(res, arr[i]);
        }
      }
      return res;
    }
    function noop(a, b, c) {
    }
    var no = (a, b, c) => false;
    var identity = (_) => _;
    function genStaticKeys$1(modules2) {
      return modules2.reduce((keys2, m) => keys2.concat(m.staticKeys || []), []).join(",");
    }
    function looseEqual2(a, b) {
      if (a === b)
        return true;
      const isObjectA = isObject2(a);
      const isObjectB = isObject2(b);
      if (isObjectA && isObjectB) {
        try {
          const isArrayA = Array.isArray(a);
          const isArrayB = Array.isArray(b);
          if (isArrayA && isArrayB) {
            return a.length === b.length && a.every((e, i) => {
              return looseEqual2(e, b[i]);
            });
          } else if (a instanceof Date && b instanceof Date) {
            return a.getTime() === b.getTime();
          } else if (!isArrayA && !isArrayB) {
            const keysA = Object.keys(a);
            const keysB = Object.keys(b);
            return keysA.length === keysB.length && keysA.every((key2) => {
              return looseEqual2(a[key2], b[key2]);
            });
          } else {
            return false;
          }
        } catch (e) {
          return false;
        }
      } else if (!isObjectA && !isObjectB) {
        return String(a) === String(b);
      } else {
        return false;
      }
    }
    function looseIndexOf2(arr, val) {
      for (let i = 0; i < arr.length; i++) {
        if (looseEqual2(arr[i], val))
          return i;
      }
      return -1;
    }
    function hasChanged2(x, y) {
      if (x === y) {
        return x === 0 && 1 / x !== 1 / y;
      } else {
        return x === x || y === y;
      }
    }
    var isUnaryTag = makeMap2("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr");
    var canBeLeftOpenTag = makeMap2("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source");
    var isNonPhrasingTag = makeMap2("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track");
    var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
    function def2(obj, key2, val, enumerable) {
      Object.defineProperty(obj, key2, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true
      });
    }
    var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
    var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
    var ncname = `[a-zA-Z_][\\-\\.0-9_a-zA-Z${unicodeRegExp.source}]*`;
    var qnameCapture = `((?:${ncname}\\:)?${ncname})`;
    var startTagOpen = new RegExp(`^<${qnameCapture}`);
    var startTagClose = /^\s*(\/?)>/;
    var endTag = new RegExp(`^<\\/${qnameCapture}[^>]*>`);
    var doctype2 = /^<!DOCTYPE [^>]+>/i;
    var comment2 = /^<!\--/;
    var conditionalComment = /^<!\[/;
    var isPlainTextElement = makeMap2("script,style,textarea", true);
    var reCache = {};
    var decodingMap = {
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&amp;": "&",
      "&#10;": "\n",
      "&#9;": "	",
      "&#39;": "'"
    };
    var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
    var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;
    var isIgnoreNewlineTag = makeMap2("pre,textarea", true);
    var shouldIgnoreFirstNewline = (tag, html8) => tag && isIgnoreNewlineTag(tag) && html8[0] === "\n";
    function decodeAttr(value, shouldDecodeNewlines) {
      const re2 = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
      return value.replace(re2, (match) => decodingMap[match]);
    }
    function parseHTML(html8, options) {
      const stack2 = [];
      const expectHTML = options.expectHTML;
      const isUnaryTag2 = options.isUnaryTag || no;
      const canBeLeftOpenTag2 = options.canBeLeftOpenTag || no;
      let index3 = 0;
      let last, lastTag;
      while (html8) {
        last = html8;
        if (!lastTag || !isPlainTextElement(lastTag)) {
          let textEnd = html8.indexOf("<");
          if (textEnd === 0) {
            if (comment2.test(html8)) {
              const commentEnd = html8.indexOf("-->");
              if (commentEnd >= 0) {
                if (options.shouldKeepComment && options.comment) {
                  options.comment(html8.substring(4, commentEnd), index3, index3 + commentEnd + 3);
                }
                advance(commentEnd + 3);
                continue;
              }
            }
            if (conditionalComment.test(html8)) {
              const conditionalEnd = html8.indexOf("]>");
              if (conditionalEnd >= 0) {
                advance(conditionalEnd + 2);
                continue;
              }
            }
            const doctypeMatch = html8.match(doctype2);
            if (doctypeMatch) {
              advance(doctypeMatch[0].length);
              continue;
            }
            const endTagMatch = html8.match(endTag);
            if (endTagMatch) {
              const curIndex = index3;
              advance(endTagMatch[0].length);
              parseEndTag(endTagMatch[1], curIndex, index3);
              continue;
            }
            const startTagMatch = parseStartTag();
            if (startTagMatch) {
              handleStartTag(startTagMatch);
              if (shouldIgnoreFirstNewline(startTagMatch.tagName, html8)) {
                advance(1);
              }
              continue;
            }
          }
          let text7, rest, next2;
          if (textEnd >= 0) {
            rest = html8.slice(textEnd);
            while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment2.test(rest) && !conditionalComment.test(rest)) {
              next2 = rest.indexOf("<", 1);
              if (next2 < 0)
                break;
              textEnd += next2;
              rest = html8.slice(textEnd);
            }
            text7 = html8.substring(0, textEnd);
          }
          if (textEnd < 0) {
            text7 = html8;
          }
          if (text7) {
            advance(text7.length);
          }
          if (options.chars && text7) {
            options.chars(text7, index3 - text7.length, index3);
          }
        } else {
          let endTagLength = 0;
          const stackedTag = lastTag.toLowerCase();
          const reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp("([\\s\\S]*?)(</" + stackedTag + "[^>]*>)", "i"));
          const rest = html8.replace(reStackedTag, function(all3, text7, endTag2) {
            endTagLength = endTag2.length;
            if (!isPlainTextElement(stackedTag) && stackedTag !== "noscript") {
              text7 = text7.replace(/<!\--([\s\S]*?)-->/g, "$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1");
            }
            if (shouldIgnoreFirstNewline(stackedTag, text7)) {
              text7 = text7.slice(1);
            }
            if (options.chars) {
              options.chars(text7);
            }
            return "";
          });
          index3 += html8.length - rest.length;
          html8 = rest;
          parseEndTag(stackedTag, index3 - endTagLength, index3);
        }
        if (html8 === last) {
          options.chars && options.chars(html8);
          if (!stack2.length && options.warn) {
            options.warn(`Mal-formatted tag at end of template: "${html8}"`, {
              start: index3 + html8.length
            });
          }
          break;
        }
      }
      parseEndTag();
      function advance(n) {
        index3 += n;
        html8 = html8.substring(n);
      }
      function parseStartTag() {
        const start = html8.match(startTagOpen);
        if (start) {
          const match = {
            tagName: start[1],
            attrs: [],
            start: index3
          };
          advance(start[0].length);
          let end, attr;
          while (!(end = html8.match(startTagClose)) && (attr = html8.match(dynamicArgAttribute) || html8.match(attribute))) {
            attr.start = index3;
            advance(attr[0].length);
            attr.end = index3;
            match.attrs.push(attr);
          }
          if (end) {
            match.unarySlash = end[1];
            advance(end[0].length);
            match.end = index3;
            return match;
          }
        }
      }
      function handleStartTag(match) {
        const tagName = match.tagName;
        const unarySlash = match.unarySlash;
        if (expectHTML) {
          if (lastTag === "p" && isNonPhrasingTag(tagName)) {
            parseEndTag(lastTag);
          }
          if (canBeLeftOpenTag2(tagName) && lastTag === tagName) {
            parseEndTag(tagName);
          }
        }
        const unary = isUnaryTag2(tagName) || !!unarySlash;
        const l = match.attrs.length;
        const attrs = new Array(l);
        for (let i = 0; i < l; i++) {
          const args = match.attrs[i];
          const value = args[3] || args[4] || args[5] || "";
          const shouldDecodeNewlines = tagName === "a" && args[1] === "href" ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
          attrs[i] = {
            name: args[1],
            value: decodeAttr(value, shouldDecodeNewlines)
          };
          if (options.outputSourceRange) {
            attrs[i].start = args.start + args[0].match(/^\s*/).length;
            attrs[i].end = args.end;
          }
        }
        if (!unary) {
          stack2.push({
            tag: tagName,
            lowerCasedTag: tagName.toLowerCase(),
            attrs,
            start: match.start,
            end: match.end
          });
          lastTag = tagName;
        }
        if (options.start) {
          options.start(tagName, attrs, unary, match.start, match.end);
        }
      }
      function parseEndTag(tagName, start, end) {
        let pos, lowerCasedTagName;
        if (start == null)
          start = index3;
        if (end == null)
          end = index3;
        if (tagName) {
          lowerCasedTagName = tagName.toLowerCase();
          for (pos = stack2.length - 1; pos >= 0; pos--) {
            if (stack2[pos].lowerCasedTag === lowerCasedTagName) {
              break;
            }
          }
        } else {
          pos = 0;
        }
        if (pos >= 0) {
          for (let i = stack2.length - 1; i >= pos; i--) {
            if ((i > pos || !tagName) && options.warn) {
              options.warn(`tag <${stack2[i].tag}> has no matching end tag.`, {
                start: stack2[i].start,
                end: stack2[i].end
              });
            }
            if (options.end) {
              options.end(stack2[i].tag, start, end);
            }
          }
          stack2.length = pos;
          lastTag = pos && stack2[pos - 1].tag;
        } else if (lowerCasedTagName === "br") {
          if (options.start) {
            options.start(tagName, [], true, start, end);
          }
        } else if (lowerCasedTagName === "p") {
          if (options.start) {
            options.start(tagName, [], false, start, end);
          }
          if (options.end) {
            options.end(tagName, start, end);
          }
        }
      }
    }
    var DEFAULT_FILENAME = "anonymous.vue";
    var splitRE = /\r?\n/g;
    var replaceRE = /./g;
    var isSpecialTag = makeMap2("script,style,template", true);
    function parseComponent(source, options = {}) {
      const sfc = {
        source,
        filename: DEFAULT_FILENAME,
        template: null,
        script: null,
        scriptSetup: null,
        styles: [],
        customBlocks: [],
        cssVars: [],
        errors: [],
        shouldForceReload: null
        // attached in parse() by compiler-sfc
      };
      let depth = 0;
      let currentBlock = null;
      let warn3 = (msg) => {
        sfc.errors.push(msg);
      };
      if (options.outputSourceRange) {
        warn3 = (msg, range4) => {
          const data = { msg };
          if (range4.start != null) {
            data.start = range4.start;
          }
          if (range4.end != null) {
            data.end = range4.end;
          }
          sfc.errors.push(data);
        };
      }
      function start(tag, attrs, unary, start2, end2) {
        if (depth === 0) {
          currentBlock = {
            type: tag,
            content: "",
            start: end2,
            end: 0,
            attrs: attrs.reduce((cumulated, { name, value }) => {
              cumulated[name] = value || true;
              return cumulated;
            }, {})
          };
          if (typeof currentBlock.attrs.src === "string") {
            currentBlock.src = currentBlock.attrs.src;
          }
          if (isSpecialTag(tag)) {
            checkAttrs(currentBlock, attrs);
            if (tag === "script") {
              const block = currentBlock;
              if (block.attrs.setup) {
                block.setup = currentBlock.attrs.setup;
                sfc.scriptSetup = block;
              } else {
                sfc.script = block;
              }
            } else if (tag === "style") {
              sfc.styles.push(currentBlock);
            } else {
              sfc[tag] = currentBlock;
            }
          } else {
            sfc.customBlocks.push(currentBlock);
          }
        }
        if (!unary) {
          depth++;
        }
      }
      function checkAttrs(block, attrs) {
        for (let i = 0; i < attrs.length; i++) {
          const attr = attrs[i];
          if (attr.name === "lang") {
            block.lang = attr.value;
          }
          if (attr.name === "scoped") {
            block.scoped = true;
          }
          if (attr.name === "module") {
            block.module = attr.value || true;
          }
        }
      }
      function end(tag, start2) {
        if (depth === 1 && currentBlock) {
          currentBlock.end = start2;
          let text7 = source.slice(currentBlock.start, currentBlock.end);
          if (options.deindent === true || // by default, deindent unless it's script with default lang or (j/t)sx?
          options.deindent !== false && !(currentBlock.type === "script" && (!currentBlock.lang || /^(j|t)sx?$/.test(currentBlock.lang)))) {
            text7 = deindent__default["default"](text7);
          }
          if (currentBlock.type !== "template" && options.pad) {
            text7 = padContent(currentBlock, options.pad) + text7;
          }
          currentBlock.content = text7;
          currentBlock = null;
        }
        depth--;
      }
      function padContent(block, pad) {
        if (pad === "space") {
          return source.slice(0, block.start).replace(replaceRE, " ");
        } else {
          const offset = source.slice(0, block.start).split(splitRE).length;
          const padChar = block.type === "script" && !block.lang ? "//\n" : "\n";
          return Array(offset).join(padChar);
        }
      }
      parseHTML(source, {
        warn: warn3,
        start,
        end,
        outputSourceRange: options.outputSourceRange
      });
      return sfc;
    }
    var hasProto = "__proto__" in {};
    var inBrowser = typeof window !== "undefined";
    var UA = inBrowser && window.navigator.userAgent.toLowerCase();
    var isIE = UA && /msie|trident/.test(UA);
    UA && UA.indexOf("msie 9.0") > 0;
    var isEdge = UA && UA.indexOf("edge/") > 0;
    UA && UA.indexOf("android") > 0;
    UA && /iphone|ipad|ipod|ios/.test(UA);
    UA && /chrome\/\d+/.test(UA) && !isEdge;
    UA && /phantomjs/.test(UA);
    UA && UA.match(/firefox\/(\d+)/);
    var nativeWatch = {}.watch;
    var supportsPassive = false;
    if (inBrowser) {
      try {
        const opts = {};
        Object.defineProperty(opts, "passive", {
          get() {
            supportsPassive = true;
          }
        });
        window.addEventListener("test-passive", null, opts);
      } catch (e) {
      }
    }
    var _isServer;
    var isServerRendering = () => {
      if (_isServer === void 0) {
        if (!inBrowser && typeof global !== "undefined") {
          _isServer = global["process"] && global["process"].env.VUE_ENV === "server";
        } else {
          _isServer = false;
        }
      }
      return _isServer;
    };
    function isNative(Ctor) {
      return typeof Ctor === "function" && /native code/.test(Ctor.toString());
    }
    var hasSymbol = typeof Symbol !== "undefined" && isNative(Symbol) && typeof Reflect !== "undefined" && isNative(Reflect.ownKeys);
    var _Set;
    if (typeof Set !== "undefined" && isNative(Set)) {
      _Set = Set;
    } else {
      _Set = class Set {
        constructor() {
          this.set = /* @__PURE__ */ Object.create(null);
        }
        has(key2) {
          return this.set[key2] === true;
        }
        add(key2) {
          this.set[key2] = true;
        }
        clear() {
          this.set = /* @__PURE__ */ Object.create(null);
        }
      };
    }
    var ASSET_TYPES = ["component", "directive", "filter"];
    var LIFECYCLE_HOOKS = [
      "beforeCreate",
      "created",
      "beforeMount",
      "mounted",
      "beforeUpdate",
      "updated",
      "beforeDestroy",
      "destroyed",
      "activated",
      "deactivated",
      "errorCaptured",
      "serverPrefetch",
      "renderTracked",
      "renderTriggered"
    ];
    var config = {
      /**
       * Option merge strategies (used in core/util/options)
       */
      // $flow-disable-line
      optionMergeStrategies: /* @__PURE__ */ Object.create(null),
      /**
       * Whether to suppress warnings.
       */
      silent: false,
      /**
       * Show production mode tip message on boot?
       */
      productionTip: true,
      /**
       * Whether to enable devtools
       */
      devtools: true,
      /**
       * Whether to record perf
       */
      performance: false,
      /**
       * Error handler for watcher errors
       */
      errorHandler: null,
      /**
       * Warn handler for watcher warns
       */
      warnHandler: null,
      /**
       * Ignore certain custom elements
       */
      ignoredElements: [],
      /**
       * Custom user key aliases for v-on
       */
      // $flow-disable-line
      keyCodes: /* @__PURE__ */ Object.create(null),
      /**
       * Check if a tag is reserved so that it cannot be registered as a
       * component. This is platform-dependent and may be overwritten.
       */
      isReservedTag: no,
      /**
       * Check if an attribute is reserved so that it cannot be used as a component
       * prop. This is platform-dependent and may be overwritten.
       */
      isReservedAttr: no,
      /**
       * Check if a tag is an unknown element.
       * Platform-dependent.
       */
      isUnknownElement: no,
      /**
       * Get the namespace of an element
       */
      getTagNamespace: noop,
      /**
       * Parse the real tag name for the specific platform.
       */
      parsePlatformTagName: identity,
      /**
       * Check if an attribute must be bound using property, e.g. value
       * Platform-dependent.
       */
      mustUseProp: no,
      /**
       * Perform updates asynchronously. Intended to be used by Vue Test Utils
       * This will significantly reduce performance if set to false.
       */
      async: true,
      /**
       * Exposed for legacy reasons
       */
      _lifecycleHooks: LIFECYCLE_HOOKS
    };
    var currentInstance = null;
    function setCurrentInstance(vm = null) {
      if (!vm)
        currentInstance && currentInstance._scope.off();
      currentInstance = vm;
      vm && vm._scope.on();
    }
    var VNode = class {
      constructor(tag, data, children, text7, elm, context, componentOptions, asyncFactory) {
        this.tag = tag;
        this.data = data;
        this.children = children;
        this.text = text7;
        this.elm = elm;
        this.ns = void 0;
        this.context = context;
        this.fnContext = void 0;
        this.fnOptions = void 0;
        this.fnScopeId = void 0;
        this.key = data && data.key;
        this.componentOptions = componentOptions;
        this.componentInstance = void 0;
        this.parent = void 0;
        this.raw = false;
        this.isStatic = false;
        this.isRootInsert = true;
        this.isComment = false;
        this.isCloned = false;
        this.isOnce = false;
        this.asyncFactory = asyncFactory;
        this.asyncMeta = void 0;
        this.isAsyncPlaceholder = false;
      }
      // DEPRECATED: alias for componentInstance for backwards compat.
      /* istanbul ignore next */
      get child() {
        return this.componentInstance;
      }
    };
    var createEmptyVNode = (text7 = "") => {
      const node2 = new VNode();
      node2.text = text7;
      node2.isComment = true;
      return node2;
    };
    function createTextVNode(val) {
      return new VNode(void 0, void 0, void 0, String(val));
    }
    function cloneVNode(vnode) {
      const cloned = new VNode(
        vnode.tag,
        vnode.data,
        // #7975
        // clone children array to avoid mutating original in case of cloning
        // a child.
        vnode.children && vnode.children.slice(),
        vnode.text,
        vnode.elm,
        vnode.context,
        vnode.componentOptions,
        vnode.asyncFactory
      );
      cloned.ns = vnode.ns;
      cloned.isStatic = vnode.isStatic;
      cloned.key = vnode.key;
      cloned.isComment = vnode.isComment;
      cloned.fnContext = vnode.fnContext;
      cloned.fnOptions = vnode.fnOptions;
      cloned.fnScopeId = vnode.fnScopeId;
      cloned.asyncMeta = vnode.asyncMeta;
      cloned.isCloned = true;
      return cloned;
    }
    if (true) {
      makeMap2(
        "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,require"
        // for Webpack/Browserify
      );
      const hasProxy = typeof Proxy !== "undefined" && isNative(Proxy);
      if (hasProxy) {
        const isBuiltInModifier = makeMap2("stop,prevent,self,ctrl,shift,alt,meta,exact");
        config.keyCodes = new Proxy(config.keyCodes, {
          set(target2, key2, value) {
            if (isBuiltInModifier(key2)) {
              warn$2(`Avoid overwriting built-in modifier in config.keyCodes: .${key2}`);
              return false;
            } else {
              target2[key2] = value;
              return true;
            }
          }
        });
      }
    }
    var uid = 0;
    var Dep = class _Dep {
      constructor() {
        this._pending = false;
        this.id = uid++;
        this.subs = [];
      }
      addSub(sub) {
        this.subs.push(sub);
      }
      removeSub(sub) {
        this.subs[this.subs.indexOf(sub)] = null;
        if (!this._pending) {
          this._pending = true;
        }
      }
      depend(info) {
        if (_Dep.target) {
          _Dep.target.addDep(this);
          if (info && _Dep.target.onTrack) {
            _Dep.target.onTrack(Object.assign({ effect: _Dep.target }, info));
          }
        }
      }
      notify(info) {
        const subs = this.subs.filter((s) => s);
        if (!config.async) {
          subs.sort((a, b) => a.id - b.id);
        }
        for (let i = 0, l = subs.length; i < l; i++) {
          const sub = subs[i];
          if (info) {
            sub.onTrigger && sub.onTrigger(Object.assign({ effect: subs[i] }, info));
          }
          sub.update();
        }
      }
    };
    Dep.target = null;
    var targetStack = [];
    function pushTarget(target2) {
      targetStack.push(target2);
      Dep.target = target2;
    }
    function popTarget() {
      targetStack.pop();
      Dep.target = targetStack[targetStack.length - 1];
    }
    var arrayProto = Array.prototype;
    var arrayMethods = Object.create(arrayProto);
    var methodsToPatch = [
      "push",
      "pop",
      "shift",
      "unshift",
      "splice",
      "sort",
      "reverse"
    ];
    methodsToPatch.forEach(function(method2) {
      const original = arrayProto[method2];
      def2(arrayMethods, method2, function mutator(...args) {
        const result = original.apply(this, args);
        const ob = this.__ob__;
        let inserted;
        switch (method2) {
          case "push":
          case "unshift":
            inserted = args;
            break;
          case "splice":
            inserted = args.slice(2);
            break;
        }
        if (inserted)
          ob.observeArray(inserted);
        if (true) {
          ob.dep.notify({
            type: "array mutation",
            target: this,
            key: method2
          });
        } else {
          ob.dep.notify();
        }
        return result;
      });
    });
    var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
    var NO_INITIAL_VALUE = {};
    var shouldObserve = true;
    function toggleObserving(value) {
      shouldObserve = value;
    }
    var mockDep = {
      notify: noop,
      depend: noop,
      addSub: noop,
      removeSub: noop
    };
    var Observer = class {
      constructor(value, shallow = false, mock = false) {
        this.value = value;
        this.shallow = shallow;
        this.mock = mock;
        this.dep = mock ? mockDep : new Dep();
        this.vmCount = 0;
        def2(value, "__ob__", this);
        if (isArray2(value)) {
          if (!mock) {
            if (hasProto) {
              value.__proto__ = arrayMethods;
            } else {
              for (let i = 0, l = arrayKeys.length; i < l; i++) {
                const key2 = arrayKeys[i];
                def2(value, key2, arrayMethods[key2]);
              }
            }
          }
          if (!shallow) {
            this.observeArray(value);
          }
        } else {
          const keys2 = Object.keys(value);
          for (let i = 0; i < keys2.length; i++) {
            const key2 = keys2[i];
            defineReactive(value, key2, NO_INITIAL_VALUE, void 0, shallow, mock);
          }
        }
      }
      /**
       * Observe a list of Array items.
       */
      observeArray(value) {
        for (let i = 0, l = value.length; i < l; i++) {
          observe(value[i], false, this.mock);
        }
      }
    };
    function observe(value, shallow, ssrMockReactivity) {
      if (value && hasOwn2(value, "__ob__") && value.__ob__ instanceof Observer) {
        return value.__ob__;
      }
      if (shouldObserve && (ssrMockReactivity || !isServerRendering()) && (isArray2(value) || isPlainObject2(value)) && Object.isExtensible(value) && !value.__v_skip && !isRef2(value) && !(value instanceof VNode)) {
        return new Observer(value, shallow, ssrMockReactivity);
      }
    }
    function defineReactive(obj, key2, val, customSetter, shallow, mock, observeEvenIfShallow = false) {
      const dep = new Dep();
      const property2 = Object.getOwnPropertyDescriptor(obj, key2);
      if (property2 && property2.configurable === false) {
        return;
      }
      const getter = property2 && property2.get;
      const setter = property2 && property2.set;
      if ((!getter || setter) && (val === NO_INITIAL_VALUE || arguments.length === 2)) {
        val = obj[key2];
      }
      let childOb = shallow ? val && val.__ob__ : observe(val, false, mock);
      Object.defineProperty(obj, key2, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
          const value = getter ? getter.call(obj) : val;
          if (Dep.target) {
            if (true) {
              dep.depend({
                target: obj,
                type: "get",
                key: key2
              });
            } else {
              dep.depend();
            }
            if (childOb) {
              childOb.dep.depend();
              if (isArray2(value)) {
                dependArray(value);
              }
            }
          }
          return isRef2(value) && !shallow ? value.value : value;
        },
        set: function reactiveSetter(newVal) {
          const value = getter ? getter.call(obj) : val;
          if (!hasChanged2(value, newVal)) {
            return;
          }
          if (customSetter) {
            customSetter();
          }
          if (setter) {
            setter.call(obj, newVal);
          } else if (getter) {
            return;
          } else if (!shallow && isRef2(value) && !isRef2(newVal)) {
            value.value = newVal;
            return;
          } else {
            val = newVal;
          }
          childOb = shallow ? newVal && newVal.__ob__ : observe(newVal, false, mock);
          if (true) {
            dep.notify({
              type: "set",
              target: obj,
              key: key2,
              newValue: newVal,
              oldValue: value
            });
          } else {
            dep.notify();
          }
        }
      });
      return dep;
    }
    function set(target2, key2, val) {
      if (isUndef(target2) || isPrimitive(target2)) {
        warn$2(`Cannot set reactive property on undefined, null, or primitive value: ${target2}`);
      }
      if (isReadonly(target2)) {
        warn$2(`Set operation on key "${key2}" failed: target is readonly.`);
        return;
      }
      const ob = target2.__ob__;
      if (isArray2(target2) && isValidArrayIndex(key2)) {
        target2.length = Math.max(target2.length, key2);
        target2.splice(key2, 1, val);
        if (ob && !ob.shallow && ob.mock) {
          observe(val, false, true);
        }
        return val;
      }
      if (key2 in target2 && !(key2 in Object.prototype)) {
        target2[key2] = val;
        return val;
      }
      if (target2._isVue || ob && ob.vmCount) {
        warn$2("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.");
        return val;
      }
      if (!ob) {
        target2[key2] = val;
        return val;
      }
      defineReactive(ob.value, key2, val, void 0, ob.shallow, ob.mock);
      if (true) {
        ob.dep.notify({
          type: "add",
          target: target2,
          key: key2,
          newValue: val,
          oldValue: void 0
        });
      } else {
        ob.dep.notify();
      }
      return val;
    }
    function dependArray(value) {
      for (let e, i = 0, l = value.length; i < l; i++) {
        e = value[i];
        if (e && e.__ob__) {
          e.__ob__.dep.depend();
        }
        if (isArray2(e)) {
          dependArray(e);
        }
      }
    }
    function isReadonly(value) {
      return !!(value && value.__v_isReadonly);
    }
    function isRef2(r4) {
      return !!(r4 && r4.__v_isRef === true);
    }
    if (true) ;
    var normalizeEvent = cached((name) => {
      const passive = name.charAt(0) === "&";
      name = passive ? name.slice(1) : name;
      const once = name.charAt(0) === "~";
      name = once ? name.slice(1) : name;
      const capture = name.charAt(0) === "!";
      name = capture ? name.slice(1) : name;
      return {
        name,
        once,
        capture,
        passive
      };
    });
    function createFnInvoker(fns, vm) {
      function invoker() {
        const fns2 = invoker.fns;
        if (isArray2(fns2)) {
          const cloned = fns2.slice();
          for (let i = 0; i < cloned.length; i++) {
            invokeWithErrorHandling(cloned[i], null, arguments, vm, `v-on handler`);
          }
        } else {
          return invokeWithErrorHandling(fns2, null, arguments, vm, `v-on handler`);
        }
      }
      invoker.fns = fns;
      return invoker;
    }
    function updateListeners(on2, oldOn, add2, remove3, createOnceHandler2, vm) {
      let name, cur, old, event;
      for (name in on2) {
        cur = on2[name];
        old = oldOn[name];
        event = normalizeEvent(name);
        if (isUndef(cur)) {
          warn$2(`Invalid handler for event "${event.name}": got ` + String(cur), vm);
        } else if (isUndef(old)) {
          if (isUndef(cur.fns)) {
            cur = on2[name] = createFnInvoker(cur, vm);
          }
          if (isTrue(event.once)) {
            cur = on2[name] = createOnceHandler2(event.name, cur, event.capture);
          }
          add2(event.name, cur, event.capture, event.passive, event.params);
        } else if (cur !== old) {
          old.fns = cur;
          on2[name] = old;
        }
      }
      for (name in oldOn) {
        if (isUndef(on2[name])) {
          event = normalizeEvent(name);
          remove3(event.name, oldOn[name], event.capture);
        }
      }
    }
    function extractPropsFromVNodeData(data, Ctor, tag) {
      const propOptions = Ctor.options.props;
      if (isUndef(propOptions)) {
        return;
      }
      const res = {};
      const { attrs, props } = data;
      if (isDef(attrs) || isDef(props)) {
        for (const key2 in propOptions) {
          const altKey = hyphenate2(key2);
          if (true) {
            const keyInLowerCase = key2.toLowerCase();
            if (key2 !== keyInLowerCase && attrs && hasOwn2(attrs, keyInLowerCase)) {
              tip(`Prop "${keyInLowerCase}" is passed to component ${formatComponentName(
                // @ts-expect-error tag is string
                tag || Ctor
              )}, but the declared prop name is "${key2}". Note that HTML attributes are case-insensitive and camelCased props need to use their kebab-case equivalents when using in-DOM templates. You should probably use "${altKey}" instead of "${key2}".`);
            }
          }
          checkProp(res, props, key2, altKey, true) || checkProp(res, attrs, key2, altKey, false);
        }
      }
      return res;
    }
    function checkProp(res, hash2, key2, altKey, preserve) {
      if (isDef(hash2)) {
        if (hasOwn2(hash2, key2)) {
          res[key2] = hash2[key2];
          if (!preserve) {
            delete hash2[key2];
          }
          return true;
        } else if (hasOwn2(hash2, altKey)) {
          res[key2] = hash2[altKey];
          if (!preserve) {
            delete hash2[altKey];
          }
          return true;
        }
      }
      return false;
    }
    function simpleNormalizeChildren(children) {
      for (let i = 0; i < children.length; i++) {
        if (isArray2(children[i])) {
          return Array.prototype.concat.apply([], children);
        }
      }
      return children;
    }
    function normalizeChildren(children) {
      return isPrimitive(children) ? [createTextVNode(children)] : isArray2(children) ? normalizeArrayChildren(children) : void 0;
    }
    function isTextNode(node2) {
      return isDef(node2) && isDef(node2.text) && isFalse(node2.isComment);
    }
    function normalizeArrayChildren(children, nestedIndex) {
      const res = [];
      let i, c, lastIndex, last;
      for (i = 0; i < children.length; i++) {
        c = children[i];
        if (isUndef(c) || typeof c === "boolean")
          continue;
        lastIndex = res.length - 1;
        last = res[lastIndex];
        if (isArray2(c)) {
          if (c.length > 0) {
            c = normalizeArrayChildren(c, `${nestedIndex || ""}_${i}`);
            if (isTextNode(c[0]) && isTextNode(last)) {
              res[lastIndex] = createTextVNode(last.text + c[0].text);
              c.shift();
            }
            res.push.apply(res, c);
          }
        } else if (isPrimitive(c)) {
          if (isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + c);
          } else if (c !== "") {
            res.push(createTextVNode(c));
          }
        } else {
          if (isTextNode(c) && isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + c.text);
          } else {
            if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
              c.key = `__vlist${nestedIndex}_${i}__`;
            }
            res.push(c);
          }
        }
      }
      return res;
    }
    var SIMPLE_NORMALIZE = 1;
    var ALWAYS_NORMALIZE = 2;
    function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
      if (isArray2(data) || isPrimitive(data)) {
        normalizationType = children;
        children = data;
        data = void 0;
      }
      if (isTrue(alwaysNormalize)) {
        normalizationType = ALWAYS_NORMALIZE;
      }
      return _createElement(context, tag, data, children, normalizationType);
    }
    function _createElement(context, tag, data, children, normalizationType) {
      if (isDef(data) && isDef(data.__ob__)) {
        warn$2(`Avoid using observed data object as vnode data: ${JSON.stringify(data)}
Always create fresh vnode data objects in each render!`, context);
        return createEmptyVNode();
      }
      if (isDef(data) && isDef(data.is)) {
        tag = data.is;
      }
      if (!tag) {
        return createEmptyVNode();
      }
      if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
        warn$2("Avoid using non-primitive value as key, use string/number value instead.", context);
      }
      if (isArray2(children) && isFunction2(children[0])) {
        data = data || {};
        data.scopedSlots = { default: children[0] };
        children.length = 0;
      }
      if (normalizationType === ALWAYS_NORMALIZE) {
        children = normalizeChildren(children);
      } else if (normalizationType === SIMPLE_NORMALIZE) {
        children = simpleNormalizeChildren(children);
      }
      let vnode, ns;
      if (typeof tag === "string") {
        let Ctor;
        ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
        if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, "components", tag))) {
          vnode = createComponent(Ctor, data, context, children, tag);
        } else {
          vnode = new VNode(tag, data, children, void 0, void 0, context);
        }
      } else {
        vnode = createComponent(tag, data, context, children);
      }
      if (isArray2(vnode)) {
        return vnode;
      } else if (isDef(vnode)) {
        if (isDef(ns))
          applyNS(vnode, ns);
        if (isDef(data))
          registerDeepBindings(data);
        return vnode;
      } else {
        return createEmptyVNode();
      }
    }
    function applyNS(vnode, ns, force) {
      vnode.ns = ns;
      if (vnode.tag === "foreignObject") {
        ns = void 0;
        force = true;
      }
      if (isDef(vnode.children)) {
        for (let i = 0, l = vnode.children.length; i < l; i++) {
          const child = vnode.children[i];
          if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== "svg")) {
            applyNS(child, ns, force);
          }
        }
      }
    }
    function registerDeepBindings(data) {
      if (isObject2(data.style)) {
        traverse(data.style);
      }
      if (isObject2(data.class)) {
        traverse(data.class);
      }
    }
    function renderList(val, render) {
      let ret = null, i, l, keys2, key2;
      if (isArray2(val) || typeof val === "string") {
        ret = new Array(val.length);
        for (i = 0, l = val.length; i < l; i++) {
          ret[i] = render(val[i], i);
        }
      } else if (typeof val === "number") {
        ret = new Array(val);
        for (i = 0; i < val; i++) {
          ret[i] = render(i + 1, i);
        }
      } else if (isObject2(val)) {
        if (hasSymbol && val[Symbol.iterator]) {
          ret = [];
          const iterator = val[Symbol.iterator]();
          let result = iterator.next();
          while (!result.done) {
            ret.push(render(result.value, ret.length));
            result = iterator.next();
          }
        } else {
          keys2 = Object.keys(val);
          ret = new Array(keys2.length);
          for (i = 0, l = keys2.length; i < l; i++) {
            key2 = keys2[i];
            ret[i] = render(val[key2], key2, i);
          }
        }
      }
      if (!isDef(ret)) {
        ret = [];
      }
      ret._isVList = true;
      return ret;
    }
    function renderSlot(name, fallbackRender, props, bindObject) {
      const scopedSlotFn = this.$scopedSlots[name];
      let nodes;
      if (scopedSlotFn) {
        props = props || {};
        if (bindObject) {
          if (!isObject2(bindObject)) {
            warn$2("slot v-bind without argument expects an Object", this);
          }
          props = extend3(extend3({}, bindObject), props);
        }
        nodes = scopedSlotFn(props) || (isFunction2(fallbackRender) ? fallbackRender() : fallbackRender);
      } else {
        nodes = this.$slots[name] || (isFunction2(fallbackRender) ? fallbackRender() : fallbackRender);
      }
      const target2 = props && props.slot;
      if (target2) {
        return this.$createElement("template", { slot: target2 }, nodes);
      } else {
        return nodes;
      }
    }
    function resolveFilter(id) {
      return resolveAsset(this.$options, "filters", id, true) || identity;
    }
    function isKeyNotMatch(expect, actual) {
      if (isArray2(expect)) {
        return expect.indexOf(actual) === -1;
      } else {
        return expect !== actual;
      }
    }
    function checkKeyCodes(eventKeyCode, key2, builtInKeyCode, eventKeyName, builtInKeyName) {
      const mappedKeyCode = config.keyCodes[key2] || builtInKeyCode;
      if (builtInKeyName && eventKeyName && !config.keyCodes[key2]) {
        return isKeyNotMatch(builtInKeyName, eventKeyName);
      } else if (mappedKeyCode) {
        return isKeyNotMatch(mappedKeyCode, eventKeyCode);
      } else if (eventKeyName) {
        return hyphenate2(eventKeyName) !== key2;
      }
      return eventKeyCode === void 0;
    }
    function bindObjectProps(data, tag, value, asProp, isSync) {
      if (value) {
        if (!isObject2(value)) {
          warn$2("v-bind without argument expects an Object or Array value", this);
        } else {
          if (isArray2(value)) {
            value = toObject(value);
          }
          let hash2;
          for (const key2 in value) {
            if (key2 === "class" || key2 === "style" || isReservedAttribute(key2)) {
              hash2 = data;
            } else {
              const type = data.attrs && data.attrs.type;
              hash2 = asProp || config.mustUseProp(tag, type, key2) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
            }
            const camelizedKey = camelize2(key2);
            const hyphenatedKey = hyphenate2(key2);
            if (!(camelizedKey in hash2) && !(hyphenatedKey in hash2)) {
              hash2[key2] = value[key2];
              if (isSync) {
                const on2 = data.on || (data.on = {});
                on2[`update:${key2}`] = function($event) {
                  value[key2] = $event;
                };
              }
            }
          }
        }
      }
      return data;
    }
    function renderStatic(index3, isInFor) {
      const cached2 = this._staticTrees || (this._staticTrees = []);
      let tree = cached2[index3];
      if (tree && !isInFor) {
        return tree;
      }
      tree = cached2[index3] = this.$options.staticRenderFns[index3].call(
        this._renderProxy,
        this._c,
        this
        // for render fns generated for functional component templates
      );
      markStatic$1(tree, `__static__${index3}`, false);
      return tree;
    }
    function markOnce(tree, index3, key2) {
      markStatic$1(tree, `__once__${index3}${key2 ? `_${key2}` : ``}`, true);
      return tree;
    }
    function markStatic$1(tree, key2, isOnce) {
      if (isArray2(tree)) {
        for (let i = 0; i < tree.length; i++) {
          if (tree[i] && typeof tree[i] !== "string") {
            markStaticNode(tree[i], `${key2}_${i}`, isOnce);
          }
        }
      } else {
        markStaticNode(tree, key2, isOnce);
      }
    }
    function markStaticNode(node2, key2, isOnce) {
      node2.isStatic = true;
      node2.key = key2;
      node2.isOnce = isOnce;
    }
    function bindObjectListeners(data, value) {
      if (value) {
        if (!isPlainObject2(value)) {
          warn$2("v-on without argument expects an Object value", this);
        } else {
          const on2 = data.on = data.on ? extend3({}, data.on) : {};
          for (const key2 in value) {
            const existing = on2[key2];
            const ours = value[key2];
            on2[key2] = existing ? [].concat(existing, ours) : ours;
          }
        }
      }
      return data;
    }
    function resolveScopedSlots(fns, res, hasDynamicKeys, contentHashKey) {
      res = res || { $stable: !hasDynamicKeys };
      for (let i = 0; i < fns.length; i++) {
        const slot = fns[i];
        if (isArray2(slot)) {
          resolveScopedSlots(slot, res, hasDynamicKeys);
        } else if (slot) {
          if (slot.proxy) {
            slot.fn.proxy = true;
          }
          res[slot.key] = slot.fn;
        }
      }
      if (contentHashKey) {
        res.$key = contentHashKey;
      }
      return res;
    }
    function bindDynamicKeys(baseObj, values2) {
      for (let i = 0; i < values2.length; i += 2) {
        const key2 = values2[i];
        if (typeof key2 === "string" && key2) {
          baseObj[values2[i]] = values2[i + 1];
        } else if (key2 !== "" && key2 !== null) {
          warn$2(`Invalid value for dynamic directive argument (expected string or null): ${key2}`, this);
        }
      }
      return baseObj;
    }
    function prependModifier(value, symbol) {
      return typeof value === "string" ? symbol + value : value;
    }
    function installRenderHelpers(target2) {
      target2._o = markOnce;
      target2._n = toNumber2;
      target2._s = toString3;
      target2._l = renderList;
      target2._t = renderSlot;
      target2._q = looseEqual2;
      target2._i = looseIndexOf2;
      target2._m = renderStatic;
      target2._f = resolveFilter;
      target2._k = checkKeyCodes;
      target2._b = bindObjectProps;
      target2._v = createTextVNode;
      target2._e = createEmptyVNode;
      target2._u = resolveScopedSlots;
      target2._g = bindObjectListeners;
      target2._d = bindDynamicKeys;
      target2._p = prependModifier;
    }
    function resolveSlots(children, context) {
      if (!children || !children.length) {
        return {};
      }
      const slots = {};
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        const data = child.data;
        if (data && data.attrs && data.attrs.slot) {
          delete data.attrs.slot;
        }
        if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
          const name = data.slot;
          const slot = slots[name] || (slots[name] = []);
          if (child.tag === "template") {
            slot.push.apply(slot, child.children || []);
          } else {
            slot.push(child);
          }
        } else {
          (slots.default || (slots.default = [])).push(child);
        }
      }
      for (const name in slots) {
        if (slots[name].every(isWhitespace2)) {
          delete slots[name];
        }
      }
      return slots;
    }
    function isWhitespace2(node2) {
      return node2.isComment && !node2.asyncFactory || node2.text === " ";
    }
    function isAsyncPlaceholder(node2) {
      return node2.isComment && node2.asyncFactory;
    }
    function normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {
      let res;
      const hasNormalSlots = Object.keys(normalSlots).length > 0;
      const isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;
      const key2 = scopedSlots && scopedSlots.$key;
      if (!scopedSlots) {
        res = {};
      } else if (scopedSlots._normalized) {
        return scopedSlots._normalized;
      } else if (isStable && prevScopedSlots && prevScopedSlots !== emptyObject && key2 === prevScopedSlots.$key && !hasNormalSlots && !prevScopedSlots.$hasNormal) {
        return prevScopedSlots;
      } else {
        res = {};
        for (const key3 in scopedSlots) {
          if (scopedSlots[key3] && key3[0] !== "$") {
            res[key3] = normalizeScopedSlot(ownerVm, normalSlots, key3, scopedSlots[key3]);
          }
        }
      }
      for (const key3 in normalSlots) {
        if (!(key3 in res)) {
          res[key3] = proxyNormalSlot(normalSlots, key3);
        }
      }
      if (scopedSlots && Object.isExtensible(scopedSlots)) {
        scopedSlots._normalized = res;
      }
      def2(res, "$stable", isStable);
      def2(res, "$key", key2);
      def2(res, "$hasNormal", hasNormalSlots);
      return res;
    }
    function normalizeScopedSlot(vm, normalSlots, key2, fn) {
      const normalized = function() {
        const cur = currentInstance;
        setCurrentInstance(vm);
        let res = arguments.length ? fn.apply(null, arguments) : fn({});
        res = res && typeof res === "object" && !isArray2(res) ? [res] : normalizeChildren(res);
        const vnode = res && res[0];
        setCurrentInstance(cur);
        return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) ? void 0 : res;
      };
      if (fn.proxy) {
        Object.defineProperty(normalSlots, key2, {
          get: normalized,
          enumerable: true,
          configurable: true
        });
      }
      return normalized;
    }
    function proxyNormalSlot(slots, key2) {
      return () => slots[key2];
    }
    function syncSetupProxy(to, from, prev, instance, type) {
      let changed = false;
      for (const key2 in from) {
        if (!(key2 in to)) {
          changed = true;
          defineProxyAttr(to, key2, instance, type);
        } else if (from[key2] !== prev[key2]) {
          changed = true;
        }
      }
      for (const key2 in to) {
        if (!(key2 in from)) {
          changed = true;
          delete to[key2];
        }
      }
      return changed;
    }
    function defineProxyAttr(proxy, key2, instance, type) {
      Object.defineProperty(proxy, key2, {
        enumerable: true,
        configurable: true,
        get() {
          return instance[type][key2];
        }
      });
    }
    function createAsyncPlaceholder(factory, data, context, children, tag) {
      const node2 = createEmptyVNode();
      node2.asyncFactory = factory;
      node2.asyncMeta = { data, context, children, tag };
      return node2;
    }
    function resolveAsyncComponent(factory, baseCtor) {
      if (isTrue(factory.error) && isDef(factory.errorComp)) {
        return factory.errorComp;
      }
      if (isDef(factory.resolved)) {
        return factory.resolved;
      }
      if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
        return factory.loadingComp;
      }
    }
    var target;
    function add(event, fn) {
      target.$on(event, fn);
    }
    function remove2(event, fn) {
      target.$off(event, fn);
    }
    function createOnceHandler(event, fn) {
      const _target = target;
      return function onceHandler() {
        const res = fn.apply(null, arguments);
        if (res !== null) {
          _target.$off(event, onceHandler);
        }
      };
    }
    function updateComponentListeners(vm, listeners, oldListeners) {
      target = vm;
      updateListeners(listeners, oldListeners || {}, add, remove2, createOnceHandler, vm);
      target = void 0;
    }
    var activeInstance = null;
    function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
      if (true) ;
      const newScopedSlots = parentVnode.data.scopedSlots;
      const oldScopedSlots = vm.$scopedSlots;
      const hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key);
      let needsForceUpdate = !!(renderChildren || // has new static slots
      vm.$options._renderChildren || // has old static slots
      hasDynamicScopedSlot);
      const prevVNode = vm.$vnode;
      vm.$options._parentVnode = parentVnode;
      vm.$vnode = parentVnode;
      if (vm._vnode) {
        vm._vnode.parent = parentVnode;
      }
      vm.$options._renderChildren = renderChildren;
      const attrs = parentVnode.data.attrs || emptyObject;
      if (vm._attrsProxy) {
        if (syncSetupProxy(vm._attrsProxy, attrs, prevVNode.data && prevVNode.data.attrs || emptyObject, vm, "$attrs")) {
          needsForceUpdate = true;
        }
      }
      vm.$attrs = attrs;
      listeners = listeners || emptyObject;
      const prevListeners = vm.$options._parentListeners;
      if (vm._listenersProxy) {
        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, "$listeners");
      }
      vm.$listeners = vm.$options._parentListeners = listeners;
      updateComponentListeners(vm, listeners, prevListeners);
      if (propsData && vm.$options.props) {
        toggleObserving(false);
        const props = vm._props;
        const propKeys = vm.$options._propKeys || [];
        for (let i = 0; i < propKeys.length; i++) {
          const key2 = propKeys[i];
          const propOptions = vm.$options.props;
          props[key2] = validateProp(key2, propOptions, propsData, vm);
        }
        toggleObserving(true);
        vm.$options.propsData = propsData;
      }
      if (needsForceUpdate) {
        vm.$slots = resolveSlots(renderChildren, parentVnode.context);
        vm.$forceUpdate();
      }
      if (true) ;
    }
    function isInInactiveTree(vm) {
      while (vm && (vm = vm.$parent)) {
        if (vm._inactive)
          return true;
      }
      return false;
    }
    function activateChildComponent(vm, direct) {
      if (direct) {
        vm._directInactive = false;
        if (isInInactiveTree(vm)) {
          return;
        }
      } else if (vm._directInactive) {
        return;
      }
      if (vm._inactive || vm._inactive === null) {
        vm._inactive = false;
        for (let i = 0; i < vm.$children.length; i++) {
          activateChildComponent(vm.$children[i]);
        }
        callHook(vm, "activated");
      }
    }
    function deactivateChildComponent(vm, direct) {
      if (direct) {
        vm._directInactive = true;
        if (isInInactiveTree(vm)) {
          return;
        }
      }
      if (!vm._inactive) {
        vm._inactive = true;
        for (let i = 0; i < vm.$children.length; i++) {
          deactivateChildComponent(vm.$children[i]);
        }
        callHook(vm, "deactivated");
      }
    }
    function callHook(vm, hook, args, setContext = true) {
      pushTarget();
      const prevInst = currentInstance;
      setContext && setCurrentInstance(vm);
      const handlers2 = vm.$options[hook];
      const info = `${hook} hook`;
      if (handlers2) {
        for (let i = 0, j = handlers2.length; i < j; i++) {
          invokeWithErrorHandling(handlers2[i], vm, args || null, vm, info);
        }
      }
      if (vm._hasHookEvent) {
        vm.$emit("hook:" + hook);
      }
      if (setContext) {
        setCurrentInstance(prevInst);
      }
      popTarget();
    }
    var getNow = Date.now;
    if (inBrowser && !isIE) {
      const performance2 = window.performance;
      if (performance2 && typeof performance2.now === "function" && getNow() > document.createEvent("Event").timeStamp) {
        getNow = () => performance2.now();
      }
    }
    function queueActivatedComponent(vm) {
      vm._inactive = false;
    }
    function handleError(err, vm, info) {
      pushTarget();
      try {
        if (vm) {
          let cur = vm;
          while (cur = cur.$parent) {
            const hooks = cur.$options.errorCaptured;
            if (hooks) {
              for (let i = 0; i < hooks.length; i++) {
                try {
                  const capture = hooks[i].call(cur, err, vm, info) === false;
                  if (capture)
                    return;
                } catch (e) {
                  globalHandleError(e, cur, "errorCaptured hook");
                }
              }
            }
          }
        }
        globalHandleError(err, vm, info);
      } finally {
        popTarget();
      }
    }
    function invokeWithErrorHandling(handler, context, args, vm, info) {
      let res;
      try {
        res = args ? handler.apply(context, args) : handler.call(context);
        if (res && !res._isVue && isPromise2(res) && !res._handled) {
          res.catch((e) => handleError(e, vm, info + ` (Promise/async)`));
          res._handled = true;
        }
      } catch (e) {
        handleError(e, vm, info);
      }
      return res;
    }
    function globalHandleError(err, vm, info) {
      logError(err, vm, info);
    }
    function logError(err, vm, info) {
      if (true) {
        warn$2(`Error in ${info}: "${err.toString()}"`, vm);
      }
      if (inBrowser && typeof console !== "undefined") {
        console.error(err);
      } else {
        throw err;
      }
    }
    var callbacks = [];
    function flushCallbacks() {
      const copies = callbacks.slice(0);
      callbacks.length = 0;
      for (let i = 0; i < copies.length; i++) {
        copies[i]();
      }
    }
    if (typeof Promise !== "undefined" && isNative(Promise)) {
      Promise.resolve();
    } else if (!isIE && typeof MutationObserver !== "undefined" && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
    MutationObserver.toString() === "[object MutationObserverConstructor]")) {
      let counter = 1;
      const observer = new MutationObserver(flushCallbacks);
      const textNode = document.createTextNode(String(counter));
      observer.observe(textNode, {
        characterData: true
      });
    } else if (typeof setImmediate !== "undefined" && isNative(setImmediate)) ;
    else ;
    var seenObjects = new _Set();
    function traverse(val) {
      _traverse(val, seenObjects);
      seenObjects.clear();
      return val;
    }
    function _traverse(val, seen2) {
      let i, keys2;
      const isA = isArray2(val);
      if (!isA && !isObject2(val) || val.__v_skip || Object.isFrozen(val) || val instanceof VNode) {
        return;
      }
      if (val.__ob__) {
        const depId = val.__ob__.dep.id;
        if (seen2.has(depId)) {
          return;
        }
        seen2.add(depId);
      }
      if (isA) {
        i = val.length;
        while (i--)
          _traverse(val[i], seen2);
      } else if (isRef2(val)) {
        _traverse(val.value, seen2);
      } else {
        keys2 = Object.keys(val);
        i = keys2.length;
        while (i--)
          _traverse(val[keys2[i]], seen2);
      }
    }
    function resolveInject(inject, vm) {
      if (inject) {
        const result = /* @__PURE__ */ Object.create(null);
        const keys2 = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
        for (let i = 0; i < keys2.length; i++) {
          const key2 = keys2[i];
          if (key2 === "__ob__")
            continue;
          const provideKey = inject[key2].from;
          if (provideKey in vm._provided) {
            result[key2] = vm._provided[provideKey];
          } else if ("default" in inject[key2]) {
            const provideDefault = inject[key2].default;
            result[key2] = isFunction2(provideDefault) ? provideDefault.call(vm) : provideDefault;
          } else if (true) {
            warn$2(`Injection "${key2}" not found`, vm);
          }
        }
        return result;
      }
    }
    function resolveConstructorOptions(Ctor) {
      let options = Ctor.options;
      if (Ctor.super) {
        const superOptions = resolveConstructorOptions(Ctor.super);
        const cachedSuperOptions = Ctor.superOptions;
        if (superOptions !== cachedSuperOptions) {
          Ctor.superOptions = superOptions;
          const modifiedOptions = resolveModifiedOptions(Ctor);
          if (modifiedOptions) {
            extend3(Ctor.extendOptions, modifiedOptions);
          }
          options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
          if (options.name) {
            options.components[options.name] = Ctor;
          }
        }
      }
      return options;
    }
    function resolveModifiedOptions(Ctor) {
      let modified;
      const latest = Ctor.options;
      const sealed = Ctor.sealedOptions;
      for (const key2 in latest) {
        if (latest[key2] !== sealed[key2]) {
          if (!modified)
            modified = {};
          modified[key2] = latest[key2];
        }
      }
      return modified;
    }
    function FunctionalRenderContext(data, props, children, parent, Ctor) {
      const options = Ctor.options;
      let contextVm;
      if (hasOwn2(parent, "_uid")) {
        contextVm = Object.create(parent);
        contextVm._original = parent;
      } else {
        contextVm = parent;
        parent = parent._original;
      }
      const isCompiled = isTrue(options._compiled);
      const needNormalization = !isCompiled;
      this.data = data;
      this.props = props;
      this.children = children;
      this.parent = parent;
      this.listeners = data.on || emptyObject;
      this.injections = resolveInject(options.inject, parent);
      this.slots = () => {
        if (!this.$slots) {
          normalizeScopedSlots(parent, data.scopedSlots, this.$slots = resolveSlots(children, parent));
        }
        return this.$slots;
      };
      Object.defineProperty(this, "scopedSlots", {
        enumerable: true,
        get() {
          return normalizeScopedSlots(parent, data.scopedSlots, this.slots());
        }
      });
      if (isCompiled) {
        this.$options = options;
        this.$slots = this.slots();
        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);
      }
      if (options._scopeId) {
        this._c = (a, b, c, d) => {
          const vnode = createElement(contextVm, a, b, c, d, needNormalization);
          if (vnode && !isArray2(vnode)) {
            vnode.fnScopeId = options._scopeId;
            vnode.fnContext = parent;
          }
          return vnode;
        };
      } else {
        this._c = (a, b, c, d) => createElement(contextVm, a, b, c, d, needNormalization);
      }
    }
    installRenderHelpers(FunctionalRenderContext.prototype);
    function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
      const options = Ctor.options;
      const props = {};
      const propOptions = options.props;
      if (isDef(propOptions)) {
        for (const key2 in propOptions) {
          props[key2] = validateProp(key2, propOptions, propsData || emptyObject);
        }
      } else {
        if (isDef(data.attrs))
          mergeProps(props, data.attrs);
        if (isDef(data.props))
          mergeProps(props, data.props);
      }
      const renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
      const vnode = options.render.call(null, renderContext._c, renderContext);
      if (vnode instanceof VNode) {
        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
      } else if (isArray2(vnode)) {
        const vnodes = normalizeChildren(vnode) || [];
        const res = new Array(vnodes.length);
        for (let i = 0; i < vnodes.length; i++) {
          res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
        }
        return res;
      }
    }
    function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
      const clone = cloneVNode(vnode);
      clone.fnContext = contextVm;
      clone.fnOptions = options;
      if (true) {
        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
      }
      if (data.slot) {
        (clone.data || (clone.data = {})).slot = data.slot;
      }
      return clone;
    }
    function mergeProps(to, from) {
      for (const key2 in from) {
        to[camelize2(key2)] = from[key2];
      }
    }
    function getComponentName(options) {
      return options.name || options.__name || options._componentTag;
    }
    var componentVNodeHooks = {
      init(vnode, hydrating) {
        if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
          const mountedNode = vnode;
          componentVNodeHooks.prepatch(mountedNode, mountedNode);
        } else {
          const child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
          child.$mount(hydrating ? vnode.elm : void 0, hydrating);
        }
      },
      prepatch(oldVnode, vnode) {
        const options = vnode.componentOptions;
        const child = vnode.componentInstance = oldVnode.componentInstance;
        updateChildComponent(
          child,
          options.propsData,
          // updated props
          options.listeners,
          // updated listeners
          vnode,
          // new parent vnode
          options.children
          // new children
        );
      },
      insert(vnode) {
        const { context, componentInstance } = vnode;
        if (!componentInstance._isMounted) {
          componentInstance._isMounted = true;
          callHook(componentInstance, "mounted");
        }
        if (vnode.data.keepAlive) {
          if (context._isMounted) {
            queueActivatedComponent(componentInstance);
          } else {
            activateChildComponent(
              componentInstance,
              true
              /* direct */
            );
          }
        }
      },
      destroy(vnode) {
        const { componentInstance } = vnode;
        if (!componentInstance._isDestroyed) {
          if (!vnode.data.keepAlive) {
            componentInstance.$destroy();
          } else {
            deactivateChildComponent(
              componentInstance,
              true
              /* direct */
            );
          }
        }
      }
    };
    var hooksToMerge = Object.keys(componentVNodeHooks);
    function createComponent(Ctor, data, context, children, tag) {
      if (isUndef(Ctor)) {
        return;
      }
      const baseCtor = context.$options._base;
      if (isObject2(Ctor)) {
        Ctor = baseCtor.extend(Ctor);
      }
      if (typeof Ctor !== "function") {
        if (true) {
          warn$2(`Invalid Component definition: ${String(Ctor)}`, context);
        }
        return;
      }
      let asyncFactory;
      if (isUndef(Ctor.cid)) {
        asyncFactory = Ctor;
        Ctor = resolveAsyncComponent(asyncFactory);
        if (Ctor === void 0) {
          return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
        }
      }
      data = data || {};
      resolveConstructorOptions(Ctor);
      if (isDef(data.model)) {
        transformModel3(Ctor.options, data);
      }
      const propsData = extractPropsFromVNodeData(data, Ctor, tag);
      if (isTrue(Ctor.options.functional)) {
        return createFunctionalComponent(Ctor, propsData, data, context, children);
      }
      const listeners = data.on;
      data.on = data.nativeOn;
      if (isTrue(Ctor.options.abstract)) {
        const slot = data.slot;
        data = {};
        if (slot) {
          data.slot = slot;
        }
      }
      installComponentHooks(data);
      const name = getComponentName(Ctor.options) || tag;
      const vnode = new VNode(
        // @ts-expect-error
        `vue-component-${Ctor.cid}${name ? `-${name}` : ""}`,
        data,
        void 0,
        void 0,
        void 0,
        context,
        // @ts-expect-error
        { Ctor, propsData, listeners, tag, children },
        asyncFactory
      );
      return vnode;
    }
    function createComponentInstanceForVnode(vnode, parent) {
      const options = {
        _isComponent: true,
        _parentVnode: vnode,
        parent
      };
      const inlineTemplate = vnode.data.inlineTemplate;
      if (isDef(inlineTemplate)) {
        options.render = inlineTemplate.render;
        options.staticRenderFns = inlineTemplate.staticRenderFns;
      }
      return new vnode.componentOptions.Ctor(options);
    }
    function installComponentHooks(data) {
      const hooks = data.hook || (data.hook = {});
      for (let i = 0; i < hooksToMerge.length; i++) {
        const key2 = hooksToMerge[i];
        const existing = hooks[key2];
        const toMerge = componentVNodeHooks[key2];
        if (existing !== toMerge && !(existing && existing._merged)) {
          hooks[key2] = existing ? mergeHook(toMerge, existing) : toMerge;
        }
      }
    }
    function mergeHook(f1, f2) {
      const merged = (a, b) => {
        f1(a, b);
        f2(a, b);
      };
      merged._merged = true;
      return merged;
    }
    function transformModel3(options, data) {
      const prop = options.model && options.model.prop || "value";
      const event = options.model && options.model.event || "input";
      (data.attrs || (data.attrs = {}))[prop] = data.model.value;
      const on2 = data.on || (data.on = {});
      const existing = on2[event];
      const callback = data.model.callback;
      if (isDef(existing)) {
        if (isArray2(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
          on2[event] = [callback].concat(existing);
        }
      } else {
        on2[event] = callback;
      }
    }
    var warn$2 = noop;
    var tip = noop;
    var generateComponentTrace;
    var formatComponentName;
    if (true) {
      const hasConsole = typeof console !== "undefined";
      const classifyRE = /(?:^|[-_])(\w)/g;
      const classify = (str2) => str2.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
      warn$2 = (msg, vm = currentInstance) => {
        const trace = vm ? generateComponentTrace(vm) : "";
        if (hasConsole && !config.silent) {
          console.error(`[Vue warn]: ${msg}${trace}`);
        }
      };
      tip = (msg, vm) => {
        if (hasConsole && !config.silent) {
          console.warn(`[Vue tip]: ${msg}` + (vm ? generateComponentTrace(vm) : ""));
        }
      };
      formatComponentName = (vm, includeFile) => {
        if (vm.$root === vm) {
          return "<Root>";
        }
        const options = isFunction2(vm) && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
        let name = getComponentName(options);
        const file = options.__file;
        if (!name && file) {
          const match = file.match(/([^/\\]+)\.vue$/);
          name = match && match[1];
        }
        return (name ? `<${classify(name)}>` : `<Anonymous>`) + (file && includeFile !== false ? ` at ${file}` : "");
      };
      const repeat2 = (str2, n) => {
        let res = "";
        while (n) {
          if (n % 2 === 1)
            res += str2;
          if (n > 1)
            str2 += str2;
          n >>= 1;
        }
        return res;
      };
      generateComponentTrace = (vm) => {
        if (vm._isVue && vm.$parent) {
          const tree = [];
          let currentRecursiveSequence = 0;
          while (vm) {
            if (tree.length > 0) {
              const last = tree[tree.length - 1];
              if (last.constructor === vm.constructor) {
                currentRecursiveSequence++;
                vm = vm.$parent;
                continue;
              } else if (currentRecursiveSequence > 0) {
                tree[tree.length - 1] = [last, currentRecursiveSequence];
                currentRecursiveSequence = 0;
              }
            }
            tree.push(vm);
            vm = vm.$parent;
          }
          return "\n\nfound in\n\n" + tree.map((vm2, i) => `${i === 0 ? "---> " : repeat2(" ", 5 + i * 2)}${isArray2(vm2) ? `${formatComponentName(vm2[0])}... (${vm2[1]} recursive calls)` : formatComponentName(vm2)}`).join("\n");
        } else {
          return `

(found in ${formatComponentName(vm)})`;
        }
      };
    }
    var strats = config.optionMergeStrategies;
    if (true) {
      strats.el = strats.propsData = function(parent, child, vm, key2) {
        if (!vm) {
          warn$2(`option "${key2}" can only be used during instance creation with the \`new\` keyword.`);
        }
        return defaultStrat(parent, child);
      };
    }
    function mergeData(to, from, recursive = true) {
      if (!from)
        return to;
      let key2, toVal, fromVal;
      const keys2 = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);
      for (let i = 0; i < keys2.length; i++) {
        key2 = keys2[i];
        if (key2 === "__ob__")
          continue;
        toVal = to[key2];
        fromVal = from[key2];
        if (!recursive || !hasOwn2(to, key2)) {
          set(to, key2, fromVal);
        } else if (toVal !== fromVal && isPlainObject2(toVal) && isPlainObject2(fromVal)) {
          mergeData(toVal, fromVal);
        }
      }
      return to;
    }
    function mergeDataOrFn(parentVal, childVal, vm) {
      if (!vm) {
        if (!childVal) {
          return parentVal;
        }
        if (!parentVal) {
          return childVal;
        }
        return function mergedDataFn() {
          return mergeData(isFunction2(childVal) ? childVal.call(this, this) : childVal, isFunction2(parentVal) ? parentVal.call(this, this) : parentVal);
        };
      } else {
        return function mergedInstanceDataFn() {
          const instanceData = isFunction2(childVal) ? childVal.call(vm, vm) : childVal;
          const defaultData = isFunction2(parentVal) ? parentVal.call(vm, vm) : parentVal;
          if (instanceData) {
            return mergeData(instanceData, defaultData);
          } else {
            return defaultData;
          }
        };
      }
    }
    strats.data = function(parentVal, childVal, vm) {
      if (!vm) {
        if (childVal && typeof childVal !== "function") {
          warn$2('The "data" option should be a function that returns a per-instance value in component definitions.', vm);
          return parentVal;
        }
        return mergeDataOrFn(parentVal, childVal);
      }
      return mergeDataOrFn(parentVal, childVal, vm);
    };
    function mergeLifecycleHook(parentVal, childVal) {
      const res = childVal ? parentVal ? parentVal.concat(childVal) : isArray2(childVal) ? childVal : [childVal] : parentVal;
      return res ? dedupeHooks(res) : res;
    }
    function dedupeHooks(hooks) {
      const res = [];
      for (let i = 0; i < hooks.length; i++) {
        if (res.indexOf(hooks[i]) === -1) {
          res.push(hooks[i]);
        }
      }
      return res;
    }
    LIFECYCLE_HOOKS.forEach((hook) => {
      strats[hook] = mergeLifecycleHook;
    });
    function mergeAssets(parentVal, childVal, vm, key2) {
      const res = Object.create(parentVal || null);
      if (childVal) {
        assertObjectType(key2, childVal, vm);
        return extend3(res, childVal);
      } else {
        return res;
      }
    }
    ASSET_TYPES.forEach(function(type) {
      strats[type + "s"] = mergeAssets;
    });
    strats.watch = function(parentVal, childVal, vm, key2) {
      if (parentVal === nativeWatch)
        parentVal = void 0;
      if (childVal === nativeWatch)
        childVal = void 0;
      if (!childVal)
        return Object.create(parentVal || null);
      if (true) {
        assertObjectType(key2, childVal, vm);
      }
      if (!parentVal)
        return childVal;
      const ret = {};
      extend3(ret, parentVal);
      for (const key3 in childVal) {
        let parent = ret[key3];
        const child = childVal[key3];
        if (parent && !isArray2(parent)) {
          parent = [parent];
        }
        ret[key3] = parent ? parent.concat(child) : isArray2(child) ? child : [child];
      }
      return ret;
    };
    strats.props = strats.methods = strats.inject = strats.computed = function(parentVal, childVal, vm, key2) {
      if (childVal && true) {
        assertObjectType(key2, childVal, vm);
      }
      if (!parentVal)
        return childVal;
      const ret = /* @__PURE__ */ Object.create(null);
      extend3(ret, parentVal);
      if (childVal)
        extend3(ret, childVal);
      return ret;
    };
    strats.provide = function(parentVal, childVal) {
      if (!parentVal)
        return childVal;
      return function() {
        const ret = /* @__PURE__ */ Object.create(null);
        mergeData(ret, isFunction2(parentVal) ? parentVal.call(this) : parentVal);
        if (childVal) {
          mergeData(
            ret,
            isFunction2(childVal) ? childVal.call(this) : childVal,
            false
            // non-recursive
          );
        }
        return ret;
      };
    };
    var defaultStrat = function(parentVal, childVal) {
      return childVal === void 0 ? parentVal : childVal;
    };
    function checkComponents(options) {
      for (const key2 in options.components) {
        validateComponentName(key2);
      }
    }
    function validateComponentName(name) {
      if (!new RegExp(`^[a-zA-Z][\\-\\.0-9_${unicodeRegExp.source}]*$`).test(name)) {
        warn$2('Invalid component name: "' + name + '". Component names should conform to valid custom element name in html5 specification.');
      }
      if (isBuiltInTag(name) || config.isReservedTag(name)) {
        warn$2("Do not use built-in or reserved HTML elements as component id: " + name);
      }
    }
    function normalizeProps2(options, vm) {
      const props = options.props;
      if (!props)
        return;
      const res = {};
      let i, val, name;
      if (isArray2(props)) {
        i = props.length;
        while (i--) {
          val = props[i];
          if (typeof val === "string") {
            name = camelize2(val);
            res[name] = { type: null };
          } else if (true) {
            warn$2("props must be strings when using array syntax.");
          }
        }
      } else if (isPlainObject2(props)) {
        for (const key2 in props) {
          val = props[key2];
          name = camelize2(key2);
          res[name] = isPlainObject2(val) ? val : { type: val };
        }
      } else if (true) {
        warn$2(`Invalid value for option "props": expected an Array or an Object, but got ${toRawType2(props)}.`, vm);
      }
      options.props = res;
    }
    function normalizeInject(options, vm) {
      const inject = options.inject;
      if (!inject)
        return;
      const normalized = options.inject = {};
      if (isArray2(inject)) {
        for (let i = 0; i < inject.length; i++) {
          normalized[inject[i]] = { from: inject[i] };
        }
      } else if (isPlainObject2(inject)) {
        for (const key2 in inject) {
          const val = inject[key2];
          normalized[key2] = isPlainObject2(val) ? extend3({ from: key2 }, val) : { from: val };
        }
      } else if (true) {
        warn$2(`Invalid value for option "inject": expected an Array or an Object, but got ${toRawType2(inject)}.`, vm);
      }
    }
    function normalizeDirectives(options) {
      const dirs = options.directives;
      if (dirs) {
        for (const key2 in dirs) {
          const def3 = dirs[key2];
          if (isFunction2(def3)) {
            dirs[key2] = { bind: def3, update: def3 };
          }
        }
      }
    }
    function assertObjectType(name, value, vm) {
      if (!isPlainObject2(value)) {
        warn$2(`Invalid value for option "${name}": expected an Object, but got ${toRawType2(value)}.`, vm);
      }
    }
    function mergeOptions(parent, child, vm) {
      if (true) {
        checkComponents(child);
      }
      if (isFunction2(child)) {
        child = child.options;
      }
      normalizeProps2(child, vm);
      normalizeInject(child, vm);
      normalizeDirectives(child);
      if (!child._base) {
        if (child.extends) {
          parent = mergeOptions(parent, child.extends, vm);
        }
        if (child.mixins) {
          for (let i = 0, l = child.mixins.length; i < l; i++) {
            parent = mergeOptions(parent, child.mixins[i], vm);
          }
        }
      }
      const options = {};
      let key2;
      for (key2 in parent) {
        mergeField(key2);
      }
      for (key2 in child) {
        if (!hasOwn2(parent, key2)) {
          mergeField(key2);
        }
      }
      function mergeField(key3) {
        const strat = strats[key3] || defaultStrat;
        options[key3] = strat(parent[key3], child[key3], vm, key3);
      }
      return options;
    }
    function resolveAsset(options, type, id, warnMissing) {
      if (typeof id !== "string") {
        return;
      }
      const assets = options[type];
      if (hasOwn2(assets, id))
        return assets[id];
      const camelizedId = camelize2(id);
      if (hasOwn2(assets, camelizedId))
        return assets[camelizedId];
      const PascalCaseId = capitalize2(camelizedId);
      if (hasOwn2(assets, PascalCaseId))
        return assets[PascalCaseId];
      const res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
      if (warnMissing && !res) {
        warn$2("Failed to resolve " + type.slice(0, -1) + ": " + id);
      }
      return res;
    }
    function validateProp(key2, propOptions, propsData, vm) {
      const prop = propOptions[key2];
      const absent = !hasOwn2(propsData, key2);
      let value = propsData[key2];
      const booleanIndex = getTypeIndex(Boolean, prop.type);
      if (booleanIndex > -1) {
        if (absent && !hasOwn2(prop, "default")) {
          value = false;
        } else if (value === "" || value === hyphenate2(key2)) {
          const stringIndex = getTypeIndex(String, prop.type);
          if (stringIndex < 0 || booleanIndex < stringIndex) {
            value = true;
          }
        }
      }
      if (value === void 0) {
        value = getPropDefaultValue(vm, prop, key2);
        const prevShouldObserve = shouldObserve;
        toggleObserving(true);
        observe(value);
        toggleObserving(prevShouldObserve);
      }
      if (true) {
        assertProp(prop, key2, value, vm, absent);
      }
      return value;
    }
    function getPropDefaultValue(vm, prop, key2) {
      if (!hasOwn2(prop, "default")) {
        return void 0;
      }
      const def3 = prop.default;
      if (isObject2(def3)) {
        warn$2('Invalid default value for prop "' + key2 + '": Props with type Object/Array must use a factory function to return the default value.', vm);
      }
      if (vm && vm.$options.propsData && vm.$options.propsData[key2] === void 0 && vm._props[key2] !== void 0) {
        return vm._props[key2];
      }
      return isFunction2(def3) && getType(prop.type) !== "Function" ? def3.call(vm) : def3;
    }
    function assertProp(prop, name, value, vm, absent) {
      if (prop.required && absent) {
        warn$2('Missing required prop: "' + name + '"', vm);
        return;
      }
      if (value == null && !prop.required) {
        return;
      }
      let type = prop.type;
      let valid2 = !type || type === true;
      const expectedTypes = [];
      if (type) {
        if (!isArray2(type)) {
          type = [type];
        }
        for (let i = 0; i < type.length && !valid2; i++) {
          const assertedType = assertType(value, type[i], vm);
          expectedTypes.push(assertedType.expectedType || "");
          valid2 = assertedType.valid;
        }
      }
      const haveExpectedTypes = expectedTypes.some((t) => t);
      if (!valid2 && haveExpectedTypes) {
        warn$2(getInvalidTypeMessage(name, value, expectedTypes), vm);
        return;
      }
      const validator = prop.validator;
      if (validator) {
        if (!validator(value)) {
          warn$2('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
        }
      }
    }
    var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
    function assertType(value, type, vm) {
      let valid2;
      const expectedType = getType(type);
      if (simpleCheckRE.test(expectedType)) {
        const t = typeof value;
        valid2 = t === expectedType.toLowerCase();
        if (!valid2 && t === "object") {
          valid2 = value instanceof type;
        }
      } else if (expectedType === "Object") {
        valid2 = isPlainObject2(value);
      } else if (expectedType === "Array") {
        valid2 = isArray2(value);
      } else {
        try {
          valid2 = value instanceof type;
        } catch (e) {
          warn$2('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
          valid2 = false;
        }
      }
      return {
        valid: valid2,
        expectedType
      };
    }
    var functionTypeCheckRE = /^\s*function (\w+)/;
    function getType(fn) {
      const match = fn && fn.toString().match(functionTypeCheckRE);
      return match ? match[1] : "";
    }
    function isSameType(a, b) {
      return getType(a) === getType(b);
    }
    function getTypeIndex(type, expectedTypes) {
      if (!isArray2(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
      }
      for (let i = 0, len2 = expectedTypes.length; i < len2; i++) {
        if (isSameType(expectedTypes[i], type)) {
          return i;
        }
      }
      return -1;
    }
    function getInvalidTypeMessage(name, value, expectedTypes) {
      let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize2).join(", ")}`;
      const expectedType = expectedTypes[0];
      const receivedType = toRawType2(value);
      if (expectedTypes.length === 1 && isExplicable(expectedType) && isExplicable(typeof value) && !isBoolean(expectedType, receivedType)) {
        message += ` with value ${styleValue(value, expectedType)}`;
      }
      message += `, got ${receivedType} `;
      if (isExplicable(receivedType)) {
        message += `with value ${styleValue(value, receivedType)}.`;
      }
      return message;
    }
    function styleValue(value, type) {
      if (type === "String") {
        return `"${value}"`;
      } else if (type === "Number") {
        return `${Number(value)}`;
      } else {
        return `${value}`;
      }
    }
    var EXPLICABLE_TYPES = ["string", "number", "boolean"];
    function isExplicable(value) {
      return EXPLICABLE_TYPES.some((elem) => value.toLowerCase() === elem);
    }
    function isBoolean(...args) {
      return args.some((elem) => elem.toLowerCase() === "boolean");
    }
    makeMap2("style,class");
    var acceptValue = makeMap2("input,textarea,option,select,progress");
    var mustUseProp = (tag, type, attr) => {
      return attr === "value" && acceptValue(tag) && type !== "button" || attr === "selected" && tag === "option" || attr === "checked" && tag === "input" || attr === "muted" && tag === "video";
    };
    var isEnumeratedAttr = makeMap2("contenteditable,draggable,spellcheck");
    makeMap2("events,caret,typing,plaintext-only");
    var isBooleanAttr2 = makeMap2("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible");
    var isHTMLTag2 = makeMap2("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot");
    var isSVG = makeMap2("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true);
    var isPreTag = (tag) => tag === "pre";
    var isReservedTag = (tag) => {
      return isHTMLTag2(tag) || isSVG(tag);
    };
    function getTagNamespace(tag) {
      if (isSVG(tag)) {
        return "svg";
      }
      if (tag === "math") {
        return "math";
      }
    }
    makeMap2("text,number,password,search,email,tel,url");
    var validDivisionCharRE2 = /[\w).+\-_$\]]/;
    function parseFilters(exp) {
      let inSingle = false;
      let inDouble = false;
      let inTemplateString = false;
      let inRegex = false;
      let curly = 0;
      let square = 0;
      let paren = 0;
      let lastFilterIndex = 0;
      let c, prev, i, expression, filters;
      for (i = 0; i < exp.length; i++) {
        prev = c;
        c = exp.charCodeAt(i);
        if (inSingle) {
          if (c === 39 && prev !== 92)
            inSingle = false;
        } else if (inDouble) {
          if (c === 34 && prev !== 92)
            inDouble = false;
        } else if (inTemplateString) {
          if (c === 96 && prev !== 92)
            inTemplateString = false;
        } else if (inRegex) {
          if (c === 47 && prev !== 92)
            inRegex = false;
        } else if (c === 124 && // pipe
        exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
          if (expression === void 0) {
            lastFilterIndex = i + 1;
            expression = exp.slice(0, i).trim();
          } else {
            pushFilter();
          }
        } else {
          switch (c) {
            case 34:
              inDouble = true;
              break;
            case 39:
              inSingle = true;
              break;
            case 96:
              inTemplateString = true;
              break;
            case 40:
              paren++;
              break;
            case 41:
              paren--;
              break;
            case 91:
              square++;
              break;
            case 93:
              square--;
              break;
            case 123:
              curly++;
              break;
            case 125:
              curly--;
              break;
          }
          if (c === 47) {
            let j = i - 1;
            let p2;
            for (; j >= 0; j--) {
              p2 = exp.charAt(j);
              if (p2 !== " ")
                break;
            }
            if (!p2 || !validDivisionCharRE2.test(p2)) {
              inRegex = true;
            }
          }
        }
      }
      if (expression === void 0) {
        expression = exp.slice(0, i).trim();
      } else if (lastFilterIndex !== 0) {
        pushFilter();
      }
      function pushFilter() {
        (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
        lastFilterIndex = i + 1;
      }
      if (filters) {
        for (i = 0; i < filters.length; i++) {
          expression = wrapFilter2(expression, filters[i]);
        }
      }
      return expression;
    }
    function wrapFilter2(exp, filter) {
      const i = filter.indexOf("(");
      if (i < 0) {
        return `_f("${filter}")(${exp})`;
      } else {
        const name = filter.slice(0, i);
        const args = filter.slice(i + 1);
        return `_f("${name}")(${exp}${args !== ")" ? "," + args : args}`;
      }
    }
    var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
    var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
    var buildRegex = cached((delimiters2) => {
      const open = delimiters2[0].replace(regexEscapeRE, "\\$&");
      const close = delimiters2[1].replace(regexEscapeRE, "\\$&");
      return new RegExp(open + "((?:.|\\n)+?)" + close, "g");
    });
    function parseText(text7, delimiters2) {
      const tagRE = delimiters2 ? buildRegex(delimiters2) : defaultTagRE;
      if (!tagRE.test(text7)) {
        return;
      }
      const tokens = [];
      const rawTokens = [];
      let lastIndex = tagRE.lastIndex = 0;
      let match, index3, tokenValue;
      while (match = tagRE.exec(text7)) {
        index3 = match.index;
        if (index3 > lastIndex) {
          rawTokens.push(tokenValue = text7.slice(lastIndex, index3));
          tokens.push(JSON.stringify(tokenValue));
        }
        const exp = parseFilters(match[1].trim());
        tokens.push(`_s(${exp})`);
        rawTokens.push({ "@binding": exp });
        lastIndex = index3 + match[0].length;
      }
      if (lastIndex < text7.length) {
        rawTokens.push(tokenValue = text7.slice(lastIndex));
        tokens.push(JSON.stringify(tokenValue));
      }
      return {
        expression: tokens.join("+"),
        tokens: rawTokens
      };
    }
    function baseWarn(msg, range4) {
      console.error(`[Vue compiler]: ${msg}`);
    }
    function pluckModuleFunction(modules2, key2) {
      return modules2 ? modules2.map((m) => m[key2]).filter((_) => _) : [];
    }
    function addProp(el, name, value, range4, dynamic) {
      (el.props || (el.props = [])).push(rangeSetItem({ name, value, dynamic }, range4));
      el.plain = false;
    }
    function addAttr(el, name, value, range4, dynamic) {
      const attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
      attrs.push(rangeSetItem({ name, value, dynamic }, range4));
      el.plain = false;
    }
    function addRawAttr(el, name, value, range4) {
      el.attrsMap[name] = value;
      el.attrsList.push(rangeSetItem({ name, value }, range4));
    }
    function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range4) {
      (el.directives || (el.directives = [])).push(rangeSetItem({
        name,
        rawName,
        value,
        arg,
        isDynamicArg,
        modifiers
      }, range4));
      el.plain = false;
    }
    function prependModifierMarker(symbol, name, dynamic) {
      return dynamic ? `_p(${name},"${symbol}")` : symbol + name;
    }
    function addHandler(el, name, value, modifiers, important, warn3, range4, dynamic) {
      modifiers = modifiers || emptyObject;
      if (warn3 && modifiers.prevent && modifiers.passive) {
        warn3("passive and prevent can't be used together. Passive handler can't prevent default event.", range4);
      }
      if (modifiers.right) {
        if (dynamic) {
          name = `(${name})==='click'?'contextmenu':(${name})`;
        } else if (name === "click") {
          name = "contextmenu";
          delete modifiers.right;
        }
      } else if (modifiers.middle) {
        if (dynamic) {
          name = `(${name})==='click'?'mouseup':(${name})`;
        } else if (name === "click") {
          name = "mouseup";
        }
      }
      if (modifiers.capture) {
        delete modifiers.capture;
        name = prependModifierMarker("!", name, dynamic);
      }
      if (modifiers.once) {
        delete modifiers.once;
        name = prependModifierMarker("~", name, dynamic);
      }
      if (modifiers.passive) {
        delete modifiers.passive;
        name = prependModifierMarker("&", name, dynamic);
      }
      let events;
      if (modifiers.native) {
        delete modifiers.native;
        events = el.nativeEvents || (el.nativeEvents = {});
      } else {
        events = el.events || (el.events = {});
      }
      const newHandler = rangeSetItem({ value: value.trim(), dynamic }, range4);
      if (modifiers !== emptyObject) {
        newHandler.modifiers = modifiers;
      }
      const handlers2 = events[name];
      if (Array.isArray(handlers2)) {
        important ? handlers2.unshift(newHandler) : handlers2.push(newHandler);
      } else if (handlers2) {
        events[name] = important ? [newHandler, handlers2] : [handlers2, newHandler];
      } else {
        events[name] = newHandler;
      }
      el.plain = false;
    }
    function getRawBindingAttr(el, name) {
      return el.rawAttrsMap[":" + name] || el.rawAttrsMap["v-bind:" + name] || el.rawAttrsMap[name];
    }
    function getBindingAttr(el, name, getStatic) {
      const dynamicValue = getAndRemoveAttr(el, ":" + name) || getAndRemoveAttr(el, "v-bind:" + name);
      if (dynamicValue != null) {
        return parseFilters(dynamicValue);
      } else if (getStatic !== false) {
        const staticValue = getAndRemoveAttr(el, name);
        if (staticValue != null) {
          return JSON.stringify(staticValue);
        }
      }
    }
    function getAndRemoveAttr(el, name, removeFromMap) {
      let val;
      if ((val = el.attrsMap[name]) != null) {
        const list4 = el.attrsList;
        for (let i = 0, l = list4.length; i < l; i++) {
          if (list4[i].name === name) {
            list4.splice(i, 1);
            break;
          }
        }
      }
      if (removeFromMap) {
        delete el.attrsMap[name];
      }
      return val;
    }
    function getAndRemoveAttrByRegex(el, name) {
      const list4 = el.attrsList;
      for (let i = 0, l = list4.length; i < l; i++) {
        const attr = list4[i];
        if (name.test(attr.name)) {
          list4.splice(i, 1);
          return attr;
        }
      }
    }
    function rangeSetItem(item, range4) {
      if (range4) {
        if (range4.start != null) {
          item.start = range4.start;
        }
        if (range4.end != null) {
          item.end = range4.end;
        }
      }
      return item;
    }
    function transformNode$1(el, options) {
      const warn3 = options.warn || baseWarn;
      const staticClass = getAndRemoveAttr(el, "class");
      if (staticClass) {
        const res = parseText(staticClass, options.delimiters);
        if (res) {
          warn3(`class="${staticClass}": Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead. For example, instead of <div class="{{ val }}">, use <div :class="val">.`, el.rawAttrsMap["class"]);
        }
      }
      if (staticClass) {
        el.staticClass = JSON.stringify(staticClass.replace(/\s+/g, " ").trim());
      }
      const classBinding = getBindingAttr(
        el,
        "class",
        false
        /* getStatic */
      );
      if (classBinding) {
        el.classBinding = classBinding;
      }
    }
    function genData$2(el) {
      let data = "";
      if (el.staticClass) {
        data += `staticClass:${el.staticClass},`;
      }
      if (el.classBinding) {
        data += `class:${el.classBinding},`;
      }
      return data;
    }
    var klass = {
      staticKeys: ["staticClass"],
      transformNode: transformNode$1,
      genData: genData$2
    };
    var parseStyleText = cached(function(cssText) {
      const res = {};
      const listDelimiter = /;(?![^(]*\))/g;
      const propertyDelimiter = /:(.+)/;
      cssText.split(listDelimiter).forEach(function(item) {
        if (item) {
          const tmp = item.split(propertyDelimiter);
          tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return res;
    });
    function transformNode(el, options) {
      const warn3 = options.warn || baseWarn;
      const staticStyle = getAndRemoveAttr(el, "style");
      if (staticStyle) {
        if (true) {
          const res = parseText(staticStyle, options.delimiters);
          if (res) {
            warn3(`style="${staticStyle}": Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead. For example, instead of <div style="{{ val }}">, use <div :style="val">.`, el.rawAttrsMap["style"]);
          }
        }
        el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
      }
      const styleBinding = getBindingAttr(
        el,
        "style",
        false
        /* getStatic */
      );
      if (styleBinding) {
        el.styleBinding = styleBinding;
      }
    }
    function genData$1(el) {
      let data = "";
      if (el.staticStyle) {
        data += `staticStyle:${el.staticStyle},`;
      }
      if (el.styleBinding) {
        data += `style:(${el.styleBinding}),`;
      }
      return data;
    }
    var style = {
      staticKeys: ["staticStyle"],
      transformNode,
      genData: genData$1
    };
    function genComponentModel(el, value, modifiers) {
      const { number: number2, trim } = modifiers || {};
      const baseValueExpression = "$$v";
      let valueExpression = baseValueExpression;
      if (trim) {
        valueExpression = `(typeof ${baseValueExpression} === 'string'? ${baseValueExpression}.trim(): ${baseValueExpression})`;
      }
      if (number2) {
        valueExpression = `_n(${valueExpression})`;
      }
      const assignment = genAssignmentCode(value, valueExpression);
      el.model = {
        value: `(${value})`,
        expression: JSON.stringify(value),
        callback: `function (${baseValueExpression}) {${assignment}}`
      };
    }
    function genAssignmentCode(value, assignment) {
      const res = parseModel(value);
      if (res.key === null) {
        return `${value}=${assignment}`;
      } else {
        return `$set(${res.exp}, ${res.key}, ${assignment})`;
      }
    }
    var len;
    var str;
    var chr;
    var index2;
    var expressionPos;
    var expressionEndPos;
    function parseModel(val) {
      val = val.trim();
      len = val.length;
      if (val.indexOf("[") < 0 || val.lastIndexOf("]") < len - 1) {
        index2 = val.lastIndexOf(".");
        if (index2 > -1) {
          return {
            exp: val.slice(0, index2),
            key: '"' + val.slice(index2 + 1) + '"'
          };
        } else {
          return {
            exp: val,
            key: null
          };
        }
      }
      str = val;
      index2 = expressionPos = expressionEndPos = 0;
      while (!eof()) {
        chr = next();
        if (isStringStart(chr)) {
          parseString(chr);
        } else if (chr === 91) {
          parseBracket(chr);
        }
      }
      return {
        exp: val.slice(0, expressionPos),
        key: val.slice(expressionPos + 1, expressionEndPos)
      };
    }
    function next() {
      return str.charCodeAt(++index2);
    }
    function eof() {
      return index2 >= len;
    }
    function isStringStart(chr2) {
      return chr2 === 34 || chr2 === 39;
    }
    function parseBracket(chr2) {
      let inBracket = 1;
      expressionPos = index2;
      while (!eof()) {
        chr2 = next();
        if (isStringStart(chr2)) {
          parseString(chr2);
          continue;
        }
        if (chr2 === 91)
          inBracket++;
        if (chr2 === 93)
          inBracket--;
        if (inBracket === 0) {
          expressionEndPos = index2;
          break;
        }
      }
    }
    function parseString(chr2) {
      const stringQuote = chr2;
      while (!eof()) {
        chr2 = next();
        if (chr2 === stringQuote) {
          break;
        }
      }
    }
    var onRE = /^@|^v-on:/;
    var dirRE = /^v-|^@|^:|^#/;
    var forAliasRE2 = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    var forIteratorRE2 = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    var stripParensRE2 = /^\(|\)$/g;
    var dynamicArgRE = /^\[.*\]$/;
    var argRE = /:(.*)$/;
    var bindRE = /^:|^\.|^v-bind:/;
    var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;
    var slotRE = /^v-slot(:|$)|^#/;
    var lineBreakRE = /[\r\n]/;
    var whitespaceRE2 = /[ \f\t\r\n]+/g;
    var invalidAttributeRE = /[\s"'<>\/=]/;
    var decodeHTMLCached = cached(he__default["default"].decode);
    var emptySlotScopeToken = `_empty_`;
    var warn$1;
    var delimiters;
    var transforms;
    var preTransforms;
    var postTransforms;
    var platformIsPreTag;
    var platformMustUseProp;
    var platformGetTagNamespace;
    var maybeComponent;
    function createASTElement(tag, attrs, parent) {
      return {
        type: 1,
        tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        rawAttrsMap: {},
        parent,
        children: []
      };
    }
    function parse3(template, options) {
      warn$1 = options.warn || baseWarn;
      platformIsPreTag = options.isPreTag || no;
      platformMustUseProp = options.mustUseProp || no;
      platformGetTagNamespace = options.getTagNamespace || no;
      const isReservedTag2 = options.isReservedTag || no;
      maybeComponent = (el) => !!(el.component || el.attrsMap[":is"] || el.attrsMap["v-bind:is"] || !(el.attrsMap.is ? isReservedTag2(el.attrsMap.is) : isReservedTag2(el.tag)));
      transforms = pluckModuleFunction(options.modules, "transformNode");
      preTransforms = pluckModuleFunction(options.modules, "preTransformNode");
      postTransforms = pluckModuleFunction(options.modules, "postTransformNode");
      delimiters = options.delimiters;
      const stack2 = [];
      const preserveWhitespace = options.preserveWhitespace !== false;
      const whitespaceOption = options.whitespace;
      let root4;
      let currentParent;
      let inVPre2 = false;
      let inPre2 = false;
      let warned = false;
      function warnOnce(msg, range4) {
        if (!warned) {
          warned = true;
          warn$1(msg, range4);
        }
      }
      function closeElement(element3) {
        trimEndingWhitespace(element3);
        if (!inVPre2 && !element3.processed) {
          element3 = processElement(element3, options);
        }
        if (!stack2.length && element3 !== root4) {
          if (root4.if && (element3.elseif || element3.else)) {
            if (true) {
              checkRootConstraints(element3);
            }
            addIfCondition(root4, {
              exp: element3.elseif,
              block: element3
            });
          } else if (true) {
            warnOnce(`Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.`, { start: element3.start });
          }
        }
        if (currentParent && !element3.forbidden) {
          if (element3.elseif || element3.else) {
            processIfConditions(element3, currentParent);
          } else {
            if (element3.slotScope) {
              const name = element3.slotTarget || '"default"';
              (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element3;
            }
            currentParent.children.push(element3);
            element3.parent = currentParent;
          }
        }
        element3.children = element3.children.filter((c) => !c.slotScope);
        trimEndingWhitespace(element3);
        if (element3.pre) {
          inVPre2 = false;
        }
        if (platformIsPreTag(element3.tag)) {
          inPre2 = false;
        }
        for (let i = 0; i < postTransforms.length; i++) {
          postTransforms[i](element3, options);
        }
      }
      function trimEndingWhitespace(el) {
        if (!inPre2) {
          let lastNode;
          while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === " ") {
            el.children.pop();
          }
        }
      }
      function checkRootConstraints(el) {
        if (el.tag === "slot" || el.tag === "template") {
          warnOnce(`Cannot use <${el.tag}> as component root element because it may contain multiple nodes.`, { start: el.start });
        }
        if (el.attrsMap.hasOwnProperty("v-for")) {
          warnOnce("Cannot use v-for on stateful component root element because it renders multiple elements.", el.rawAttrsMap["v-for"]);
        }
      }
      parseHTML(template, {
        warn: warn$1,
        expectHTML: options.expectHTML,
        isUnaryTag: options.isUnaryTag,
        canBeLeftOpenTag: options.canBeLeftOpenTag,
        shouldDecodeNewlines: options.shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
        shouldKeepComment: options.comments,
        outputSourceRange: options.outputSourceRange,
        start(tag, attrs, unary, start, end) {
          const ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);
          if (isIE && ns === "svg") {
            attrs = guardIESVGBug(attrs);
          }
          let element3 = createASTElement(tag, attrs, currentParent);
          if (ns) {
            element3.ns = ns;
          }
          if (true) {
            if (options.outputSourceRange) {
              element3.start = start;
              element3.end = end;
              element3.rawAttrsMap = element3.attrsList.reduce((cumulated, attr) => {
                cumulated[attr.name] = attr;
                return cumulated;
              }, {});
            }
            attrs.forEach((attr) => {
              if (invalidAttributeRE.test(attr.name)) {
                warn$1(`Invalid dynamic argument expression: attribute names cannot contain spaces, quotes, <, >, / or =.`, options.outputSourceRange ? {
                  start: attr.start + attr.name.indexOf(`[`),
                  end: attr.start + attr.name.length
                } : void 0);
              }
            });
          }
          if (isForbiddenTag(element3) && !isServerRendering()) {
            element3.forbidden = true;
            warn$1(`Templates should only be responsible for mapping the state to the UI. Avoid placing tags with side-effects in your templates, such as <${tag}>, as they will not be parsed.`, { start: element3.start });
          }
          for (let i = 0; i < preTransforms.length; i++) {
            element3 = preTransforms[i](element3, options) || element3;
          }
          if (!inVPre2) {
            processPre(element3);
            if (element3.pre) {
              inVPre2 = true;
            }
          }
          if (platformIsPreTag(element3.tag)) {
            inPre2 = true;
          }
          if (inVPre2) {
            processRawAttrs(element3);
          } else if (!element3.processed) {
            processFor2(element3);
            processIf2(element3);
            processOnce(element3);
          }
          if (!root4) {
            root4 = element3;
            if (true) {
              checkRootConstraints(root4);
            }
          }
          if (!unary) {
            currentParent = element3;
            stack2.push(element3);
          } else {
            closeElement(element3);
          }
        },
        end(tag, start, end) {
          const element3 = stack2[stack2.length - 1];
          stack2.length -= 1;
          currentParent = stack2[stack2.length - 1];
          if (options.outputSourceRange) {
            element3.end = end;
          }
          closeElement(element3);
        },
        chars(text7, start, end) {
          if (!currentParent) {
            if (true) {
              if (text7 === template) {
                warnOnce("Component template requires a root element, rather than just text.", { start });
              } else if (text7 = text7.trim()) {
                warnOnce(`text "${text7}" outside root element will be ignored.`, {
                  start
                });
              }
            }
            return;
          }
          if (isIE && currentParent.tag === "textarea" && currentParent.attrsMap.placeholder === text7) {
            return;
          }
          const children = currentParent.children;
          if (inPre2 || text7.trim()) {
            text7 = isTextTag(currentParent) ? text7 : decodeHTMLCached(text7);
          } else if (!children.length) {
            text7 = "";
          } else if (whitespaceOption) {
            if (whitespaceOption === "condense") {
              text7 = lineBreakRE.test(text7) ? "" : " ";
            } else {
              text7 = " ";
            }
          } else {
            text7 = preserveWhitespace ? " " : "";
          }
          if (text7) {
            if (!inPre2 && whitespaceOption === "condense") {
              text7 = text7.replace(whitespaceRE2, " ");
            }
            let res;
            let child;
            if (!inVPre2 && text7 !== " " && (res = parseText(text7, delimiters))) {
              child = {
                type: 2,
                expression: res.expression,
                tokens: res.tokens,
                text: text7
              };
            } else if (text7 !== " " || !children.length || children[children.length - 1].text !== " ") {
              child = {
                type: 3,
                text: text7
              };
            }
            if (child) {
              if (options.outputSourceRange) {
                child.start = start;
                child.end = end;
              }
              children.push(child);
            }
          }
        },
        comment(text7, start, end) {
          if (currentParent) {
            const child = {
              type: 3,
              text: text7,
              isComment: true
            };
            if (options.outputSourceRange) {
              child.start = start;
              child.end = end;
            }
            currentParent.children.push(child);
          }
        }
      });
      return root4;
    }
    function processPre(el) {
      if (getAndRemoveAttr(el, "v-pre") != null) {
        el.pre = true;
      }
    }
    function processRawAttrs(el) {
      const list4 = el.attrsList;
      const len2 = list4.length;
      if (len2) {
        const attrs = el.attrs = new Array(len2);
        for (let i = 0; i < len2; i++) {
          attrs[i] = {
            name: list4[i].name,
            value: JSON.stringify(list4[i].value)
          };
          if (list4[i].start != null) {
            attrs[i].start = list4[i].start;
            attrs[i].end = list4[i].end;
          }
        }
      } else if (!el.pre) {
        el.plain = true;
      }
    }
    function processElement(element3, options) {
      processKey(element3);
      element3.plain = !element3.key && !element3.scopedSlots && !element3.attrsList.length;
      processRef(element3);
      processSlotContent(element3);
      processSlotOutlet2(element3);
      processComponent(element3);
      for (let i = 0; i < transforms.length; i++) {
        element3 = transforms[i](element3, options) || element3;
      }
      processAttrs(element3);
      return element3;
    }
    function processKey(el) {
      const exp = getBindingAttr(el, "key");
      if (exp) {
        if (true) {
          if (el.tag === "template") {
            warn$1(`<template> cannot be keyed. Place the key on real elements instead.`, getRawBindingAttr(el, "key"));
          }
          if (el.for) {
            const iterator = el.iterator2 || el.iterator1;
            const parent = el.parent;
            if (iterator && iterator === exp && parent && parent.tag === "transition-group") {
              warn$1(
                `Do not use v-for index as key on <transition-group> children, this is the same as not using keys.`,
                getRawBindingAttr(el, "key"),
                true
                /* tip */
              );
            }
          }
        }
        el.key = exp;
      }
    }
    function processRef(el) {
      const ref = getBindingAttr(el, "ref");
      if (ref) {
        el.ref = ref;
        el.refInFor = checkInFor(el);
      }
    }
    function processFor2(el) {
      let exp;
      if (exp = getAndRemoveAttr(el, "v-for")) {
        const res = parseFor(exp);
        if (res) {
          extend3(el, res);
        } else if (true) {
          warn$1(`Invalid v-for expression: ${exp}`, el.rawAttrsMap["v-for"]);
        }
      }
    }
    function parseFor(exp) {
      const inMatch = exp.match(forAliasRE2);
      if (!inMatch)
        return;
      const res = {};
      res.for = inMatch[2].trim();
      const alias = inMatch[1].trim().replace(stripParensRE2, "");
      const iteratorMatch = alias.match(forIteratorRE2);
      if (iteratorMatch) {
        res.alias = alias.replace(forIteratorRE2, "").trim();
        res.iterator1 = iteratorMatch[1].trim();
        if (iteratorMatch[2]) {
          res.iterator2 = iteratorMatch[2].trim();
        }
      } else {
        res.alias = alias;
      }
      return res;
    }
    function processIf2(el) {
      const exp = getAndRemoveAttr(el, "v-if");
      if (exp) {
        el.if = exp;
        addIfCondition(el, {
          exp,
          block: el
        });
      } else {
        if (getAndRemoveAttr(el, "v-else") != null) {
          el.else = true;
        }
        const elseif = getAndRemoveAttr(el, "v-else-if");
        if (elseif) {
          el.elseif = elseif;
        }
      }
    }
    function processIfConditions(el, parent) {
      const prev = findPrevElement(parent.children);
      if (prev && prev.if) {
        addIfCondition(prev, {
          exp: el.elseif,
          block: el
        });
      } else if (true) {
        warn$1(`v-${el.elseif ? 'else-if="' + el.elseif + '"' : "else"} used on element <${el.tag}> without corresponding v-if.`, el.rawAttrsMap[el.elseif ? "v-else-if" : "v-else"]);
      }
    }
    function findPrevElement(children) {
      let i = children.length;
      while (i--) {
        if (children[i].type === 1) {
          return children[i];
        } else {
          if (children[i].text !== " ") {
            warn$1(`text "${children[i].text.trim()}" between v-if and v-else(-if) will be ignored.`, children[i]);
          }
          children.pop();
        }
      }
    }
    function addIfCondition(el, condition) {
      if (!el.ifConditions) {
        el.ifConditions = [];
      }
      el.ifConditions.push(condition);
    }
    function processOnce(el) {
      const once = getAndRemoveAttr(el, "v-once");
      if (once != null) {
        el.once = true;
      }
    }
    function processSlotContent(el) {
      let slotScope;
      if (el.tag === "template") {
        slotScope = getAndRemoveAttr(el, "scope");
        if (slotScope) {
          warn$1(`the "scope" attribute for scoped slots have been deprecated and replaced by "slot-scope" since 2.5. The new "slot-scope" attribute can also be used on plain elements in addition to <template> to denote scoped slots.`, el.rawAttrsMap["scope"], true);
        }
        el.slotScope = slotScope || getAndRemoveAttr(el, "slot-scope");
      } else if (slotScope = getAndRemoveAttr(el, "slot-scope")) {
        if (el.attrsMap["v-for"]) {
          warn$1(`Ambiguous combined usage of slot-scope and v-for on <${el.tag}> (v-for takes higher priority). Use a wrapper <template> for the scoped slot to make it clearer.`, el.rawAttrsMap["slot-scope"], true);
        }
        el.slotScope = slotScope;
      }
      const slotTarget = getBindingAttr(el, "slot");
      if (slotTarget) {
        el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
        el.slotTargetDynamic = !!(el.attrsMap[":slot"] || el.attrsMap["v-bind:slot"]);
        if (el.tag !== "template" && !el.slotScope) {
          addAttr(el, "slot", slotTarget, getRawBindingAttr(el, "slot"));
        }
      }
      {
        if (el.tag === "template") {
          const slotBinding = getAndRemoveAttrByRegex(el, slotRE);
          if (slotBinding) {
            if (true) {
              if (el.slotTarget || el.slotScope) {
                warn$1(`Unexpected mixed usage of different slot syntaxes.`, el);
              }
              if (el.parent && !maybeComponent(el.parent)) {
                warn$1(`<template v-slot> can only appear at the root level inside the receiving component`, el);
              }
            }
            const { name, dynamic } = getSlotName(slotBinding);
            el.slotTarget = name;
            el.slotTargetDynamic = dynamic;
            el.slotScope = slotBinding.value || emptySlotScopeToken;
          }
        } else {
          const slotBinding = getAndRemoveAttrByRegex(el, slotRE);
          if (slotBinding) {
            if (true) {
              if (!maybeComponent(el)) {
                warn$1(`v-slot can only be used on components or <template>.`, slotBinding);
              }
              if (el.slotScope || el.slotTarget) {
                warn$1(`Unexpected mixed usage of different slot syntaxes.`, el);
              }
              if (el.scopedSlots) {
                warn$1(`To avoid scope ambiguity, the default slot should also use <template> syntax when there are other named slots.`, slotBinding);
              }
            }
            const slots = el.scopedSlots || (el.scopedSlots = {});
            const { name, dynamic } = getSlotName(slotBinding);
            const slotContainer = slots[name] = createASTElement("template", [], el);
            slotContainer.slotTarget = name;
            slotContainer.slotTargetDynamic = dynamic;
            slotContainer.children = el.children.filter((c) => {
              if (!c.slotScope) {
                c.parent = slotContainer;
                return true;
              }
            });
            slotContainer.slotScope = slotBinding.value || emptySlotScopeToken;
            el.children = [];
            el.plain = false;
          }
        }
      }
    }
    function getSlotName(binding) {
      let name = binding.name.replace(slotRE, "");
      if (!name) {
        if (binding.name[0] !== "#") {
          name = "default";
        } else if (true) {
          warn$1(`v-slot shorthand syntax requires a slot name.`, binding);
        }
      }
      return dynamicArgRE.test(name) ? (
        // dynamic [name]
        { name: name.slice(1, -1), dynamic: true }
      ) : (
        // static name
        { name: `"${name}"`, dynamic: false }
      );
    }
    function processSlotOutlet2(el) {
      if (el.tag === "slot") {
        el.slotName = getBindingAttr(el, "name");
        if (el.key) {
          warn$1(`\`key\` does not work on <slot> because slots are abstract outlets and can possibly expand into multiple elements. Use the key on a wrapping element instead.`, getRawBindingAttr(el, "key"));
        }
      }
    }
    function processComponent(el) {
      let binding;
      if (binding = getBindingAttr(el, "is")) {
        el.component = binding;
      }
      if (getAndRemoveAttr(el, "inline-template") != null) {
        el.inlineTemplate = true;
      }
    }
    function processAttrs(el) {
      const list4 = el.attrsList;
      let i, l, name, rawName, value, modifiers, syncGen, isDynamic;
      for (i = 0, l = list4.length; i < l; i++) {
        name = rawName = list4[i].name;
        value = list4[i].value;
        if (dirRE.test(name)) {
          el.hasBindings = true;
          modifiers = parseModifiers(name.replace(dirRE, ""));
          if (modifiers) {
            name = name.replace(modifierRE, "");
          }
          if (bindRE.test(name)) {
            name = name.replace(bindRE, "");
            value = parseFilters(value);
            isDynamic = dynamicArgRE.test(name);
            if (isDynamic) {
              name = name.slice(1, -1);
            }
            if (value.trim().length === 0) {
              warn$1(`The value for a v-bind expression cannot be empty. Found in "v-bind:${name}"`);
            }
            if (modifiers) {
              if (modifiers.prop && !isDynamic) {
                name = camelize2(name);
                if (name === "innerHtml")
                  name = "innerHTML";
              }
              if (modifiers.camel && !isDynamic) {
                name = camelize2(name);
              }
              if (modifiers.sync) {
                syncGen = genAssignmentCode(value, `$event`);
                if (!isDynamic) {
                  addHandler(el, `update:${camelize2(name)}`, syncGen, null, false, warn$1, list4[i]);
                  if (hyphenate2(name) !== camelize2(name)) {
                    addHandler(el, `update:${hyphenate2(name)}`, syncGen, null, false, warn$1, list4[i]);
                  }
                } else {
                  addHandler(
                    el,
                    `"update:"+(${name})`,
                    syncGen,
                    null,
                    false,
                    warn$1,
                    list4[i],
                    true
                    // dynamic
                  );
                }
              }
            }
            if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
              addProp(el, name, value, list4[i], isDynamic);
            } else {
              addAttr(el, name, value, list4[i], isDynamic);
            }
          } else if (onRE.test(name)) {
            name = name.replace(onRE, "");
            isDynamic = dynamicArgRE.test(name);
            if (isDynamic) {
              name = name.slice(1, -1);
            }
            addHandler(el, name, value, modifiers, false, warn$1, list4[i], isDynamic);
          } else {
            name = name.replace(dirRE, "");
            const argMatch = name.match(argRE);
            let arg = argMatch && argMatch[1];
            isDynamic = false;
            if (arg) {
              name = name.slice(0, -(arg.length + 1));
              if (dynamicArgRE.test(arg)) {
                arg = arg.slice(1, -1);
                isDynamic = true;
              }
            }
            addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list4[i]);
            if (name === "model") {
              checkForAliasModel(el, value);
            }
          }
        } else {
          if (true) {
            const res = parseText(value, delimiters);
            if (res) {
              warn$1(`${name}="${value}": Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead. For example, instead of <div id="{{ val }}">, use <div :id="val">.`, list4[i]);
            }
          }
          addAttr(el, name, JSON.stringify(value), list4[i]);
          if (!el.component && name === "muted" && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
            addProp(el, name, "true", list4[i]);
          }
        }
      }
    }
    function checkInFor(el) {
      let parent = el;
      while (parent) {
        if (parent.for !== void 0) {
          return true;
        }
        parent = parent.parent;
      }
      return false;
    }
    function parseModifiers(name) {
      const match = name.match(modifierRE);
      if (match) {
        const ret = {};
        match.forEach((m) => {
          ret[m.slice(1)] = true;
        });
        return ret;
      }
    }
    function makeAttrsMap(attrs) {
      const map = {};
      for (let i = 0, l = attrs.length; i < l; i++) {
        if (map[attrs[i].name] && !isIE && !isEdge) {
          warn$1("duplicate attribute: " + attrs[i].name, attrs[i]);
        }
        map[attrs[i].name] = attrs[i].value;
      }
      return map;
    }
    function isTextTag(el) {
      return el.tag === "script" || el.tag === "style";
    }
    function isForbiddenTag(el) {
      return el.tag === "style" || el.tag === "script" && (!el.attrsMap.type || el.attrsMap.type === "text/javascript");
    }
    var ieNSBug = /^xmlns:NS\d+/;
    var ieNSPrefix = /^NS\d+:/;
    function guardIESVGBug(attrs) {
      const res = [];
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (!ieNSBug.test(attr.name)) {
          attr.name = attr.name.replace(ieNSPrefix, "");
          res.push(attr);
        }
      }
      return res;
    }
    function checkForAliasModel(el, value) {
      let _el = el;
      while (_el) {
        if (_el.for && _el.alias === value) {
          warn$1(`<${el.tag} v-model="${value}">: You are binding v-model directly to a v-for iteration alias. This will not be able to modify the v-for source array because writing to the alias is like modifying a function local variable. Consider using an array of objects and use v-model on an object property instead.`, el.rawAttrsMap["v-model"]);
        }
        _el = _el.parent;
      }
    }
    function preTransformNode(el, options) {
      if (el.tag === "input") {
        const map = el.attrsMap;
        if (!map["v-model"]) {
          return;
        }
        let typeBinding;
        if (map[":type"] || map["v-bind:type"]) {
          typeBinding = getBindingAttr(el, "type");
        }
        if (!map.type && !typeBinding && map["v-bind"]) {
          typeBinding = `(${map["v-bind"]}).type`;
        }
        if (typeBinding) {
          const ifCondition = getAndRemoveAttr(el, "v-if", true);
          const ifConditionExtra = ifCondition ? `&&(${ifCondition})` : ``;
          const hasElse = getAndRemoveAttr(el, "v-else", true) != null;
          const elseIfCondition = getAndRemoveAttr(el, "v-else-if", true);
          const branch0 = cloneASTElement(el);
          processFor2(branch0);
          addRawAttr(branch0, "type", "checkbox");
          processElement(branch0, options);
          branch0.processed = true;
          branch0.if = `(${typeBinding})==='checkbox'` + ifConditionExtra;
          addIfCondition(branch0, {
            exp: branch0.if,
            block: branch0
          });
          const branch1 = cloneASTElement(el);
          getAndRemoveAttr(branch1, "v-for", true);
          addRawAttr(branch1, "type", "radio");
          processElement(branch1, options);
          addIfCondition(branch0, {
            exp: `(${typeBinding})==='radio'` + ifConditionExtra,
            block: branch1
          });
          const branch2 = cloneASTElement(el);
          getAndRemoveAttr(branch2, "v-for", true);
          addRawAttr(branch2, ":type", typeBinding);
          processElement(branch2, options);
          addIfCondition(branch0, {
            exp: ifCondition,
            block: branch2
          });
          if (hasElse) {
            branch0.else = true;
          } else if (elseIfCondition) {
            branch0.elseif = elseIfCondition;
          }
          return branch0;
        }
      }
    }
    function cloneASTElement(el) {
      return createASTElement(el.tag, el.attrsList.slice(), el.parent);
    }
    var model$1 = {
      preTransformNode
    };
    var modules = [klass, style, model$1];
    var warn2;
    var RANGE_TOKEN = "__r";
    function model(el, dir, _warn) {
      warn2 = _warn;
      const value = dir.value;
      const modifiers = dir.modifiers;
      const tag = el.tag;
      const type = el.attrsMap.type;
      if (true) {
        if (tag === "input" && type === "file") {
          warn2(`<${el.tag} v-model="${value}" type="file">:
File inputs are read only. Use a v-on:change listener instead.`, el.rawAttrsMap["v-model"]);
        }
      }
      if (el.component) {
        genComponentModel(el, value, modifiers);
        return false;
      } else if (tag === "select") {
        genSelect(el, value, modifiers);
      } else if (tag === "input" && type === "checkbox") {
        genCheckboxModel(el, value, modifiers);
      } else if (tag === "input" && type === "radio") {
        genRadioModel(el, value, modifiers);
      } else if (tag === "input" || tag === "textarea") {
        genDefaultModel(el, value, modifiers);
      } else {
        genComponentModel(el, value, modifiers);
        return false;
      }
      return true;
    }
    function genCheckboxModel(el, value, modifiers) {
      const number2 = modifiers && modifiers.number;
      const valueBinding = getBindingAttr(el, "value") || "null";
      const trueValueBinding = getBindingAttr(el, "true-value") || "true";
      const falseValueBinding = getBindingAttr(el, "false-value") || "false";
      addProp(el, "checked", `Array.isArray(${value})?_i(${value},${valueBinding})>-1` + (trueValueBinding === "true" ? `:(${value})` : `:_q(${value},${trueValueBinding})`));
      addHandler(el, "change", `var $$a=${value},$$el=$event.target,$$c=$$el.checked?(${trueValueBinding}):(${falseValueBinding});if(Array.isArray($$a)){var $$v=${number2 ? "_n(" + valueBinding + ")" : valueBinding},$$i=_i($$a,$$v);if($$el.checked){$$i<0&&(${genAssignmentCode(value, "$$a.concat([$$v])")})}else{$$i>-1&&(${genAssignmentCode(value, "$$a.slice(0,$$i).concat($$a.slice($$i+1))")})}}else{${genAssignmentCode(value, "$$c")}}`, null, true);
    }
    function genRadioModel(el, value, modifiers) {
      const number2 = modifiers && modifiers.number;
      let valueBinding = getBindingAttr(el, "value") || "null";
      valueBinding = number2 ? `_n(${valueBinding})` : valueBinding;
      addProp(el, "checked", `_q(${value},${valueBinding})`);
      addHandler(el, "change", genAssignmentCode(value, valueBinding), null, true);
    }
    function genSelect(el, value, modifiers) {
      const number2 = modifiers && modifiers.number;
      const selectedVal = `Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return ${number2 ? "_n(val)" : "val"}})`;
      const assignment = "$event.target.multiple ? $$selectedVal : $$selectedVal[0]";
      let code3 = `var $$selectedVal = ${selectedVal};`;
      code3 = `${code3} ${genAssignmentCode(value, assignment)}`;
      addHandler(el, "change", code3, null, true);
    }
    function genDefaultModel(el, value, modifiers) {
      const type = el.attrsMap.type;
      if (true) {
        const value2 = el.attrsMap["v-bind:value"] || el.attrsMap[":value"];
        const typeBinding = el.attrsMap["v-bind:type"] || el.attrsMap[":type"];
        if (value2 && !typeBinding) {
          const binding = el.attrsMap["v-bind:value"] ? "v-bind:value" : ":value";
          warn2(`${binding}="${value2}" conflicts with v-model on the same element because the latter already expands to a value binding internally`, el.rawAttrsMap[binding]);
        }
      }
      const { lazy, number: number2, trim } = modifiers || {};
      const needCompositionGuard = !lazy && type !== "range";
      const event = lazy ? "change" : type === "range" ? RANGE_TOKEN : "input";
      let valueExpression = "$event.target.value";
      if (trim) {
        valueExpression = `$event.target.value.trim()`;
      }
      if (number2) {
        valueExpression = `_n(${valueExpression})`;
      }
      let code3 = genAssignmentCode(value, valueExpression);
      if (needCompositionGuard) {
        code3 = `if($event.target.composing)return;${code3}`;
      }
      addProp(el, "value", `(${value})`);
      addHandler(el, event, code3, null, true);
      if (trim || number2) {
        addHandler(el, "blur", "$forceUpdate()");
      }
    }
    function text6(el, dir) {
      if (dir.value) {
        addProp(el, "textContent", `_s(${dir.value})`, dir);
      }
    }
    function html7(el, dir) {
      if (dir.value) {
        addProp(el, "innerHTML", `_s(${dir.value})`, dir);
      }
    }
    var directives = {
      model,
      text: text6,
      html: html7
    };
    var baseOptions = {
      expectHTML: true,
      modules,
      directives,
      isPreTag,
      isUnaryTag,
      mustUseProp,
      canBeLeftOpenTag,
      isReservedTag,
      getTagNamespace,
      staticKeys: genStaticKeys$1(modules)
    };
    var isStaticKey;
    var isPlatformReservedTag$1;
    var genStaticKeysCached = cached(genStaticKeys);
    function optimize$1(root4, options) {
      if (!root4)
        return;
      isStaticKey = genStaticKeysCached(options.staticKeys || "");
      isPlatformReservedTag$1 = options.isReservedTag || no;
      markStatic(root4);
      markStaticRoots(root4, false);
    }
    function genStaticKeys(keys2) {
      return makeMap2("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap" + (keys2 ? "," + keys2 : ""));
    }
    function markStatic(node2) {
      node2.static = isStatic(node2);
      if (node2.type === 1) {
        if (!isPlatformReservedTag$1(node2.tag) && node2.tag !== "slot" && node2.attrsMap["inline-template"] == null) {
          return;
        }
        for (let i = 0, l = node2.children.length; i < l; i++) {
          const child = node2.children[i];
          markStatic(child);
          if (!child.static) {
            node2.static = false;
          }
        }
        if (node2.ifConditions) {
          for (let i = 1, l = node2.ifConditions.length; i < l; i++) {
            const block = node2.ifConditions[i].block;
            markStatic(block);
            if (!block.static) {
              node2.static = false;
            }
          }
        }
      }
    }
    function markStaticRoots(node2, isInFor) {
      if (node2.type === 1) {
        if (node2.static || node2.once) {
          node2.staticInFor = isInFor;
        }
        if (node2.static && node2.children.length && !(node2.children.length === 1 && node2.children[0].type === 3)) {
          node2.staticRoot = true;
          return;
        } else {
          node2.staticRoot = false;
        }
        if (node2.children) {
          for (let i = 0, l = node2.children.length; i < l; i++) {
            markStaticRoots(node2.children[i], isInFor || !!node2.for);
          }
        }
        if (node2.ifConditions) {
          for (let i = 1, l = node2.ifConditions.length; i < l; i++) {
            markStaticRoots(node2.ifConditions[i].block, isInFor);
          }
        }
      }
    }
    function isStatic(node2) {
      if (node2.type === 2) {
        return false;
      }
      if (node2.type === 3) {
        return true;
      }
      return !!(node2.pre || !node2.hasBindings && // no dynamic bindings
      !node2.if && !node2.for && // not v-if or v-for or v-else
      !isBuiltInTag(node2.tag) && // not a built-in
      isPlatformReservedTag$1(node2.tag) && // not a component
      !isDirectChildOfTemplateFor(node2) && Object.keys(node2).every(isStaticKey));
    }
    function isDirectChildOfTemplateFor(node2) {
      while (node2.parent) {
        node2 = node2.parent;
        if (node2.tag !== "template") {
          return false;
        }
        if (node2.for) {
          return true;
        }
      }
      return false;
    }
    var fnExpRE2 = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
    var fnInvokeRE = /\([^)]*?\);*$/;
    var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;
    var keyCodes = {
      esc: 27,
      tab: 9,
      enter: 13,
      space: 32,
      up: 38,
      left: 37,
      right: 39,
      down: 40,
      delete: [8, 46]
    };
    var keyNames = {
      // #7880: IE11 and Edge use `Esc` for Escape key name.
      esc: ["Esc", "Escape"],
      tab: "Tab",
      enter: "Enter",
      // #9112: IE11 uses `Spacebar` for Space key name.
      space: [" ", "Spacebar"],
      // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
      up: ["Up", "ArrowUp"],
      left: ["Left", "ArrowLeft"],
      right: ["Right", "ArrowRight"],
      down: ["Down", "ArrowDown"],
      // #9112: IE11 uses `Del` for Delete key name.
      delete: ["Backspace", "Delete", "Del"]
    };
    var genGuard = (condition) => `if(${condition})return null;`;
    var modifierCode = {
      stop: "$event.stopPropagation();",
      prevent: "$event.preventDefault();",
      self: genGuard(`$event.target !== $event.currentTarget`),
      ctrl: genGuard(`!$event.ctrlKey`),
      shift: genGuard(`!$event.shiftKey`),
      alt: genGuard(`!$event.altKey`),
      meta: genGuard(`!$event.metaKey`),
      left: genGuard(`'button' in $event && $event.button !== 0`),
      middle: genGuard(`'button' in $event && $event.button !== 1`),
      right: genGuard(`'button' in $event && $event.button !== 2`)
    };
    function genHandlers(events, isNative2) {
      const prefix = isNative2 ? "nativeOn:" : "on:";
      let staticHandlers = ``;
      let dynamicHandlers = ``;
      for (const name in events) {
        const handlerCode = genHandler(events[name]);
        if (events[name] && events[name].dynamic) {
          dynamicHandlers += `${name},${handlerCode},`;
        } else {
          staticHandlers += `"${name}":${handlerCode},`;
        }
      }
      staticHandlers = `{${staticHandlers.slice(0, -1)}}`;
      if (dynamicHandlers) {
        return prefix + `_d(${staticHandlers},[${dynamicHandlers.slice(0, -1)}])`;
      } else {
        return prefix + staticHandlers;
      }
    }
    function genHandler(handler) {
      if (!handler) {
        return "function(){}";
      }
      if (Array.isArray(handler)) {
        return `[${handler.map((handler2) => genHandler(handler2)).join(",")}]`;
      }
      const isMethodPath = simplePathRE.test(handler.value);
      const isFunctionExpression = fnExpRE2.test(handler.value);
      const isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ""));
      if (!handler.modifiers) {
        if (isMethodPath || isFunctionExpression) {
          return handler.value;
        }
        return `function($event){${isFunctionInvocation ? `return ${handler.value}` : handler.value}}`;
      } else {
        let code3 = "";
        let genModifierCode = "";
        const keys2 = [];
        for (const key2 in handler.modifiers) {
          if (modifierCode[key2]) {
            genModifierCode += modifierCode[key2];
            if (keyCodes[key2]) {
              keys2.push(key2);
            }
          } else if (key2 === "exact") {
            const modifiers = handler.modifiers;
            genModifierCode += genGuard(["ctrl", "shift", "alt", "meta"].filter((keyModifier) => !modifiers[keyModifier]).map((keyModifier) => `$event.${keyModifier}Key`).join("||"));
          } else {
            keys2.push(key2);
          }
        }
        if (keys2.length) {
          code3 += genKeyFilter(keys2);
        }
        if (genModifierCode) {
          code3 += genModifierCode;
        }
        const handlerCode = isMethodPath ? `return ${handler.value}.apply(null, arguments)` : isFunctionExpression ? `return (${handler.value}).apply(null, arguments)` : isFunctionInvocation ? `return ${handler.value}` : handler.value;
        return `function($event){${code3}${handlerCode}}`;
      }
    }
    function genKeyFilter(keys2) {
      return (
        // make sure the key filters only apply to KeyboardEvents
        // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
        // key events that do not have keyCode property...
        `if(!$event.type.indexOf('key')&&${keys2.map(genFilterCode).join("&&")})return null;`
      );
    }
    function genFilterCode(key2) {
      const keyVal = parseInt(key2, 10);
      if (keyVal) {
        return `$event.keyCode!==${keyVal}`;
      }
      const keyCode = keyCodes[key2];
      const keyName = keyNames[key2];
      return `_k($event.keyCode,${JSON.stringify(key2)},${JSON.stringify(keyCode)},$event.key,${JSON.stringify(keyName)})`;
    }
    function on(el, dir) {
      if (dir.modifiers) {
        warn$2(`v-on without argument does not support modifiers.`);
      }
      el.wrapListeners = (code3) => `_g(${code3},${dir.value})`;
    }
    function bind(el, dir) {
      el.wrapData = (code3) => {
        return `_b(${code3},'${el.tag}',${dir.value},${dir.modifiers && dir.modifiers.prop ? "true" : "false"}${dir.modifiers && dir.modifiers.sync ? ",true" : ""})`;
      };
    }
    var baseDirectives = {
      on,
      bind,
      cloak: noop
    };
    var CodegenState = class {
      constructor(options) {
        this.options = options;
        this.warn = options.warn || baseWarn;
        this.transforms = pluckModuleFunction(options.modules, "transformCode");
        this.dataGenFns = pluckModuleFunction(options.modules, "genData");
        this.directives = extend3(extend3({}, baseDirectives), options.directives);
        const isReservedTag2 = options.isReservedTag || no;
        this.maybeComponent = (el) => !!el.component || !isReservedTag2(el.tag);
        this.onceId = 0;
        this.staticRenderFns = [];
        this.pre = false;
      }
    };
    function generate$1(ast, options) {
      const state = new CodegenState(options);
      const code3 = ast ? ast.tag === "script" ? "null" : genElement(ast, state) : '_c("div")';
      return {
        render: `with(this){return ${code3}}`,
        staticRenderFns: state.staticRenderFns
      };
    }
    function genElement(el, state) {
      if (el.parent) {
        el.pre = el.pre || el.parent.pre;
      }
      if (el.staticRoot && !el.staticProcessed) {
        return genStatic(el, state);
      } else if (el.once && !el.onceProcessed) {
        return genOnce(el, state);
      } else if (el.for && !el.forProcessed) {
        return genFor(el, state);
      } else if (el.if && !el.ifProcessed) {
        return genIf(el, state);
      } else if (el.tag === "template" && !el.slotTarget && !state.pre) {
        return genChildren(el, state) || "void 0";
      } else if (el.tag === "slot") {
        return genSlot(el, state);
      } else {
        let code3;
        if (el.component) {
          code3 = genComponent(el.component, el, state);
        } else {
          let data;
          const maybeComponent2 = state.maybeComponent(el);
          if (!el.plain || el.pre && maybeComponent2) {
            data = genData(el, state);
          }
          let tag;
          const bindings = state.options.bindings;
          if (maybeComponent2 && bindings && bindings.__isScriptSetup !== false) {
            tag = checkBindingType(bindings, el.tag);
          }
          if (!tag)
            tag = `'${el.tag}'`;
          const children = el.inlineTemplate ? null : genChildren(el, state, true);
          code3 = `_c(${tag}${data ? `,${data}` : ""}${children ? `,${children}` : ""})`;
        }
        for (let i = 0; i < state.transforms.length; i++) {
          code3 = state.transforms[i](el, code3);
        }
        return code3;
      }
    }
    function checkBindingType(bindings, key2) {
      const camelName = camelize2(key2);
      const PascalName = capitalize2(camelName);
      const checkType = (type) => {
        if (bindings[key2] === type) {
          return key2;
        }
        if (bindings[camelName] === type) {
          return camelName;
        }
        if (bindings[PascalName] === type) {
          return PascalName;
        }
      };
      const fromConst = checkType(
        "setup-const"
        /* BindingTypes.SETUP_CONST */
      ) || checkType(
        "setup-reactive-const"
        /* BindingTypes.SETUP_REACTIVE_CONST */
      );
      if (fromConst) {
        return fromConst;
      }
      const fromMaybeRef = checkType(
        "setup-let"
        /* BindingTypes.SETUP_LET */
      ) || checkType(
        "setup-ref"
        /* BindingTypes.SETUP_REF */
      ) || checkType(
        "setup-maybe-ref"
        /* BindingTypes.SETUP_MAYBE_REF */
      );
      if (fromMaybeRef) {
        return fromMaybeRef;
      }
    }
    function genStatic(el, state) {
      el.staticProcessed = true;
      const originalPreState = state.pre;
      if (el.pre) {
        state.pre = el.pre;
      }
      state.staticRenderFns.push(`with(this){return ${genElement(el, state)}}`);
      state.pre = originalPreState;
      return `_m(${state.staticRenderFns.length - 1}${el.staticInFor ? ",true" : ""})`;
    }
    function genOnce(el, state) {
      el.onceProcessed = true;
      if (el.if && !el.ifProcessed) {
        return genIf(el, state);
      } else if (el.staticInFor) {
        let key2 = "";
        let parent = el.parent;
        while (parent) {
          if (parent.for) {
            key2 = parent.key;
            break;
          }
          parent = parent.parent;
        }
        if (!key2) {
          state.warn(`v-once can only be used inside v-for that is keyed. `, el.rawAttrsMap["v-once"]);
          return genElement(el, state);
        }
        return `_o(${genElement(el, state)},${state.onceId++},${key2})`;
      } else {
        return genStatic(el, state);
      }
    }
    function genIf(el, state, altGen, altEmpty) {
      el.ifProcessed = true;
      return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
    }
    function genIfConditions(conditions, state, altGen, altEmpty) {
      if (!conditions.length) {
        return altEmpty || "_e()";
      }
      const condition = conditions.shift();
      if (condition.exp) {
        return `(${condition.exp})?${genTernaryExp(condition.block)}:${genIfConditions(conditions, state, altGen, altEmpty)}`;
      } else {
        return `${genTernaryExp(condition.block)}`;
      }
      function genTernaryExp(el) {
        return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
      }
    }
    function genFor(el, state, altGen, altHelper) {
      const exp = el.for;
      const alias = el.alias;
      const iterator1 = el.iterator1 ? `,${el.iterator1}` : "";
      const iterator2 = el.iterator2 ? `,${el.iterator2}` : "";
      if (state.maybeComponent(el) && el.tag !== "slot" && el.tag !== "template" && !el.key) {
        state.warn(
          `<${el.tag} v-for="${alias} in ${exp}">: component lists rendered with v-for should have explicit keys. See https://v2.vuejs.org/v2/guide/list.html#key for more info.`,
          el.rawAttrsMap["v-for"],
          true
          /* tip */
        );
      }
      el.forProcessed = true;
      return `${altHelper || "_l"}((${exp}),function(${alias}${iterator1}${iterator2}){return ${(altGen || genElement)(el, state)}})`;
    }
    function genData(el, state) {
      let data = "{";
      const dirs = genDirectives(el, state);
      if (dirs)
        data += dirs + ",";
      if (el.key) {
        data += `key:${el.key},`;
      }
      if (el.ref) {
        data += `ref:${el.ref},`;
      }
      if (el.refInFor) {
        data += `refInFor:true,`;
      }
      if (el.pre) {
        data += `pre:true,`;
      }
      if (el.component) {
        data += `tag:"${el.tag}",`;
      }
      for (let i = 0; i < state.dataGenFns.length; i++) {
        data += state.dataGenFns[i](el);
      }
      if (el.attrs) {
        data += `attrs:${genProps(el.attrs)},`;
      }
      if (el.props) {
        data += `domProps:${genProps(el.props)},`;
      }
      if (el.events) {
        data += `${genHandlers(el.events, false)},`;
      }
      if (el.nativeEvents) {
        data += `${genHandlers(el.nativeEvents, true)},`;
      }
      if (el.slotTarget && !el.slotScope) {
        data += `slot:${el.slotTarget},`;
      }
      if (el.scopedSlots) {
        data += `${genScopedSlots(el, el.scopedSlots, state)},`;
      }
      if (el.model) {
        data += `model:{value:${el.model.value},callback:${el.model.callback},expression:${el.model.expression}},`;
      }
      if (el.inlineTemplate) {
        const inlineTemplate = genInlineTemplate(el, state);
        if (inlineTemplate) {
          data += `${inlineTemplate},`;
        }
      }
      data = data.replace(/,$/, "") + "}";
      if (el.dynamicAttrs) {
        data = `_b(${data},"${el.tag}",${genProps(el.dynamicAttrs)})`;
      }
      if (el.wrapData) {
        data = el.wrapData(data);
      }
      if (el.wrapListeners) {
        data = el.wrapListeners(data);
      }
      return data;
    }
    function genDirectives(el, state) {
      const dirs = el.directives;
      if (!dirs)
        return;
      let res = "directives:[";
      let hasRuntime = false;
      let i, l, dir, needRuntime;
      for (i = 0, l = dirs.length; i < l; i++) {
        dir = dirs[i];
        needRuntime = true;
        const gen = state.directives[dir.name];
        if (gen) {
          needRuntime = !!gen(el, dir, state.warn);
        }
        if (needRuntime) {
          hasRuntime = true;
          res += `{name:"${dir.name}",rawName:"${dir.rawName}"${dir.value ? `,value:(${dir.value}),expression:${JSON.stringify(dir.value)}` : ""}${dir.arg ? `,arg:${dir.isDynamicArg ? dir.arg : `"${dir.arg}"`}` : ""}${dir.modifiers ? `,modifiers:${JSON.stringify(dir.modifiers)}` : ""}},`;
        }
      }
      if (hasRuntime) {
        return res.slice(0, -1) + "]";
      }
    }
    function genInlineTemplate(el, state) {
      const ast = el.children[0];
      if (el.children.length !== 1 || ast.type !== 1) {
        state.warn("Inline-template components must have exactly one child element.", { start: el.start });
      }
      if (ast && ast.type === 1) {
        const inlineRenderFns = generate$1(ast, state.options);
        return `inlineTemplate:{render:function(){${inlineRenderFns.render}},staticRenderFns:[${inlineRenderFns.staticRenderFns.map((code3) => `function(){${code3}}`).join(",")}]}`;
      }
    }
    function genScopedSlots(el, slots, state) {
      let needsForceUpdate = el.for || Object.keys(slots).some((key2) => {
        const slot = slots[key2];
        return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot);
      });
      let needsKey = !!el.if;
      if (!needsForceUpdate) {
        let parent = el.parent;
        while (parent) {
          if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {
            needsForceUpdate = true;
            break;
          }
          if (parent.if) {
            needsKey = true;
          }
          parent = parent.parent;
        }
      }
      const generatedSlots = Object.keys(slots).map((key2) => genScopedSlot(slots[key2], state)).join(",");
      return `scopedSlots:_u([${generatedSlots}]${needsForceUpdate ? `,null,true` : ``}${!needsForceUpdate && needsKey ? `,null,false,${hash(generatedSlots)}` : ``})`;
    }
    function hash(str2) {
      let hash2 = 5381;
      let i = str2.length;
      while (i) {
        hash2 = hash2 * 33 ^ str2.charCodeAt(--i);
      }
      return hash2 >>> 0;
    }
    function containsSlotChild(el) {
      if (el.type === 1) {
        if (el.tag === "slot") {
          return true;
        }
        return el.children.some(containsSlotChild);
      }
      return false;
    }
    function genScopedSlot(el, state) {
      const isLegacySyntax = el.attrsMap["slot-scope"];
      if (el.if && !el.ifProcessed && !isLegacySyntax) {
        return genIf(el, state, genScopedSlot, `null`);
      }
      if (el.for && !el.forProcessed) {
        return genFor(el, state, genScopedSlot);
      }
      const slotScope = el.slotScope === emptySlotScopeToken ? `` : String(el.slotScope);
      const fn = `function(${slotScope}){return ${el.tag === "template" ? el.if && isLegacySyntax ? `(${el.if})?${genChildren(el, state) || "undefined"}:undefined` : genChildren(el, state) || "undefined" : genElement(el, state)}}`;
      const reverseProxy = slotScope ? `` : `,proxy:true`;
      return `{key:${el.slotTarget || `"default"`},fn:${fn}${reverseProxy}}`;
    }
    function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
      const children = el.children;
      if (children.length) {
        const el2 = children[0];
        if (children.length === 1 && el2.for && el2.tag !== "template" && el2.tag !== "slot") {
          const normalizationType2 = checkSkip ? state.maybeComponent(el2) ? `,1` : `,0` : ``;
          return `${(altGenElement || genElement)(el2, state)}${normalizationType2}`;
        }
        const normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
        const gen = altGenNode || genNode2;
        return `[${children.map((c) => gen(c, state)).join(",")}]${normalizationType ? `,${normalizationType}` : ""}`;
      }
    }
    function getNormalizationType(children, maybeComponent2) {
      let res = 0;
      for (let i = 0; i < children.length; i++) {
        const el = children[i];
        if (el.type !== 1) {
          continue;
        }
        if (needsNormalization(el) || el.ifConditions && el.ifConditions.some((c) => needsNormalization(c.block))) {
          res = 2;
          break;
        }
        if (maybeComponent2(el) || el.ifConditions && el.ifConditions.some((c) => maybeComponent2(c.block))) {
          res = 1;
        }
      }
      return res;
    }
    function needsNormalization(el) {
      return el.for !== void 0 || el.tag === "template" || el.tag === "slot";
    }
    function genNode2(node2, state) {
      if (node2.type === 1) {
        return genElement(node2, state);
      } else if (node2.type === 3 && node2.isComment) {
        return genComment2(node2);
      } else {
        return genText2(node2);
      }
    }
    function genText2(text7) {
      return `_v(${text7.type === 2 ? text7.expression : transformSpecialNewlines(JSON.stringify(text7.text))})`;
    }
    function genComment2(comment3) {
      return `_e(${JSON.stringify(comment3.text)})`;
    }
    function genSlot(el, state) {
      const slotName = el.slotName || '"default"';
      const children = genChildren(el, state);
      let res = `_t(${slotName}${children ? `,function(){return ${children}}` : ""}`;
      const attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map((attr) => ({
        // slot props are camelized
        name: camelize2(attr.name),
        value: attr.value,
        dynamic: attr.dynamic
      }))) : null;
      const bind2 = el.attrsMap["v-bind"];
      if ((attrs || bind2) && !children) {
        res += `,null`;
      }
      if (attrs) {
        res += `,${attrs}`;
      }
      if (bind2) {
        res += `${attrs ? "" : ",null"},${bind2}`;
      }
      return res + ")";
    }
    function genComponent(componentName, el, state) {
      const children = el.inlineTemplate ? null : genChildren(el, state, true);
      return `_c(${componentName},${genData(el, state)}${children ? `,${children}` : ""})`;
    }
    function genProps(props) {
      let staticProps = ``;
      let dynamicProps = ``;
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        const value = transformSpecialNewlines(prop.value);
        if (prop.dynamic) {
          dynamicProps += `${prop.name},${value},`;
        } else {
          staticProps += `"${prop.name}":${value},`;
        }
      }
      staticProps = `{${staticProps.slice(0, -1)}}`;
      if (dynamicProps) {
        return `_d(${staticProps},[${dynamicProps.slice(0, -1)}])`;
      } else {
        return staticProps;
      }
    }
    function transformSpecialNewlines(text7) {
      return text7.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    var prohibitedKeywordRE2 = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b") + "\\b");
    var unaryOperatorsRE = new RegExp("\\b" + "delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b") + "\\s*\\([^\\)]*\\)");
    var stripStringRE2 = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
    function detectErrors(ast, warn3) {
      if (ast) {
        checkNode(ast, warn3);
      }
    }
    function checkNode(node2, warn3) {
      if (node2.type === 1) {
        for (const name in node2.attrsMap) {
          if (dirRE.test(name)) {
            const value = node2.attrsMap[name];
            if (value) {
              const range4 = node2.rawAttrsMap[name];
              if (name === "v-for") {
                checkFor(node2, `v-for="${value}"`, warn3, range4);
              } else if (name === "v-slot" || name[0] === "#") {
                checkFunctionParameterExpression(value, `${name}="${value}"`, warn3, range4);
              } else if (onRE.test(name)) {
                checkEvent(value, `${name}="${value}"`, warn3, range4);
              } else {
                checkExpression(value, `${name}="${value}"`, warn3, range4);
              }
            }
          }
        }
        if (node2.children) {
          for (let i = 0; i < node2.children.length; i++) {
            checkNode(node2.children[i], warn3);
          }
        }
      } else if (node2.type === 2) {
        checkExpression(node2.expression, node2.text, warn3, node2);
      }
    }
    function checkEvent(exp, text7, warn3, range4) {
      const stripped = exp.replace(stripStringRE2, "");
      const keywordMatch = stripped.match(unaryOperatorsRE);
      if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== "$") {
        warn3(`avoid using JavaScript unary operator as property name: "${keywordMatch[0]}" in expression ${text7.trim()}`, range4);
      }
      checkExpression(exp, text7, warn3, range4);
    }
    function checkFor(node2, text7, warn3, range4) {
      checkExpression(node2.for || "", text7, warn3, range4);
      checkIdentifier(node2.alias, "v-for alias", text7, warn3, range4);
      checkIdentifier(node2.iterator1, "v-for iterator", text7, warn3, range4);
      checkIdentifier(node2.iterator2, "v-for iterator", text7, warn3, range4);
    }
    function checkIdentifier(ident, type, text7, warn3, range4) {
      if (typeof ident === "string") {
        try {
          new Function(`var ${ident}=_`);
        } catch (e) {
          warn3(`invalid ${type} "${ident}" in expression: ${text7.trim()}`, range4);
        }
      }
    }
    function checkExpression(exp, text7, warn3, range4) {
      try {
        new Function(`return ${exp}`);
      } catch (e) {
        const keywordMatch = exp.replace(stripStringRE2, "").match(prohibitedKeywordRE2);
        if (keywordMatch) {
          warn3(`avoid using JavaScript keyword as property name: "${keywordMatch[0]}"
  Raw expression: ${text7.trim()}`, range4);
        } else {
          warn3(`invalid expression: ${e.message} in

    ${exp}

  Raw expression: ${text7.trim()}
`, range4);
        }
      }
    }
    function checkFunctionParameterExpression(exp, text7, warn3, range4) {
      try {
        new Function(exp, "");
      } catch (e) {
        warn3(`invalid function parameter expression: ${e.message} in

    ${exp}

  Raw expression: ${text7.trim()}
`, range4);
      }
    }
    var range3 = 2;
    function generateCodeFrame2(source, start = 0, end = source.length) {
      const lines = source.split(/\r?\n/);
      let count = 0;
      const res = [];
      for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + 1;
        if (count >= start) {
          for (let j = i - range3; j <= i + range3 || end > count; j++) {
            if (j < 0 || j >= lines.length)
              continue;
            res.push(`${j + 1}${repeat(` `, 3 - String(j + 1).length)}|  ${lines[j]}`);
            const lineLength = lines[j].length;
            if (j === i) {
              const pad = start - (count - lineLength) + 1;
              const length = end > count ? lineLength - pad : end - start;
              res.push(`   |  ` + repeat(` `, pad) + repeat(`^`, length));
            } else if (j > i) {
              if (end > count) {
                const length = Math.min(end - count, lineLength);
                res.push(`   |  ` + repeat(`^`, length));
              }
              count += lineLength + 1;
            }
          }
          break;
        }
      }
      return res.join("\n");
    }
    function repeat(str2, n) {
      let result = "";
      if (n > 0) {
        while (true) {
          if (n & 1)
            result += str2;
          n >>>= 1;
          if (n <= 0)
            break;
          str2 += str2;
        }
      }
      return result;
    }
    function createFunction(code3, errors) {
      try {
        return new Function(code3);
      } catch (err) {
        errors.push({ err, code: code3 });
        return noop;
      }
    }
    function createCompileToFunctionFn(compile4) {
      const cache = /* @__PURE__ */ Object.create(null);
      return function compileToFunctions2(template, options, vm) {
        options = extend3({}, options);
        const warn3 = options.warn || warn$2;
        delete options.warn;
        if (true) {
          try {
            new Function("return 1");
          } catch (e) {
            if (e.toString().match(/unsafe-eval|CSP/)) {
              warn3("It seems you are using the standalone build of Vue.js in an environment with Content Security Policy that prohibits unsafe-eval. The template compiler cannot work in this environment. Consider relaxing the policy to allow unsafe-eval or pre-compiling your templates into render functions.");
            }
          }
        }
        const key2 = options.delimiters ? String(options.delimiters) + template : template;
        if (cache[key2]) {
          return cache[key2];
        }
        const compiled = compile4(template, options);
        if (true) {
          if (compiled.errors && compiled.errors.length) {
            if (options.outputSourceRange) {
              compiled.errors.forEach((e) => {
                warn3(`Error compiling template:

${e.msg}

` + generateCodeFrame2(template, e.start, e.end), vm);
              });
            } else {
              warn3(`Error compiling template:

${template}

` + compiled.errors.map((e) => `- ${e}`).join("\n") + "\n", vm);
            }
          }
          if (compiled.tips && compiled.tips.length) {
            if (options.outputSourceRange) {
              compiled.tips.forEach((e) => tip(e.msg, vm));
            } else {
              compiled.tips.forEach((msg) => tip(msg, vm));
            }
          }
        }
        const res = {};
        const fnGenErrors = [];
        res.render = createFunction(compiled.render, fnGenErrors);
        res.staticRenderFns = compiled.staticRenderFns.map((code3) => {
          return createFunction(code3, fnGenErrors);
        });
        if (true) {
          if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
            warn3(`Failed to generate render function:

` + fnGenErrors.map(({ err, code: code3 }) => `${err.toString()} in

${code3}
`).join("\n"), vm);
          }
        }
        return cache[key2] = res;
      };
    }
    function createCompilerCreator(baseCompile2) {
      return function createCompiler2(baseOptions2) {
        function compile4(template, options) {
          const finalOptions = Object.create(baseOptions2);
          const errors = [];
          const tips = [];
          let warn3 = (msg, range4, tip2) => {
            (tip2 ? tips : errors).push(msg);
          };
          if (options) {
            if (options.outputSourceRange) {
              const leadingSpaceLength = template.match(/^\s*/)[0].length;
              warn3 = (msg, range4, tip2) => {
                const data = typeof msg === "string" ? { msg } : msg;
                if (range4) {
                  if (range4.start != null) {
                    data.start = range4.start + leadingSpaceLength;
                  }
                  if (range4.end != null) {
                    data.end = range4.end + leadingSpaceLength;
                  }
                }
                (tip2 ? tips : errors).push(data);
              };
            }
            if (options.modules) {
              finalOptions.modules = (baseOptions2.modules || []).concat(options.modules);
            }
            if (options.directives) {
              finalOptions.directives = extend3(Object.create(baseOptions2.directives || null), options.directives);
            }
            for (const key2 in options) {
              if (key2 !== "modules" && key2 !== "directives") {
                finalOptions[key2] = options[key2];
              }
            }
          }
          finalOptions.warn = warn3;
          const compiled = baseCompile2(template.trim(), finalOptions);
          if (true) {
            detectErrors(compiled.ast, warn3);
          }
          compiled.errors = errors;
          compiled.tips = tips;
          return compiled;
        }
        return {
          compile: compile4,
          compileToFunctions: createCompileToFunctionFn(compile4)
        };
      };
    }
    var createCompiler$1 = createCompilerCreator(function baseCompile2(template, options) {
      const ast = parse3(template.trim(), options);
      if (options.optimize !== false) {
        optimize$1(ast, options);
      }
      const code3 = generate$1(ast, options);
      return {
        ast,
        render: code3.render,
        staticRenderFns: code3.staticRenderFns
      };
    });
    var { compile: compile$1, compileToFunctions: compileToFunctions$1 } = createCompiler$1(baseOptions);
    var isAttr = makeMap2("accept,accept-charset,accesskey,action,align,alt,async,autocomplete,autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,data,datetime,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,for,form,formaction,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,usemap,value,width,wrap");
    var isRenderableAttr = (name) => {
      return isAttr(name) || name.indexOf("data-") === 0 || name.indexOf("aria-") === 0;
    };
    var propsToAttrMap2 = {
      acceptCharset: "accept-charset",
      className: "class",
      htmlFor: "for",
      httpEquiv: "http-equiv"
    };
    var ESC = {
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "&": "&amp;"
    };
    function escape(s) {
      return s.replace(/[<>"&]/g, escapeChar);
    }
    function escapeChar(a) {
      return ESC[a] || a;
    }
    var plainStringRE = /^"(?:[^"\\]|\\.)*"$|^'(?:[^'\\]|\\.)*'$/;
    function applyModelTransform(el, state) {
      if (el.directives) {
        for (let i = 0; i < el.directives.length; i++) {
          const dir = el.directives[i];
          if (dir.name === "model") {
            state.directives.model(el, dir, state.warn);
            if (el.tag === "textarea" && el.props) {
              el.props = el.props.filter((p2) => p2.name !== "value");
            }
            break;
          }
        }
      }
    }
    function genAttrSegments(attrs) {
      return attrs.map(({ name, value }) => genAttrSegment(name, value));
    }
    function genDOMPropSegments(props, attrs) {
      const segments = [];
      props.forEach(({ name, value }) => {
        name = propsToAttrMap2[name] || name.toLowerCase();
        if (isRenderableAttr(name) && !(attrs && attrs.some((a) => a.name === name))) {
          segments.push(genAttrSegment(name, value));
        }
      });
      return segments;
    }
    function genAttrSegment(name, value) {
      if (plainStringRE.test(value)) {
        value = value.replace(/^'|'$/g, '"');
        if (isEnumeratedAttr(name) && value !== `"false"`) {
          value = `"true"`;
        }
        return {
          type: RAW,
          value: isBooleanAttr2(name) ? ` ${name}="${name}"` : value === '""' ? ` ${name}` : ` ${name}="${JSON.parse(value)}"`
        };
      } else {
        return {
          type: EXPRESSION,
          value: `_ssrAttr(${JSON.stringify(name)},${value})`
        };
      }
    }
    function genClassSegments(staticClass, classBinding) {
      if (staticClass && !classBinding) {
        return [{ type: RAW, value: ` class="${JSON.parse(staticClass)}"` }];
      } else {
        return [
          {
            type: EXPRESSION,
            value: `_ssrClass(${staticClass || "null"},${classBinding || "null"})`
          }
        ];
      }
    }
    function genStyleSegments(staticStyle, parsedStaticStyle, styleBinding, vShowExpression) {
      if (staticStyle && !styleBinding && !vShowExpression) {
        return [{ type: RAW, value: ` style=${JSON.stringify(staticStyle)}` }];
      } else {
        return [
          {
            type: EXPRESSION,
            value: `_ssrStyle(${parsedStaticStyle || "null"},${styleBinding || "null"}, ${vShowExpression ? `{ display: (${vShowExpression}) ? '' : 'none' }` : "null"})`
          }
        ];
      }
    }
    var optimizability = {
      FALSE: 0,
      FULL: 1,
      SELF: 2,
      CHILDREN: 3,
      PARTIAL: 4
      // self un-optimizable with some un-optimizable children
    };
    var isPlatformReservedTag;
    function optimize(root4, options) {
      if (!root4)
        return;
      isPlatformReservedTag = options.isReservedTag || no;
      walk2(root4, true);
    }
    function walk2(node2, isRoot) {
      if (isUnOptimizableTree(node2)) {
        node2.ssrOptimizability = optimizability.FALSE;
        return;
      }
      const selfUnoptimizable = isRoot || hasCustomDirective(node2);
      const check = (child) => {
        if (child.ssrOptimizability !== optimizability.FULL) {
          node2.ssrOptimizability = selfUnoptimizable ? optimizability.PARTIAL : optimizability.SELF;
        }
      };
      if (selfUnoptimizable) {
        node2.ssrOptimizability = optimizability.CHILDREN;
      }
      if (node2.type === 1) {
        for (let i = 0, l = node2.children.length; i < l; i++) {
          const child = node2.children[i];
          walk2(child);
          check(child);
        }
        if (node2.ifConditions) {
          for (let i = 1, l = node2.ifConditions.length; i < l; i++) {
            const block = node2.ifConditions[i].block;
            walk2(block, isRoot);
            check(block);
          }
        }
        if (node2.ssrOptimizability == null || !isRoot && (node2.attrsMap["v-html"] || node2.attrsMap["v-text"])) {
          node2.ssrOptimizability = optimizability.FULL;
        } else {
          node2.children = optimizeSiblings(node2);
        }
      } else {
        node2.ssrOptimizability = optimizability.FULL;
      }
    }
    function optimizeSiblings(el) {
      const children = el.children;
      const optimizedChildren = [];
      let currentOptimizableGroup = [];
      const pushGroup = () => {
        if (currentOptimizableGroup.length) {
          optimizedChildren.push({
            type: 1,
            parent: el,
            tag: "template",
            attrsList: [],
            attrsMap: {},
            rawAttrsMap: {},
            children: currentOptimizableGroup,
            ssrOptimizability: optimizability.FULL
          });
        }
        currentOptimizableGroup = [];
      };
      for (let i = 0; i < children.length; i++) {
        const c = children[i];
        if (c.ssrOptimizability === optimizability.FULL) {
          currentOptimizableGroup.push(c);
        } else {
          pushGroup();
          optimizedChildren.push(c);
        }
      }
      pushGroup();
      return optimizedChildren;
    }
    function isUnOptimizableTree(node2) {
      if (node2.type === 2 || node2.type === 3) {
        return false;
      }
      return isBuiltInTag(node2.tag) || // built-in (slot, component)
      !isPlatformReservedTag(node2.tag) || // custom component
      !!node2.component || // "is" component
      isSelectWithModel(node2);
    }
    var isBuiltInDir = makeMap2("text,html,show,on,bind,model,pre,cloak,once");
    function hasCustomDirective(node2) {
      return node2.type === 1 && node2.directives && node2.directives.some((d) => !isBuiltInDir(d.name));
    }
    function isSelectWithModel(node2) {
      return node2.type === 1 && node2.tag === "select" && node2.directives != null && node2.directives.some((d) => d.name === "model");
    }
    var RAW = 0;
    var INTERPOLATION = 1;
    var EXPRESSION = 2;
    function generate2(ast, options) {
      const state = new CodegenState(options);
      const code3 = ast ? genSSRElement(ast, state) : '_c("div")';
      return {
        render: `with(this){return ${code3}}`,
        staticRenderFns: state.staticRenderFns
      };
    }
    function genSSRElement(el, state) {
      if (el.for && !el.forProcessed) {
        return genFor(el, state, genSSRElement);
      } else if (el.if && !el.ifProcessed) {
        return genIf(el, state, genSSRElement);
      } else if (el.tag === "template" && !el.slotTarget) {
        return el.ssrOptimizability === optimizability.FULL ? genChildrenAsStringNode(el, state) : genSSRChildren(el, state) || "void 0";
      }
      switch (el.ssrOptimizability) {
        case optimizability.FULL:
          return genStringElement(el, state);
        case optimizability.SELF:
          return genStringElementWithChildren(el, state);
        case optimizability.CHILDREN:
          return genNormalElement(el, state, true);
        case optimizability.PARTIAL:
          return genNormalElement(el, state, false);
        default:
          return genElement(el, state);
      }
    }
    function genNormalElement(el, state, stringifyChildren) {
      const data = el.plain ? void 0 : genData(el, state);
      const children = stringifyChildren ? `[${genChildrenAsStringNode(el, state)}]` : genSSRChildren(el, state, true);
      return `_c('${el.tag}'${data ? `,${data}` : ""}${children ? `,${children}` : ""})`;
    }
    function genSSRChildren(el, state, checkSkip) {
      return genChildren(el, state, checkSkip, genSSRElement, genSSRNode);
    }
    function genSSRNode(el, state) {
      return el.type === 1 ? genSSRElement(el, state) : genText2(el);
    }
    function genChildrenAsStringNode(el, state) {
      return el.children.length ? `_ssrNode(${flattenSegments(childrenToSegments(el, state))})` : "";
    }
    function genStringElement(el, state) {
      return `_ssrNode(${elementToString(el, state)})`;
    }
    function genStringElementWithChildren(el, state) {
      const children = genSSRChildren(el, state, true);
      return `_ssrNode(${flattenSegments(elementToOpenTagSegments(el, state))},"</${el.tag}>"${children ? `,${children}` : ""})`;
    }
    function elementToString(el, state) {
      return `(${flattenSegments(elementToSegments(el, state))})`;
    }
    function elementToSegments(el, state) {
      if (el.for && !el.forProcessed) {
        el.forProcessed = true;
        return [
          {
            type: EXPRESSION,
            value: genFor(el, state, elementToString, "_ssrList")
          }
        ];
      } else if (el.if && !el.ifProcessed) {
        el.ifProcessed = true;
        return [
          {
            type: EXPRESSION,
            value: genIf(el, state, elementToString, '"<!---->"')
          }
        ];
      } else if (el.tag === "template") {
        return childrenToSegments(el, state);
      }
      const openSegments = elementToOpenTagSegments(el, state);
      const childrenSegments = childrenToSegments(el, state);
      const { isUnaryTag: isUnaryTag2 } = state.options;
      const close = isUnaryTag2 && isUnaryTag2(el.tag) ? [] : [{ type: RAW, value: `</${el.tag}>` }];
      return openSegments.concat(childrenSegments, close);
    }
    function elementToOpenTagSegments(el, state) {
      applyModelTransform(el, state);
      let binding;
      const segments = [{ type: RAW, value: `<${el.tag}` }];
      if (el.attrs) {
        segments.push.apply(segments, genAttrSegments(el.attrs));
      }
      if (el.props) {
        segments.push.apply(segments, genDOMPropSegments(el.props, el.attrs));
      }
      if (binding = el.attrsMap["v-bind"]) {
        segments.push({ type: EXPRESSION, value: `_ssrAttrs(${binding})` });
      }
      if (binding = el.attrsMap["v-bind.prop"]) {
        segments.push({ type: EXPRESSION, value: `_ssrDOMProps(${binding})` });
      }
      if (el.staticClass || el.classBinding) {
        segments.push.apply(segments, genClassSegments(el.staticClass, el.classBinding));
      }
      if (el.staticStyle || el.styleBinding || el.attrsMap["v-show"]) {
        segments.push.apply(segments, genStyleSegments(el.attrsMap.style, el.staticStyle, el.styleBinding, el.attrsMap["v-show"]));
      }
      if (state.options.scopeId) {
        segments.push({ type: RAW, value: ` ${state.options.scopeId}` });
      }
      segments.push({ type: RAW, value: `>` });
      return segments;
    }
    function childrenToSegments(el, state) {
      let binding;
      if (binding = el.attrsMap["v-html"]) {
        return [{ type: EXPRESSION, value: `_s(${binding})` }];
      }
      if (binding = el.attrsMap["v-text"]) {
        return [{ type: INTERPOLATION, value: `_s(${binding})` }];
      }
      if (el.tag === "textarea" && (binding = el.attrsMap["v-model"])) {
        return [{ type: INTERPOLATION, value: `_s(${binding})` }];
      }
      return el.children ? nodesToSegments(el.children, state) : [];
    }
    function nodesToSegments(children, state) {
      const segments = [];
      for (let i = 0; i < children.length; i++) {
        const c = children[i];
        if (c.type === 1) {
          segments.push.apply(segments, elementToSegments(c, state));
        } else if (c.type === 2) {
          segments.push({ type: INTERPOLATION, value: c.expression });
        } else if (c.type === 3) {
          let text7 = escape(c.text);
          if (c.isComment) {
            text7 = "<!--" + text7 + "-->";
          }
          segments.push({ type: RAW, value: text7 });
        }
      }
      return segments;
    }
    function flattenSegments(segments) {
      const mergedSegments = [];
      let textBuffer = "";
      const pushBuffer = () => {
        if (textBuffer) {
          mergedSegments.push(JSON.stringify(textBuffer));
          textBuffer = "";
        }
      };
      for (let i = 0; i < segments.length; i++) {
        const s = segments[i];
        if (s.type === RAW) {
          textBuffer += s.value;
        } else if (s.type === INTERPOLATION) {
          pushBuffer();
          mergedSegments.push(`_ssrEscape(${s.value})`);
        } else if (s.type === EXPRESSION) {
          pushBuffer();
          mergedSegments.push(`(${s.value})`);
        }
      }
      pushBuffer();
      return mergedSegments.join("+");
    }
    var createCompiler = createCompilerCreator(function baseCompile2(template, options) {
      const ast = parse3(template.trim(), options);
      optimize(ast, options);
      const code3 = generate2(ast, options);
      return {
        ast,
        render: code3.render,
        staticRenderFns: code3.staticRenderFns
      };
    });
    var { compile: compile3, compileToFunctions } = createCompiler(baseOptions);
    exports.compile = compile$1;
    exports.compileToFunctions = compileToFunctions$1;
    exports.generateCodeFrame = generateCodeFrame2;
    exports.parseComponent = parseComponent;
    exports.ssrCompile = compile3;
    exports.ssrCompileToFunctions = compileToFunctions;
  }
});

// node_modules/@vue/language-core/lib/utils/vue2TemplateCompiler.js
var require_vue2TemplateCompiler = __commonJS({
  "node_modules/@vue/language-core/lib/utils/vue2TemplateCompiler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compile = void 0;
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var Vue2TemplateCompiler = require_build();
    var compile3 = (template, options = {}) => {
      if (typeof template !== "string") {
        throw new Error(`[@vue/language-core] compile() first argument must be string.`);
      }
      const onError = options.onError;
      const onWarn = options.onWarn;
      options.onError = (error2) => {
        if (error2.code === 33 || error2.code === 29) {
          return;
        }
        if (onError) {
          onError(error2);
        } else {
          throw error2;
        }
      };
      const vue2Result = Vue2TemplateCompiler.compile(template, { outputSourceRange: true });
      for (const error2 of vue2Result.errors) {
        onError == null ? void 0 : onError({
          code: "vue-template-compiler",
          name: "",
          message: error2.msg,
          loc: {
            source: "",
            start: { column: -1, line: -1, offset: error2.start },
            end: { column: -1, line: -1, offset: error2.end ?? error2.start }
          }
        });
      }
      for (const error2 of vue2Result.tips) {
        onWarn == null ? void 0 : onWarn({
          code: "vue-template-compiler",
          name: "",
          message: error2.msg,
          loc: {
            source: "",
            start: { column: -1, line: -1, offset: error2.start },
            end: { column: -1, line: -1, offset: error2.end ?? error2.start }
          }
        });
      }
      return baseCompile2(template, Object.assign({}, CompilerDOM.parserOptions, options, {
        nodeTransforms: [
          ...CompilerDOM.DOMNodeTransforms,
          ...options.nodeTransforms || []
        ],
        directiveTransforms: Object.assign({}, CompilerDOM.DOMDirectiveTransforms, options.directiveTransforms || {})
      }));
    };
    exports.compile = compile3;
    function baseCompile2(template, options = {}) {
      const onError = options.onError || ((error2) => {
        throw error2;
      });
      const isModuleMode = options.mode === "module";
      const prefixIdentifiers = options.prefixIdentifiers === true || isModuleMode;
      if (!prefixIdentifiers && options.cacheHandlers) {
        onError(CompilerDOM.createCompilerError(49));
      }
      if (options.scopeId && !isModuleMode) {
        onError(CompilerDOM.createCompilerError(50));
      }
      const ast = CompilerDOM.baseParse(template, options);
      const [nodeTransforms, directiveTransforms] = CompilerDOM.getBaseTransformPreset(prefixIdentifiers);
      const transformIf2 = nodeTransforms[1];
      const transformFor2 = nodeTransforms[3];
      nodeTransforms[1] = transformFor2;
      nodeTransforms[3] = transformIf2;
      CompilerDOM.transform(ast, Object.assign({}, options, {
        prefixIdentifiers,
        nodeTransforms: [
          ...nodeTransforms,
          ...options.nodeTransforms || []
          // user transforms
        ],
        directiveTransforms: Object.assign(
          {},
          directiveTransforms,
          options.directiveTransforms || {}
          // user transforms
        )
      }));
      return CompilerDOM.generate(ast, Object.assign({}, options, {
        prefixIdentifiers
      }));
    }
  }
});

// node_modules/@vue/language-core/lib/virtualFile/embeddedFile.js
var require_embeddedFile = __commonJS({
  "node_modules/@vue/language-core/lib/virtualFile/embeddedFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VueEmbeddedCode = void 0;
    var VueEmbeddedCode = class {
      constructor(id, lang, content3) {
        this.id = id;
        this.lang = lang;
        this.content = content3;
        this.linkedCodeMappings = [];
        this.embeddedCodes = [];
      }
    };
    exports.VueEmbeddedCode = VueEmbeddedCode;
  }
});

// node_modules/@vue/language-core/lib/virtualFile/computedEmbeddedCodes.js
var require_computedEmbeddedCodes = __commonJS({
  "node_modules/@vue/language-core/lib/virtualFile/computedEmbeddedCodes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computedEmbeddedCodes = computedEmbeddedCodes;
    exports.resolveCommonLanguageId = resolveCommonLanguageId;
    var alien_signals_1 = require_cjs();
    var muggle_string_1 = require_out();
    var buildMappings_1 = require_buildMappings();
    var embeddedFile_1 = require_embeddedFile();
    function computedEmbeddedCodes(plugins, fileName, sfc) {
      const nameToBlock = (0, alien_signals_1.computed)(() => {
        const blocks = {};
        if (sfc.template) {
          blocks[sfc.template.name] = sfc.template;
        }
        if (sfc.script) {
          blocks[sfc.script.name] = sfc.script;
        }
        if (sfc.scriptSetup) {
          blocks[sfc.scriptSetup.name] = sfc.scriptSetup;
        }
        for (const block of sfc.styles) {
          blocks[block.name] = block;
        }
        for (const block of sfc.customBlocks) {
          blocks[block.name] = block;
        }
        return blocks;
      });
      const pluginsResult = plugins.map((plugin) => computedPluginEmbeddedCodes(plugins, plugin, fileName, sfc, nameToBlock));
      const flatResult = (0, alien_signals_1.computed)(() => pluginsResult.map((r4) => r4.get()).flat());
      const structuredResult = (0, alien_signals_1.computed)(() => {
        const embeddedCodes = [];
        let remain = [...flatResult.get()];
        while (remain.length) {
          const beforeLength = remain.length;
          consumeRemain();
          if (beforeLength === remain.length) {
            break;
          }
        }
        for (const { code: code3 } of remain) {
          console.error("Unable to resolve embedded: " + code3.parentCodeId + " -> " + code3.id);
        }
        return embeddedCodes;
        function consumeRemain() {
          for (let i = remain.length - 1; i >= 0; i--) {
            const { code: code3, snapshot, mappings } = remain[i];
            if (!code3.parentCodeId) {
              embeddedCodes.push({
                id: code3.id,
                languageId: resolveCommonLanguageId(code3.lang),
                linkedCodeMappings: code3.linkedCodeMappings,
                snapshot,
                mappings,
                embeddedCodes: []
              });
              remain.splice(i, 1);
            } else {
              const parent = findParentStructure(code3.parentCodeId, embeddedCodes);
              if (parent) {
                parent.embeddedCodes ?? (parent.embeddedCodes = []);
                parent.embeddedCodes.push({
                  id: code3.id,
                  languageId: resolveCommonLanguageId(code3.lang),
                  linkedCodeMappings: code3.linkedCodeMappings,
                  snapshot,
                  mappings,
                  embeddedCodes: []
                });
                remain.splice(i, 1);
              }
            }
          }
        }
        function findParentStructure(id, current) {
          for (const child of current) {
            if (child.id === id) {
              return child;
            }
            let parent = findParentStructure(id, child.embeddedCodes ?? []);
            if (parent) {
              return parent;
            }
          }
        }
      });
      return structuredResult;
    }
    function computedPluginEmbeddedCodes(plugins, plugin, fileName, sfc, nameToBlock) {
      const computeds = /* @__PURE__ */ new Map();
      const getComputedKey = (code3) => code3.id + "__" + code3.lang;
      const codes2 = (0, alien_signals_1.computed)(() => {
        try {
          if (!plugin.getEmbeddedCodes) {
            return [...computeds.values()];
          }
          const embeddedCodeInfos = plugin.getEmbeddedCodes(fileName, sfc);
          for (const oldId of computeds.keys()) {
            if (!embeddedCodeInfos.some((code3) => getComputedKey(code3) === oldId)) {
              computeds.delete(oldId);
            }
          }
          for (const codeInfo of embeddedCodeInfos) {
            if (!computeds.has(getComputedKey(codeInfo))) {
              computeds.set(getComputedKey(codeInfo), (0, alien_signals_1.computed)(() => {
                const content3 = [];
                const code3 = new embeddedFile_1.VueEmbeddedCode(codeInfo.id, codeInfo.lang, content3);
                for (const plugin2 of plugins) {
                  if (!plugin2.resolveEmbeddedCode) {
                    continue;
                  }
                  try {
                    plugin2.resolveEmbeddedCode(fileName, sfc, code3);
                  } catch (e) {
                    console.error(e);
                  }
                }
                const newText = (0, muggle_string_1.toString)(code3.content);
                const changeRanges = /* @__PURE__ */ new Map();
                const snapshot = {
                  getText: (start, end) => newText.slice(start, end),
                  getLength: () => newText.length,
                  getChangeRange(oldSnapshot) {
                    if (!changeRanges.has(oldSnapshot)) {
                      changeRanges.set(oldSnapshot, void 0);
                      const oldText = oldSnapshot.getText(0, oldSnapshot.getLength());
                      const changeRange = fullDiffTextChangeRange(oldText, newText);
                      if (changeRange) {
                        changeRanges.set(oldSnapshot, changeRange);
                      }
                    }
                    return changeRanges.get(oldSnapshot);
                  }
                };
                return {
                  code: code3,
                  snapshot
                };
              }));
            }
          }
        } catch (e) {
          console.error(e);
        }
        return [...computeds.values()];
      });
      return (0, alien_signals_1.computed)(() => {
        return codes2.get().map((_file) => {
          const { code: code3, snapshot } = _file.get();
          const mappings = (0, buildMappings_1.buildMappings)(code3.content.map((segment) => {
            if (typeof segment === "string") {
              return segment;
            }
            const source = segment[1];
            if (source === void 0) {
              return segment;
            }
            const block = nameToBlock.get()[source];
            if (!block) {
              return segment;
            }
            return [
              segment[0],
              void 0,
              segment[2] + block.startTagEnd,
              segment[3]
            ];
          }));
          const newMappings = [];
          let lastValidMapping;
          for (let i = 0; i < mappings.length; i++) {
            const mapping = mappings[i];
            if (mapping.data.__combineOffsetMapping !== void 0) {
              const offsetMapping = mappings[i - mapping.data.__combineOffsetMapping];
              if (typeof offsetMapping === "string" || !offsetMapping) {
                throw new Error("Invalid offset mapping, mappings: " + mappings.length + ", i: " + i + ", offset: " + mapping.data.__combineOffsetMapping);
              }
              offsetMapping.sourceOffsets.push(...mapping.sourceOffsets);
              offsetMapping.generatedOffsets.push(...mapping.generatedOffsets);
              offsetMapping.lengths.push(...mapping.lengths);
              continue;
            } else if (mapping.data.__combineLastMapping) {
              lastValidMapping.sourceOffsets.push(...mapping.sourceOffsets);
              lastValidMapping.generatedOffsets.push(...mapping.generatedOffsets);
              lastValidMapping.lengths.push(...mapping.lengths);
              continue;
            } else {
              lastValidMapping = mapping;
            }
            newMappings.push(mapping);
          }
          return {
            code: code3,
            snapshot,
            mappings: newMappings
          };
        });
      });
    }
    function fullDiffTextChangeRange(oldText, newText) {
      for (let start = 0; start < oldText.length && start < newText.length; start++) {
        if (oldText[start] !== newText[start]) {
          let end = oldText.length;
          for (let i = 0; i < oldText.length - start && i < newText.length - start; i++) {
            if (oldText[oldText.length - i - 1] !== newText[newText.length - i - 1]) {
              break;
            }
            end--;
          }
          let length = end - start;
          let newLength = length + (newText.length - oldText.length);
          if (newLength < 0) {
            length -= newLength;
            newLength = 0;
          }
          return {
            span: { start, length },
            newLength
          };
        }
      }
    }
    function resolveCommonLanguageId(lang) {
      switch (lang) {
        case "js":
          return "javascript";
        case "cjs":
          return "javascript";
        case "mjs":
          return "javascript";
        case "ts":
          return "typescript";
        case "cts":
          return "typescript";
        case "mts":
          return "typescript";
        case "jsx":
          return "javascriptreact";
        case "tsx":
          return "typescriptreact";
        case "pug":
          return "jade";
        case "md":
          return "markdown";
      }
      return lang;
    }
  }
});

// node_modules/@vue/language-core/lib/utils/parseCssVars.js
var require_parseCssVars = __commonJS({
  "node_modules/@vue/language-core/lib/utils/parseCssVars.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.commentReg = void 0;
    exports.parseCssVars = parseCssVars;
    exports.fillBlank = fillBlank;
    var vBindCssVarReg = /\bv-bind\(\s*(?:'([^']+)'|"([^"]+)"|([a-z_]\w*))\s*\)/gi;
    exports.commentReg = new RegExp("(?<=\\/\\*)[\\s\\S]*?(?=\\*\\/)|(?<=\\/\\/)[\\s\\S]*?(?=\\n)", "g");
    function* parseCssVars(css) {
      css = fillBlank(css, exports.commentReg);
      const matchs = css.matchAll(vBindCssVarReg);
      for (const match of matchs) {
        const matchText = match.slice(1).find((t) => t);
        if (matchText) {
          const offset = match.index + css.slice(match.index).indexOf(matchText);
          yield { offset, text: matchText };
        }
      }
    }
    function fillBlank(css, ...regs) {
      for (const reg of regs) {
        css = css.replace(reg, (match) => " ".repeat(match.length));
      }
      return css;
    }
  }
});

// node_modules/@vue/language-core/lib/utils/parseCssClassNames.js
var require_parseCssClassNames = __commonJS({
  "node_modules/@vue/language-core/lib/utils/parseCssClassNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseCssClassNames = parseCssClassNames;
    var parseCssVars_1 = require_parseCssVars();
    var cssClassNameReg = /(?=(\.[a-z_][-\w]*)[\s.,+~>:#)[{])/gi;
    var fragmentReg = new RegExp("(?<={)[^{]*(?=(?<!\\\\);)", "g");
    function* parseCssClassNames(css) {
      css = (0, parseCssVars_1.fillBlank)(css, parseCssVars_1.commentReg, fragmentReg);
      const matches2 = css.matchAll(cssClassNameReg);
      for (const match of matches2) {
        const matchText = match[1];
        if (matchText) {
          yield { offset: match.index, text: matchText };
        }
      }
    }
  }
});

// node_modules/@vue/language-core/lib/virtualFile/computedSfc.js
var require_computedSfc = __commonJS({
  "node_modules/@vue/language-core/lib/virtualFile/computedSfc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computedSfc = computedSfc;
    var alien_signals_1 = require_cjs();
    var parseCssClassNames_1 = require_parseCssClassNames();
    var parseCssVars_1 = require_parseCssVars();
    function computedSfc(ts3, plugins, fileName, snapshot, parsed) {
      const untrackedSnapshot = () => {
        const prevTrackId = alien_signals_1.System.activeTrackId;
        alien_signals_1.System.activeTrackId = 0;
        const res = snapshot.get();
        alien_signals_1.System.activeTrackId = prevTrackId;
        return res;
      };
      const content3 = (0, alien_signals_1.computed)(() => {
        return snapshot.get().getText(0, snapshot.get().getLength());
      });
      const template = computedNullableSfcBlock("template", "html", (0, alien_signals_1.computed)(() => {
        var _a;
        return ((_a = parsed.get()) == null ? void 0 : _a.descriptor.template) ?? void 0;
      }), (_block, base) => {
        const compiledAst = computedTemplateAst(base);
        return mergeObject(base, {
          get ast() {
            var _a;
            return (_a = compiledAst.get()) == null ? void 0 : _a.ast;
          },
          get errors() {
            var _a;
            return (_a = compiledAst.get()) == null ? void 0 : _a.errors;
          },
          get warnings() {
            var _a;
            return (_a = compiledAst.get()) == null ? void 0 : _a.warnings;
          }
        });
      });
      const script = computedNullableSfcBlock("script", "js", (0, alien_signals_1.computed)(() => {
        var _a;
        return ((_a = parsed.get()) == null ? void 0 : _a.descriptor.script) ?? void 0;
      }), (block, base) => {
        const src = (0, alien_signals_1.computed)(() => block.get().src);
        const srcOffset = (0, alien_signals_1.computed)(() => {
          const _src = src.get();
          return _src ? untrackedSnapshot().getText(0, base.startTagEnd).lastIndexOf(_src) - base.startTagEnd : -1;
        });
        const ast = (0, alien_signals_1.computed)(() => {
          var _a;
          for (const plugin of plugins) {
            const ast2 = (_a = plugin.compileSFCScript) == null ? void 0 : _a.call(plugin, base.lang, base.content);
            if (ast2) {
              return ast2;
            }
          }
          return ts3.createSourceFile(fileName + "." + base.lang, "", 99);
        });
        return mergeObject(base, {
          get src() {
            return src.get();
          },
          get srcOffset() {
            return srcOffset.get();
          },
          get ast() {
            return ast.get();
          }
        });
      });
      const scriptSetupOriginal = computedNullableSfcBlock("scriptSetup", "js", (0, alien_signals_1.computed)(() => {
        var _a;
        return ((_a = parsed.get()) == null ? void 0 : _a.descriptor.scriptSetup) ?? void 0;
      }), (block, base) => {
        const generic = (0, alien_signals_1.computed)(() => {
          const _block = block.get();
          return typeof _block.attrs.generic === "string" ? _block.attrs.generic : void 0;
        });
        const genericOffset = (0, alien_signals_1.computed)(() => {
          const _generic = generic.get();
          return _generic !== void 0 ? untrackedSnapshot().getText(0, base.startTagEnd).lastIndexOf(_generic) - base.startTagEnd : -1;
        });
        const ast = (0, alien_signals_1.computed)(() => {
          var _a;
          for (const plugin of plugins) {
            const ast2 = (_a = plugin.compileSFCScript) == null ? void 0 : _a.call(plugin, base.lang, base.content);
            if (ast2) {
              return ast2;
            }
          }
          return ts3.createSourceFile(fileName + "." + base.lang, "", 99);
        });
        return mergeObject(base, {
          get generic() {
            return generic.get();
          },
          get genericOffset() {
            return genericOffset.get();
          },
          get ast() {
            return ast.get();
          }
        });
      });
      const hasScript = (0, alien_signals_1.computed)(() => {
        var _a;
        return !!((_a = parsed.get()) == null ? void 0 : _a.descriptor.script);
      });
      const hasScriptSetup = (0, alien_signals_1.computed)(() => {
        var _a;
        return !!((_a = parsed.get()) == null ? void 0 : _a.descriptor.scriptSetup);
      });
      const scriptSetup = (0, alien_signals_1.computed)(() => {
        if (!hasScript.get() && !hasScriptSetup.get()) {
          return {
            content: "",
            lang: "ts",
            name: "",
            start: 0,
            end: 0,
            startTagEnd: 0,
            endTagStart: 0,
            generic: void 0,
            genericOffset: 0,
            attrs: {},
            ast: ts3.createSourceFile("", "", 99, false, ts3.ScriptKind.TS)
          };
        }
        return scriptSetupOriginal.get();
      });
      const styles = alien_signals_1.Unstable.computedArray((0, alien_signals_1.computed)(() => {
        var _a;
        return ((_a = parsed.get()) == null ? void 0 : _a.descriptor.styles) ?? [];
      }), (block, i) => {
        const base = computedSfcBlock("style_" + i, "css", block);
        const module3 = (0, alien_signals_1.computed)(() => {
          const _module = block.get().module;
          return _module ? {
            name: _module.name,
            offset: _module.offset ? base.start + _module.offset : void 0
          } : void 0;
        });
        const scoped = (0, alien_signals_1.computed)(() => !!block.get().scoped);
        const cssVars = (0, alien_signals_1.computed)(() => [...(0, parseCssVars_1.parseCssVars)(base.content)]);
        const classNames = (0, alien_signals_1.computed)(() => [...(0, parseCssClassNames_1.parseCssClassNames)(base.content)]);
        return () => mergeObject(base, {
          get module() {
            return module3.get();
          },
          get scoped() {
            return scoped.get();
          },
          get cssVars() {
            return cssVars.get();
          },
          get classNames() {
            return classNames.get();
          }
        });
      });
      const customBlocks = alien_signals_1.Unstable.computedArray((0, alien_signals_1.computed)(() => {
        var _a;
        return ((_a = parsed.get()) == null ? void 0 : _a.descriptor.customBlocks) ?? [];
      }), (block, i) => {
        const base = computedSfcBlock("custom_block_" + i, "txt", block);
        const type = (0, alien_signals_1.computed)(() => block.get().type);
        return () => mergeObject(base, {
          get type() {
            return type.get();
          }
        });
      });
      return {
        get content() {
          return content3.get();
        },
        get template() {
          return template.get();
        },
        get script() {
          return script.get();
        },
        get scriptSetup() {
          return scriptSetup.get();
        },
        get styles() {
          return styles;
        },
        get customBlocks() {
          return customBlocks;
        }
      };
      function computedTemplateAst(base) {
        let cache;
        return (0, alien_signals_1.computed)(() => {
          var _a;
          if ((cache == null ? void 0 : cache.template) === base.content) {
            return {
              errors: [],
              warnings: [],
              ast: cache == null ? void 0 : cache.result.ast
            };
          }
          if (cache == null ? void 0 : cache.plugin.updateSFCTemplate) {
            const change = untrackedSnapshot().getChangeRange(cache.snapshot);
            if (change) {
              const prevTrackId = alien_signals_1.System.activeTrackId;
              alien_signals_1.System.activeTrackId = 0;
              const templateOffset = base.startTagEnd;
              alien_signals_1.System.activeTrackId = prevTrackId;
              const newText = untrackedSnapshot().getText(change.span.start, change.span.start + change.newLength);
              const newResult = cache.plugin.updateSFCTemplate(cache.result, {
                start: change.span.start - templateOffset,
                end: change.span.start + change.span.length - templateOffset,
                newText
              });
              if (newResult) {
                cache.template = base.content;
                cache.snapshot = untrackedSnapshot();
                cache.result = newResult;
                return {
                  errors: [],
                  warnings: [],
                  ast: newResult.ast
                };
              }
            }
          }
          const errors = [];
          const warnings = [];
          let options = {
            onError: (err) => errors.push(err),
            onWarn: (err) => warnings.push(err),
            expressionPlugins: ["typescript"]
          };
          for (const plugin of plugins) {
            if (plugin.resolveTemplateCompilerOptions) {
              options = plugin.resolveTemplateCompilerOptions(options);
            }
          }
          for (const plugin of plugins) {
            let result;
            try {
              result = (_a = plugin.compileSFCTemplate) == null ? void 0 : _a.call(plugin, base.lang, base.content, options);
            } catch (e) {
              const err = e;
              errors.push(err);
            }
            if (result || errors.length) {
              if (result && !errors.length && !warnings.length) {
                cache = {
                  template: base.content,
                  snapshot: untrackedSnapshot(),
                  result,
                  plugin
                };
              } else {
                cache = void 0;
              }
              return {
                errors,
                warnings,
                ast: result == null ? void 0 : result.ast
              };
            }
          }
          return {
            errors,
            warnings,
            ast: void 0
          };
        });
      }
      function computedNullableSfcBlock(name, defaultLang, block, resolve) {
        const hasBlock = (0, alien_signals_1.computed)(() => !!block.get());
        return (0, alien_signals_1.computed)(() => {
          if (!hasBlock.get()) {
            return;
          }
          const _block = (0, alien_signals_1.computed)(() => block.get());
          return resolve(_block, computedSfcBlock(name, defaultLang, _block));
        });
      }
      function computedSfcBlock(name, defaultLang, block) {
        const lang = (0, alien_signals_1.computed)(() => block.get().lang ?? defaultLang);
        const attrs = (0, alien_signals_1.computed)(() => block.get().attrs);
        const content4 = (0, alien_signals_1.computed)(() => block.get().content);
        const startTagEnd = (0, alien_signals_1.computed)(() => block.get().loc.start.offset);
        const endTagStart = (0, alien_signals_1.computed)(() => block.get().loc.end.offset);
        const start = (0, alien_signals_1.computed)(() => untrackedSnapshot().getText(0, startTagEnd.get()).lastIndexOf("<" + block.get().type));
        const end = (0, alien_signals_1.computed)(() => endTagStart.get() + untrackedSnapshot().getText(endTagStart.get(), untrackedSnapshot().getLength()).indexOf(">") + 1);
        return {
          name,
          get lang() {
            return lang.get();
          },
          get attrs() {
            return attrs.get();
          },
          get content() {
            return content4.get();
          },
          get startTagEnd() {
            return startTagEnd.get();
          },
          get endTagStart() {
            return endTagStart.get();
          },
          get start() {
            return start.get();
          },
          get end() {
            return end.get();
          }
        };
      }
    }
    function mergeObject(a, b) {
      return Object.defineProperties(a, Object.getOwnPropertyDescriptors(b));
    }
  }
});

// node_modules/@vue/language-core/lib/virtualFile/computedVueSfc.js
var require_computedVueSfc = __commonJS({
  "node_modules/@vue/language-core/lib/virtualFile/computedVueSfc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computedVueSfc = computedVueSfc;
    var alien_signals_1 = require_cjs();
    function computedVueSfc(plugins, fileName, languageId, snapshot) {
      let cache;
      return (0, alien_signals_1.computed)(() => {
        var _a, _b;
        if (cache == null ? void 0 : cache.plugin.updateSFC) {
          const change = snapshot.get().getChangeRange(cache.snapshot);
          if (change) {
            const newSfc = cache.plugin.updateSFC(cache.sfc, {
              start: change.span.start,
              end: change.span.start + change.span.length,
              newText: snapshot.get().getText(change.span.start, change.span.start + change.newLength)
            });
            if (newSfc) {
              cache.snapshot = snapshot.get();
              cache.sfc = JSON.parse(JSON.stringify(newSfc));
              return cache.sfc;
            }
          }
        }
        for (const plugin of plugins) {
          const sfc = ((_a = plugin.parseSFC) == null ? void 0 : _a.call(plugin, fileName, snapshot.get().getText(0, snapshot.get().getLength()))) ?? ((_b = plugin.parseSFC2) == null ? void 0 : _b.call(plugin, fileName, languageId, snapshot.get().getText(0, snapshot.get().getLength())));
          if (sfc) {
            if (!sfc.errors.length) {
              cache = {
                snapshot: snapshot.get(),
                sfc,
                plugin
              };
            }
            return sfc;
          }
        }
      });
    }
  }
});

// node_modules/@vue/language-core/lib/virtualFile/vueFile.js
var require_vueFile = __commonJS({
  "node_modules/@vue/language-core/lib/virtualFile/vueFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VueVirtualCode = void 0;
    var alien_signals_1 = require_cjs();
    var plugins_1 = require_plugins();
    var computedEmbeddedCodes_1 = require_computedEmbeddedCodes();
    var computedSfc_1 = require_computedSfc();
    var computedVueSfc_1 = require_computedVueSfc();
    var VueVirtualCode = class {
      // others
      get embeddedCodes() {
        return this._embeddedCodes.get();
      }
      get snapshot() {
        return this._snapshot.get();
      }
      get mappings() {
        return this._mappings.get();
      }
      constructor(fileName, languageId, initSnapshot, vueCompilerOptions, plugins, ts3) {
        this.fileName = fileName;
        this.languageId = languageId;
        this.initSnapshot = initSnapshot;
        this.vueCompilerOptions = vueCompilerOptions;
        this.plugins = plugins;
        this.ts = ts3;
        this.id = "main";
        this._snapshot = (0, alien_signals_1.signal)(void 0);
        this._vueSfc = (0, computedVueSfc_1.computedVueSfc)(this.plugins, this.fileName, this.languageId, this._snapshot);
        this._sfc = (0, computedSfc_1.computedSfc)(this.ts, this.plugins, this.fileName, this._snapshot, this._vueSfc);
        this._mappings = (0, alien_signals_1.computed)(() => {
          const snapshot = this._snapshot.get();
          return [{
            sourceOffsets: [0],
            generatedOffsets: [0],
            lengths: [snapshot.getLength()],
            data: plugins_1.allCodeFeatures
          }];
        });
        this._embeddedCodes = (0, computedEmbeddedCodes_1.computedEmbeddedCodes)(this.plugins, this.fileName, this._sfc);
        this._snapshot.set(initSnapshot);
      }
      update(newSnapshot) {
        this._snapshot.set(newSnapshot);
      }
    };
    exports.VueVirtualCode = VueVirtualCode;
  }
});

// node_modules/@vue/language-core/lib/languagePlugin.js
var require_languagePlugin = __commonJS({
  "node_modules/@vue/language-core/lib/languagePlugin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createVueLanguagePlugin = createVueLanguagePlugin2;
    exports.getAllExtensions = getAllExtensions;
    var language_core_1 = require_language_core();
    var CompilerDOM = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var plugins_1 = require_plugins();
    var CompilerVue2 = require_vue2TemplateCompiler();
    var vueFile_1 = require_vueFile();
    var fileRegistries = [];
    function getVueFileRegistry(key2, plugins) {
      var _a;
      let fileRegistry = (_a = fileRegistries.find((r4) => r4.key === key2 && r4.plugins.length === plugins.length && r4.plugins.every((plugin) => plugins.includes(plugin)))) == null ? void 0 : _a.files;
      if (!fileRegistry) {
        fileRegistry = /* @__PURE__ */ new Map();
        fileRegistries.push({
          key: key2,
          plugins,
          files: fileRegistry
        });
      }
      return fileRegistry;
    }
    function getFileRegistryKey(compilerOptions, vueCompilerOptions, plugins) {
      const values2 = [
        ...Object.keys(vueCompilerOptions).sort().filter((key2) => key2 !== "plugins").map((key2) => [key2, vueCompilerOptions[key2]]),
        [...new Set(plugins.map((plugin) => plugin.requiredCompilerOptions ?? []).flat())].sort().map((key2) => [key2, compilerOptions[key2]])
      ];
      return JSON.stringify(values2);
    }
    function createVueLanguagePlugin2(ts3, compilerOptions, vueCompilerOptions, asFileName) {
      const pluginContext = {
        modules: {
          "@vue/compiler-dom": vueCompilerOptions.target < 3 ? {
            ...CompilerDOM,
            compile: CompilerVue2.compile
          } : CompilerDOM,
          typescript: ts3
        },
        compilerOptions,
        vueCompilerOptions
      };
      const plugins = (0, plugins_1.createPlugins)(pluginContext);
      const fileRegistry = getVueFileRegistry(getFileRegistryKey(compilerOptions, vueCompilerOptions, plugins), vueCompilerOptions.plugins);
      return {
        getLanguageId(scriptId) {
          var _a;
          const fileName = asFileName(scriptId);
          for (const plugin of plugins) {
            const languageId = (_a = plugin.getLanguageId) == null ? void 0 : _a.call(plugin, fileName);
            if (languageId) {
              return languageId;
            }
          }
        },
        createVirtualCode(scriptId, languageId, snapshot) {
          const fileName = asFileName(scriptId);
          if (plugins.some((plugin) => {
            var _a;
            return (_a = plugin.isValidFile) == null ? void 0 : _a.call(plugin, fileName, languageId);
          })) {
            const code3 = fileRegistry.get(fileName);
            if (code3) {
              code3.update(snapshot);
              return code3;
            } else {
              const code4 = new vueFile_1.VueVirtualCode(fileName, languageId, snapshot, vueCompilerOptions, plugins, ts3);
              fileRegistry.set(fileName, code4);
              return code4;
            }
          }
        },
        updateVirtualCode(_fileId, code3, snapshot) {
          code3.update(snapshot);
          return code3;
        },
        typescript: {
          extraFileExtensions: getAllExtensions(vueCompilerOptions).map((ext) => ({
            extension: ext.slice(1),
            isMixedContent: true,
            scriptKind: 7
          })),
          getServiceScript(root4) {
            for (const code3 of (0, language_core_1.forEachEmbeddedCode)(root4)) {
              if (/script_(js|jsx|ts|tsx)/.test(code3.id)) {
                const lang = code3.id.substring("script_".length);
                return {
                  code: code3,
                  extension: "." + lang,
                  scriptKind: lang === "js" ? ts3.ScriptKind.JS : lang === "jsx" ? ts3.ScriptKind.JSX : lang === "tsx" ? ts3.ScriptKind.TSX : ts3.ScriptKind.TS
                };
              }
            }
          }
        }
      };
    }
    function getAllExtensions(options) {
      const result = /* @__PURE__ */ new Set();
      for (const key2 in options) {
        if (key2 === "extensions" || key2.endsWith("Extensions")) {
          const value = options[key2];
          if (Array.isArray(value) && value.every((v) => typeof v === "string")) {
            for (const ext of value) {
              result.add(ext);
            }
          }
        }
      }
      return [...result];
    }
  }
});

// node_modules/@vue/language-core/lib/utils/ts.js
var require_ts = __commonJS({
  "node_modules/@vue/language-core/lib/utils/ts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createParsedCommandLineByJson = createParsedCommandLineByJson;
    exports.createParsedCommandLine = createParsedCommandLine;
    exports.resolveVueCompilerOptions = resolveVueCompilerOptions2;
    exports.setupGlobalTypes = setupGlobalTypes2;
    var shared_1 = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    var path_browserify_1 = require_path_browserify();
    var languagePlugin_1 = require_languagePlugin();
    var globalTypes_1 = require_globalTypes();
    function createParsedCommandLineByJson(ts3, parseConfigHost, rootDir, json, configFileName = rootDir + "/jsconfig.json", skipGlobalTypesSetup = false) {
      const proxyHost = proxyParseConfigHostForExtendConfigPaths(parseConfigHost);
      ts3.parseJsonConfigFileContent(json, proxyHost.host, rootDir, {}, configFileName);
      let vueOptions = {};
      for (const extendPath of proxyHost.extendConfigPaths.reverse()) {
        try {
          vueOptions = {
            ...vueOptions,
            ...getPartialVueCompilerOptions(ts3, ts3.readJsonConfigFile(extendPath, proxyHost.host.readFile))
          };
        } catch (err) {
        }
      }
      const resolvedVueOptions = resolveVueCompilerOptions2(vueOptions);
      if (skipGlobalTypesSetup) {
        resolvedVueOptions.__setupedGlobalTypes = true;
      } else {
        resolvedVueOptions.__setupedGlobalTypes = setupGlobalTypes2(rootDir, resolvedVueOptions, parseConfigHost);
      }
      const parsed = ts3.parseJsonConfigFileContent(json, proxyHost.host, rootDir, {}, configFileName, void 0, (0, languagePlugin_1.getAllExtensions)(resolvedVueOptions).map((extension2) => ({
        extension: extension2.slice(1),
        isMixedContent: true,
        scriptKind: ts3.ScriptKind.Deferred
      })));
      parsed.options.outDir = void 0;
      return {
        ...parsed,
        vueOptions: resolvedVueOptions
      };
    }
    function createParsedCommandLine(ts3, parseConfigHost, tsConfigPath, skipGlobalTypesSetup = false) {
      try {
        const proxyHost = proxyParseConfigHostForExtendConfigPaths(parseConfigHost);
        const config = ts3.readJsonConfigFile(tsConfigPath, proxyHost.host.readFile);
        ts3.parseJsonSourceFileConfigFileContent(config, proxyHost.host, path_browserify_1.posix.dirname(tsConfigPath), {}, tsConfigPath);
        let vueOptions = {};
        for (const extendPath of proxyHost.extendConfigPaths.reverse()) {
          try {
            vueOptions = {
              ...vueOptions,
              ...getPartialVueCompilerOptions(ts3, ts3.readJsonConfigFile(extendPath, proxyHost.host.readFile))
            };
          } catch (err) {
          }
        }
        const resolvedVueOptions = resolveVueCompilerOptions2(vueOptions);
        if (skipGlobalTypesSetup) {
          resolvedVueOptions.__setupedGlobalTypes = true;
        } else {
          resolvedVueOptions.__setupedGlobalTypes = setupGlobalTypes2(path_browserify_1.posix.dirname(tsConfigPath), resolvedVueOptions, parseConfigHost);
        }
        const parsed = ts3.parseJsonSourceFileConfigFileContent(config, proxyHost.host, path_browserify_1.posix.dirname(tsConfigPath), {}, tsConfigPath, void 0, (0, languagePlugin_1.getAllExtensions)(resolvedVueOptions).map((extension2) => ({
          extension: extension2.slice(1),
          isMixedContent: true,
          scriptKind: ts3.ScriptKind.Deferred
        })));
        parsed.options.outDir = void 0;
        return {
          ...parsed,
          vueOptions: resolvedVueOptions
        };
      } catch (err) {
        return {
          fileNames: [],
          options: {},
          vueOptions: resolveVueCompilerOptions2({}),
          errors: []
        };
      }
    }
    function proxyParseConfigHostForExtendConfigPaths(parseConfigHost) {
      const extendConfigPaths = [];
      const host = new Proxy(parseConfigHost, {
        get(target, key2) {
          if (key2 === "readFile") {
            return (fileName) => {
              if (!fileName.endsWith("/package.json") && !extendConfigPaths.includes(fileName)) {
                extendConfigPaths.push(fileName);
              }
              return target.readFile(fileName);
            };
          }
          return target[key2];
        }
      });
      return {
        host,
        extendConfigPaths
      };
    }
    function getPartialVueCompilerOptions(ts3, tsConfigSourceFile) {
      const folder = path_browserify_1.posix.dirname(tsConfigSourceFile.fileName);
      const obj = ts3.convertToObject(tsConfigSourceFile, []);
      const rawOptions = (obj == null ? void 0 : obj.vueCompilerOptions) ?? {};
      const result = {
        ...rawOptions
      };
      const target = rawOptions.target ?? "auto";
      if (target === "auto") {
        const resolvedPath = resolvePath("vue/package.json");
        if (resolvedPath) {
          const vuePackageJson = __require(resolvedPath);
          const versionNumbers = vuePackageJson.version.split(".");
          result.target = Number(versionNumbers[0] + "." + versionNumbers[1]);
        } else {
        }
      } else {
        result.target = target;
      }
      if (rawOptions.plugins) {
        const plugins = rawOptions.plugins.map((pluginPath) => {
          try {
            const resolvedPath = resolvePath(pluginPath);
            if (resolvedPath) {
              const plugin = __require(resolvedPath);
              plugin.__moduleName = pluginPath;
              return plugin;
            } else {
              console.warn("[Vue] Load plugin failed:", pluginPath);
            }
          } catch (error2) {
            console.warn("[Vue] Resolve plugin path failed:", pluginPath, error2);
          }
          return [];
        });
        result.plugins = plugins;
      }
      return result;
      function resolvePath(scriptPath) {
        try {
          if (__require == null ? void 0 : __require.resolve) {
            return __require.resolve(scriptPath, { paths: [folder] });
          } else {
          }
        } catch (error2) {
        }
      }
    }
    function resolveVueCompilerOptions2(vueOptions) {
      const target = vueOptions.target ?? 3.3;
      const lib = vueOptions.lib ?? "vue";
      return {
        ...vueOptions,
        target,
        extensions: vueOptions.extensions ?? [".vue"],
        vitePressExtensions: vueOptions.vitePressExtensions ?? [],
        petiteVueExtensions: vueOptions.petiteVueExtensions ?? [],
        lib,
        jsxSlots: vueOptions.jsxSlots ?? false,
        strictTemplates: vueOptions.strictTemplates ?? false,
        skipTemplateCodegen: vueOptions.skipTemplateCodegen ?? false,
        fallthroughAttributes: vueOptions.fallthroughAttributes ?? false,
        dataAttributes: vueOptions.dataAttributes ?? [],
        htmlAttributes: vueOptions.htmlAttributes ?? ["aria-*"],
        optionsWrapper: vueOptions.optionsWrapper ?? (target >= 2.7 ? [`(await import('${lib}')).defineComponent(`, `)`] : [`(await import('${lib}')).default.extend(`, `)`]),
        macros: {
          defineProps: ["defineProps"],
          defineSlots: ["defineSlots"],
          defineEmits: ["defineEmits"],
          defineExpose: ["defineExpose"],
          defineModel: ["defineModel"],
          defineOptions: ["defineOptions"],
          withDefaults: ["withDefaults"],
          ...vueOptions.macros
        },
        composibles: {
          useCssModule: ["useCssModule"],
          useTemplateRef: ["useTemplateRef", "templateRef"],
          ...vueOptions.composibles
        },
        plugins: vueOptions.plugins ?? [],
        // experimental
        experimentalDefinePropProposal: vueOptions.experimentalDefinePropProposal ?? false,
        experimentalResolveStyleCssClasses: vueOptions.experimentalResolveStyleCssClasses ?? "scoped",
        // https://github.com/vuejs/vue-next/blob/master/packages/compiler-dom/src/transforms/vModel.ts#L49-L51
        // https://vuejs.org/guide/essentials/forms.html#form-input-bindings
        experimentalModelPropName: Object.fromEntries(Object.entries(vueOptions.experimentalModelPropName ?? {
          "": {
            input: true
          },
          value: {
            input: { type: "text" },
            textarea: true,
            select: true
          }
        }).map(([k, v]) => [(0, shared_1.camelize)(k), v]))
      };
    }
    function setupGlobalTypes2(rootDir, vueOptions, host) {
      if (!host.writeFile) {
        return;
      }
      try {
        let dir = rootDir;
        while (!host.fileExists(path_browserify_1.posix.join(dir, "node_modules", vueOptions.lib, "package.json"))) {
          const parentDir = path_browserify_1.posix.dirname(dir);
          if (dir === parentDir) {
            throw 0;
          }
          dir = parentDir;
        }
        const globalTypesPath = path_browserify_1.posix.join(dir, "node_modules", ".vue-global-types", `${vueOptions.lib}_${vueOptions.target}_${vueOptions.strictTemplates}.d.ts`);
        const globalTypesContents = `// @ts-nocheck
export {};
` + (0, globalTypes_1.generateGlobalTypes)(vueOptions.lib, vueOptions.target, vueOptions.strictTemplates);
        host.writeFile(globalTypesPath, globalTypesContents);
        return { absolutePath: globalTypesPath };
      } catch {
      }
    }
  }
});

// node_modules/@vue/language-core/index.js
var require_language_core2 = __commonJS({
  "node_modules/@vue/language-core/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tsCodegen = exports.scriptRanges = void 0;
    __exportStar(require_globalTypes(), exports);
    __exportStar(require_template(), exports);
    __exportStar(require_languagePlugin(), exports);
    __exportStar(require_scriptSetupRanges(), exports);
    __exportStar(require_plugins(), exports);
    __exportStar(require_types3(), exports);
    __exportStar(require_parseSfc(), exports);
    __exportStar(require_ts(), exports);
    __exportStar(require_vueFile(), exports);
    exports.scriptRanges = require_scriptRanges();
    var vue_tsx_1 = require_vue_tsx();
    Object.defineProperty(exports, "tsCodegen", { enumerable: true, get: function() {
      return vue_tsx_1.tsCodegen;
    } });
    __exportStar(require_shared(), exports);
    __exportStar(require_language_core(), exports);
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env2) {
      createDebug2.debug = createDebug2;
      createDebug2.default = createDebug2;
      createDebug2.coerce = coerce;
      createDebug2.disable = disable2;
      createDebug2.enable = enable;
      createDebug2.enabled = enabled;
      createDebug2.humanize = require_ms();
      createDebug2.destroy = destroy;
      Object.keys(env2).forEach((key2) => {
        createDebug2[key2] = env2[key2];
      });
      createDebug2.names = [];
      createDebug2.skips = [];
      createDebug2.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
      }
      createDebug2.selectColor = selectColor;
      function createDebug2(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug2.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug2.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug2.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug2.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug2.useColors();
        debug2.color = createDebug2.selectColor(namespace);
        debug2.extend = extend3;
        debug2.destroy = createDebug2.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug2.namespaces) {
              namespacesCache = createDebug2.namespaces;
              enabledCache = createDebug2.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug2.init === "function") {
          createDebug2.init(debug2);
        }
        return debug2;
      }
      function extend3(namespace, delimiter) {
        const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug2.save(namespaces);
        createDebug2.namespaces = namespaces;
        createDebug2.names = [];
        createDebug2.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug2.skips.push(ns.slice(1));
          } else {
            createDebug2.names.push(ns);
          }
        }
      }
      function matchesTemplate(search2, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search2.length) {
          if (templateIndex < template.length && (template[templateIndex] === search2[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable2() {
        const namespaces = [
          ...createDebug2.names,
          ...createDebug2.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug2.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug2.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug2.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug2.enable(createDebug2.load());
      return createDebug2;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r4;
      try {
        r4 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r4 && typeof process !== "undefined" && "env" in process) {
        r4 = process.env.DEBUG;
      }
      return r4;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = require_common2()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/@shikijs/types/dist/index.mjs
var ShikiError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ShikiError";
  }
};

// node_modules/@shikijs/engine-oniguruma/dist/index.mjs
var ShikiError2 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ShikiError";
  }
};
function getHeapMax() {
  return 2147483648;
}
function _emscripten_get_now() {
  return typeof performance !== "undefined" ? performance.now() : Date.now();
}
var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
async function main(init) {
  let wasmMemory;
  let buffer;
  const binding = {};
  function updateGlobalBufferAndViews(buf) {
    buffer = buf;
    binding.HEAPU8 = new Uint8Array(buf);
    binding.HEAPU32 = new Uint32Array(buf);
  }
  function _emscripten_memcpy_big(dest, src, num) {
    binding.HEAPU8.copyWithin(dest, src, src + num);
  }
  function emscripten_realloc_buffer(size) {
    try {
      wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
      updateGlobalBufferAndViews(wasmMemory.buffer);
      return 1;
    } catch {
    }
  }
  function _emscripten_resize_heap(requestedSize) {
    const oldSize = binding.HEAPU8.length;
    requestedSize = requestedSize >>> 0;
    const maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize)
      return false;
    for (let cutDown = 1; cutDown <= 4; cutDown *= 2) {
      let overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      const newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      const replacement = emscripten_realloc_buffer(newSize);
      if (replacement)
        return true;
    }
    return false;
  }
  const UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead = 1024) {
    const endIdx = idx + maxBytesToRead;
    let endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    let str = "";
    while (idx < endPtr) {
      let u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      const u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) === 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      const u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) === 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        const ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  }
  function UTF8ToString(ptr, maxBytesToRead) {
    return ptr ? UTF8ArrayToString(binding.HEAPU8, ptr, maxBytesToRead) : "";
  }
  const asmLibraryArg = {
    emscripten_get_now: _emscripten_get_now,
    emscripten_memcpy_big: _emscripten_memcpy_big,
    emscripten_resize_heap: _emscripten_resize_heap,
    fd_write: () => 0
  };
  async function createWasm() {
    const info = {
      env: asmLibraryArg,
      wasi_snapshot_preview1: asmLibraryArg
    };
    const exports = await init(info);
    wasmMemory = exports.memory;
    updateGlobalBufferAndViews(wasmMemory.buffer);
    Object.assign(binding, exports);
    binding.UTF8ToString = UTF8ToString;
  }
  await createWasm();
  return binding;
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField2 = (obj, key2, value) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var onigBinding = null;
function throwLastOnigError(onigBinding2) {
  throw new ShikiError2(onigBinding2.UTF8ToString(onigBinding2.getLastOnigError()));
}
var UtfString = class _UtfString {
  constructor(str) {
    __publicField2(this, "utf16Length");
    __publicField2(this, "utf8Length");
    __publicField2(this, "utf16Value");
    __publicField2(this, "utf8Value");
    __publicField2(this, "utf16OffsetToUtf8");
    __publicField2(this, "utf8OffsetToUtf16");
    const utf16Length = str.length;
    const utf8Length = _UtfString._utf8ByteLength(str);
    const computeIndicesMapping = utf8Length !== utf16Length;
    const utf16OffsetToUtf8 = computeIndicesMapping ? new Uint32Array(utf16Length + 1) : null;
    if (computeIndicesMapping)
      utf16OffsetToUtf8[utf16Length] = utf8Length;
    const utf8OffsetToUtf16 = computeIndicesMapping ? new Uint32Array(utf8Length + 1) : null;
    if (computeIndicesMapping)
      utf8OffsetToUtf16[utf8Length] = utf16Length;
    const utf8Value = new Uint8Array(utf8Length);
    let i8 = 0;
    for (let i16 = 0; i16 < utf16Length; i16++) {
      const charCode = str.charCodeAt(i16);
      let codePoint = charCode;
      let wasSurrogatePair = false;
      if (charCode >= 55296 && charCode <= 56319) {
        if (i16 + 1 < utf16Length) {
          const nextCharCode = str.charCodeAt(i16 + 1);
          if (nextCharCode >= 56320 && nextCharCode <= 57343) {
            codePoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
            wasSurrogatePair = true;
          }
        }
      }
      if (computeIndicesMapping) {
        utf16OffsetToUtf8[i16] = i8;
        if (wasSurrogatePair)
          utf16OffsetToUtf8[i16 + 1] = i8;
        if (codePoint <= 127) {
          utf8OffsetToUtf16[i8 + 0] = i16;
        } else if (codePoint <= 2047) {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
        } else if (codePoint <= 65535) {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
          utf8OffsetToUtf16[i8 + 2] = i16;
        } else {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
          utf8OffsetToUtf16[i8 + 2] = i16;
          utf8OffsetToUtf16[i8 + 3] = i16;
        }
      }
      if (codePoint <= 127) {
        utf8Value[i8++] = codePoint;
      } else if (codePoint <= 2047) {
        utf8Value[i8++] = 192 | (codePoint & 1984) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      } else if (codePoint <= 65535) {
        utf8Value[i8++] = 224 | (codePoint & 61440) >>> 12;
        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      } else {
        utf8Value[i8++] = 240 | (codePoint & 1835008) >>> 18;
        utf8Value[i8++] = 128 | (codePoint & 258048) >>> 12;
        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      }
      if (wasSurrogatePair)
        i16++;
    }
    this.utf16Length = utf16Length;
    this.utf8Length = utf8Length;
    this.utf16Value = str;
    this.utf8Value = utf8Value;
    this.utf16OffsetToUtf8 = utf16OffsetToUtf8;
    this.utf8OffsetToUtf16 = utf8OffsetToUtf16;
  }
  static _utf8ByteLength(str) {
    let result = 0;
    for (let i = 0, len = str.length; i < len; i++) {
      const charCode = str.charCodeAt(i);
      let codepoint = charCode;
      let wasSurrogatePair = false;
      if (charCode >= 55296 && charCode <= 56319) {
        if (i + 1 < len) {
          const nextCharCode = str.charCodeAt(i + 1);
          if (nextCharCode >= 56320 && nextCharCode <= 57343) {
            codepoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
            wasSurrogatePair = true;
          }
        }
      }
      if (codepoint <= 127)
        result += 1;
      else if (codepoint <= 2047)
        result += 2;
      else if (codepoint <= 65535)
        result += 3;
      else
        result += 4;
      if (wasSurrogatePair)
        i++;
    }
    return result;
  }
  createString(onigBinding2) {
    const result = onigBinding2.omalloc(this.utf8Length);
    onigBinding2.HEAPU8.set(this.utf8Value, result);
    return result;
  }
};
var _OnigString = class {
  constructor(str) {
    __publicField2(this, "id", ++_OnigString.LAST_ID);
    __publicField2(this, "_onigBinding");
    __publicField2(this, "content");
    __publicField2(this, "utf16Length");
    __publicField2(this, "utf8Length");
    __publicField2(this, "utf16OffsetToUtf8");
    __publicField2(this, "utf8OffsetToUtf16");
    __publicField2(this, "ptr");
    if (!onigBinding)
      throw new ShikiError2("Must invoke loadWasm first.");
    this._onigBinding = onigBinding;
    this.content = str;
    const utfString = new UtfString(str);
    this.utf16Length = utfString.utf16Length;
    this.utf8Length = utfString.utf8Length;
    this.utf16OffsetToUtf8 = utfString.utf16OffsetToUtf8;
    this.utf8OffsetToUtf16 = utfString.utf8OffsetToUtf16;
    if (this.utf8Length < 1e4 && !_OnigString._sharedPtrInUse) {
      if (!_OnigString._sharedPtr)
        _OnigString._sharedPtr = onigBinding.omalloc(1e4);
      _OnigString._sharedPtrInUse = true;
      onigBinding.HEAPU8.set(utfString.utf8Value, _OnigString._sharedPtr);
      this.ptr = _OnigString._sharedPtr;
    } else {
      this.ptr = utfString.createString(onigBinding);
    }
  }
  convertUtf8OffsetToUtf16(utf8Offset) {
    if (this.utf8OffsetToUtf16) {
      if (utf8Offset < 0)
        return 0;
      if (utf8Offset > this.utf8Length)
        return this.utf16Length;
      return this.utf8OffsetToUtf16[utf8Offset];
    }
    return utf8Offset;
  }
  convertUtf16OffsetToUtf8(utf16Offset) {
    if (this.utf16OffsetToUtf8) {
      if (utf16Offset < 0)
        return 0;
      if (utf16Offset > this.utf16Length)
        return this.utf8Length;
      return this.utf16OffsetToUtf8[utf16Offset];
    }
    return utf16Offset;
  }
  dispose() {
    if (this.ptr === _OnigString._sharedPtr)
      _OnigString._sharedPtrInUse = false;
    else
      this._onigBinding.ofree(this.ptr);
  }
};
var OnigString = _OnigString;
__publicField2(OnigString, "LAST_ID", 0);
__publicField2(OnigString, "_sharedPtr", 0);
__publicField2(OnigString, "_sharedPtrInUse", false);
var OnigScanner = class {
  constructor(patterns) {
    __publicField2(this, "_onigBinding");
    __publicField2(this, "_ptr");
    if (!onigBinding)
      throw new ShikiError2("Must invoke loadWasm first.");
    const strPtrsArr = [];
    const strLenArr = [];
    for (let i = 0, len = patterns.length; i < len; i++) {
      const utfString = new UtfString(patterns[i]);
      strPtrsArr[i] = utfString.createString(onigBinding);
      strLenArr[i] = utfString.utf8Length;
    }
    const strPtrsPtr = onigBinding.omalloc(4 * patterns.length);
    onigBinding.HEAPU32.set(strPtrsArr, strPtrsPtr / 4);
    const strLenPtr = onigBinding.omalloc(4 * patterns.length);
    onigBinding.HEAPU32.set(strLenArr, strLenPtr / 4);
    const scannerPtr = onigBinding.createOnigScanner(strPtrsPtr, strLenPtr, patterns.length);
    for (let i = 0, len = patterns.length; i < len; i++)
      onigBinding.ofree(strPtrsArr[i]);
    onigBinding.ofree(strLenPtr);
    onigBinding.ofree(strPtrsPtr);
    if (scannerPtr === 0)
      throwLastOnigError(onigBinding);
    this._onigBinding = onigBinding;
    this._ptr = scannerPtr;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(string4, startPosition, arg) {
    let options = 0;
    if (typeof arg === "number") {
      options = arg;
    }
    if (typeof string4 === "string") {
      string4 = new OnigString(string4);
      const result = this._findNextMatchSync(string4, startPosition, false, options);
      string4.dispose();
      return result;
    }
    return this._findNextMatchSync(string4, startPosition, false, options);
  }
  _findNextMatchSync(string4, startPosition, debugCall, options) {
    const onigBinding2 = this._onigBinding;
    const resultPtr = onigBinding2.findNextOnigScannerMatch(this._ptr, string4.id, string4.ptr, string4.utf8Length, string4.convertUtf16OffsetToUtf8(startPosition), options);
    if (resultPtr === 0) {
      return null;
    }
    const HEAPU32 = onigBinding2.HEAPU32;
    let offset = resultPtr / 4;
    const index2 = HEAPU32[offset++];
    const count = HEAPU32[offset++];
    const captureIndices = [];
    for (let i = 0; i < count; i++) {
      const beg = string4.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
      const end = string4.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
      captureIndices[i] = {
        start: beg,
        end,
        length: end - beg
      };
    }
    return {
      index: index2,
      captureIndices
    };
  }
};
function isInstantiatorOptionsObject(dataOrOptions) {
  return typeof dataOrOptions.instantiator === "function";
}
function isInstantiatorModule(dataOrOptions) {
  return typeof dataOrOptions.default === "function";
}
function isDataOptionsObject(dataOrOptions) {
  return typeof dataOrOptions.data !== "undefined";
}
function isResponse(dataOrOptions) {
  return typeof Response !== "undefined" && dataOrOptions instanceof Response;
}
function isArrayBuffer(data) {
  var _a;
  return typeof ArrayBuffer !== "undefined" && (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) || typeof Buffer !== "undefined" && ((_a = Buffer.isBuffer) == null ? void 0 : _a.call(Buffer, data)) || typeof SharedArrayBuffer !== "undefined" && data instanceof SharedArrayBuffer || typeof Uint32Array !== "undefined" && data instanceof Uint32Array;
}
var initPromise;
function loadWasm(options) {
  if (initPromise)
    return initPromise;
  async function _load() {
    onigBinding = await main(async (info) => {
      let instance = options;
      instance = await instance;
      if (typeof instance === "function")
        instance = await instance(info);
      if (typeof instance === "function")
        instance = await instance(info);
      if (isInstantiatorOptionsObject(instance)) {
        instance = await instance.instantiator(info);
      } else if (isInstantiatorModule(instance)) {
        instance = await instance.default(info);
      } else {
        if (isDataOptionsObject(instance))
          instance = instance.data;
        if (isResponse(instance)) {
          if (typeof WebAssembly.instantiateStreaming === "function")
            instance = await _makeResponseStreamingLoader(instance)(info);
          else
            instance = await _makeResponseNonStreamingLoader(instance)(info);
        } else if (isArrayBuffer(instance)) {
          instance = await _makeArrayBufferLoader(instance)(info);
        } else if (instance instanceof WebAssembly.Module) {
          instance = await _makeArrayBufferLoader(instance)(info);
        } else if ("default" in instance && instance.default instanceof WebAssembly.Module) {
          instance = await _makeArrayBufferLoader(instance.default)(info);
        }
      }
      if ("instance" in instance)
        instance = instance.instance;
      if ("exports" in instance)
        instance = instance.exports;
      return instance;
    });
  }
  initPromise = _load();
  return initPromise;
}
function _makeArrayBufferLoader(data) {
  return (importObject) => WebAssembly.instantiate(data, importObject);
}
function _makeResponseStreamingLoader(data) {
  return (importObject) => WebAssembly.instantiateStreaming(data, importObject);
}
function _makeResponseNonStreamingLoader(data) {
  return async (importObject) => {
    const arrayBuffer = await data.arrayBuffer();
    return WebAssembly.instantiate(arrayBuffer, importObject);
  };
}
var _defaultWasmLoader;
function getDefaultWasmLoader() {
  return _defaultWasmLoader;
}
async function createOnigurumaEngine(options) {
  if (options)
    await loadWasm(options);
  return {
    createScanner(patterns) {
      return new OnigScanner(patterns.map((p2) => typeof p2 === "string" ? p2 : p2.source));
    },
    createString(s) {
      return new OnigString(s);
    }
  };
}

// node_modules/@shikijs/core/dist/shared/core.Bn_XU0Iv.mjs
var _emitDeprecation = false;
var _emitError = false;
function warnDeprecated(message, version = 3) {
  if (!_emitDeprecation)
    return;
  if (typeof _emitDeprecation === "number" && version > _emitDeprecation)
    return;
  if (_emitError) {
    throw new Error(`[SHIKI DEPRECATE]: ${message}`);
  } else {
    console.trace(`[SHIKI DEPRECATE]: ${message}`);
  }
}

// node_modules/html-void-elements/index.js
var htmlVoidElements = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];

// node_modules/property-information/lib/util/schema.js
var Schema = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(property2, normal, space2) {
    this.normal = normal;
    this.property = property2;
    if (space2) {
      this.space = space2;
    }
  }
};
Schema.prototype.normal = {};
Schema.prototype.property = {};
Schema.prototype.space = void 0;

// node_modules/property-information/lib/util/merge.js
function merge(definitions, space2) {
  const property2 = {};
  const normal = {};
  for (const definition3 of definitions) {
    Object.assign(property2, definition3.property);
    Object.assign(normal, definition3.normal);
  }
  return new Schema(property2, normal, space2);
}

// node_modules/property-information/lib/normalize.js
function normalize(value) {
  return value.toLowerCase();
}

// node_modules/property-information/lib/util/info.js
var Info = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(property2, attribute) {
    this.attribute = attribute;
    this.property = property2;
  }
};
Info.prototype.attribute = "";
Info.prototype.booleanish = false;
Info.prototype.boolean = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.commaSeparated = false;
Info.prototype.defined = false;
Info.prototype.mustUseProperty = false;
Info.prototype.number = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.property = "";
Info.prototype.spaceSeparated = false;
Info.prototype.space = void 0;

// node_modules/property-information/lib/util/types.js
var types_exports = {};
__export(types_exports, {
  boolean: () => boolean,
  booleanish: () => booleanish,
  commaOrSpaceSeparated: () => commaOrSpaceSeparated,
  commaSeparated: () => commaSeparated,
  number: () => number,
  overloadedBoolean: () => overloadedBoolean,
  spaceSeparated: () => spaceSeparated
});
var powers = 0;
var boolean = increment();
var booleanish = increment();
var overloadedBoolean = increment();
var number = increment();
var spaceSeparated = increment();
var commaSeparated = increment();
var commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}

// node_modules/property-information/lib/util/defined-info.js
var checks = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(types_exports)
);
var DefinedInfo = class extends Info {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(property2, attribute, mask, space2) {
    let index2 = -1;
    super(property2, attribute);
    mark(this, "space", space2);
    if (typeof mask === "number") {
      while (++index2 < checks.length) {
        const check = checks[index2];
        mark(this, checks[index2], (mask & types_exports[check]) === types_exports[check]);
      }
    }
  }
};
DefinedInfo.prototype.defined = true;
function mark(values2, key2, value) {
  if (value) {
    values2[key2] = value;
  }
}

// node_modules/property-information/lib/util/create.js
function create(definition3) {
  const properties = {};
  const normals = {};
  for (const [property2, value] of Object.entries(definition3.properties)) {
    const info = new DefinedInfo(
      property2,
      definition3.transform(definition3.attributes || {}, property2),
      value,
      definition3.space
    );
    if (definition3.mustUseProperty && definition3.mustUseProperty.includes(property2)) {
      info.mustUseProperty = true;
    }
    properties[property2] = info;
    normals[normalize(property2)] = property2;
    normals[normalize(info.attribute)] = property2;
  }
  return new Schema(properties, normals, definition3.space);
}

// node_modules/property-information/lib/aria.js
var aria = create({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  },
  transform(_, property2) {
    return property2 === "role" ? property2 : "aria-" + property2.slice(4).toLowerCase();
  }
});

// node_modules/property-information/lib/util/case-sensitive-transform.js
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}

// node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform(attributes, property2) {
  return caseSensitiveTransform(attributes, property2.toLowerCase());
}

// node_modules/property-information/lib/html.js
var html = create({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: overloadedBoolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: caseInsensitiveTransform
});

// node_modules/property-information/lib/svg.js
var svg = create({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: caseSensitiveTransform
});

// node_modules/property-information/lib/xlink.js
var xlink = create({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(_, property2) {
    return "xlink:" + property2.slice(5).toLowerCase();
  }
});

// node_modules/property-information/lib/xmlns.js
var xmlns = create({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: caseInsensitiveTransform
});

// node_modules/property-information/lib/xml.js
var xml = create({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(_, property2) {
    return "xml:" + property2.slice(3).toLowerCase();
  }
});

// node_modules/property-information/lib/find.js
var cap = /[A-Z]/g;
var dash = /-[a-z]/g;
var valid = /^data[-\w.:]+$/i;
function find(schema, value) {
  const normal = normalize(value);
  let property2 = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      property2 = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(property2, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}

// node_modules/property-information/index.js
var html2 = merge([aria, html, xlink, xmlns, xml], "html");
var svg2 = merge([aria, svg, xlink, xmlns, xml], "svg");

// node_modules/zwitch/index.js
var own = {}.hasOwnProperty;
function zwitch(key2, options) {
  const settings = options || {};
  function one3(value, ...parameters) {
    let fn = one3.invalid;
    const handlers2 = one3.handlers;
    if (value && own.call(value, key2)) {
      const id = String(value[key2]);
      fn = own.call(handlers2, id) ? handlers2[id] : one3.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one3.handlers = settings.handlers || {};
  one3.invalid = settings.invalid;
  one3.unknown = settings.unknown;
  return one3;
}

// node_modules/stringify-entities/lib/core.js
var defaultSubsetRegex = /["&'<>`]/g;
var surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var controlCharactersRegex = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
);
var regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g;
var subsetToRegexCache = /* @__PURE__ */ new WeakMap();
function core(value, options) {
  value = value.replace(
    options.subset ? charactersToExpressionCached(options.subset) : defaultSubsetRegex,
    basic
  );
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(surrogatePairsRegex, surrogate).replace(controlCharactersRegex, basic);
  function surrogate(pair, index2, all3) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all3.charCodeAt(index2 + 2),
      options
    );
  }
  function basic(character, index2, all3) {
    return options.format(
      character.charCodeAt(0),
      all3.charCodeAt(index2 + 1),
      options
    );
  }
}
function charactersToExpressionCached(subset) {
  let cached = subsetToRegexCache.get(subset);
  if (!cached) {
    cached = charactersToExpression(subset);
    subsetToRegexCache.set(subset, cached);
  }
  return cached;
}
function charactersToExpression(subset) {
  const groups = [];
  let index2 = -1;
  while (++index2 < subset.length) {
    groups.push(subset[index2].replace(regexEscapeRegex, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}

// node_modules/stringify-entities/lib/util/to-hexadecimal.js
var hexadecimalRegex = /[\dA-Fa-f]/;
function toHexadecimal(code3, next, omit) {
  const value = "&#x" + code3.toString(16).toUpperCase();
  return omit && next && !hexadecimalRegex.test(String.fromCharCode(next)) ? value : value + ";";
}

// node_modules/stringify-entities/lib/util/to-decimal.js
var decimalRegex = /\d/;
function toDecimal(code3, next, omit) {
  const value = "&#" + String(code3);
  return omit && next && !decimalRegex.test(String.fromCharCode(next)) ? value : value + ";";
}

// node_modules/character-entities-legacy/index.js
var characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];

// node_modules/character-entities-html4/index.js
var characterEntitiesHtml4 = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
};

// node_modules/stringify-entities/lib/constant/dangerous.js
var dangerous = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];

// node_modules/stringify-entities/lib/util/to-named.js
var own2 = {}.hasOwnProperty;
var characters = {};
var key;
for (key in characterEntitiesHtml4) {
  if (own2.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}
var notAlphanumericRegex = /[^\dA-Za-z]/;
function toNamed(code3, next, omit, attribute) {
  const character = String.fromCharCode(code3);
  if (own2.call(characters, character)) {
    const name = characters[character];
    const value = "&" + name;
    if (omit && characterEntitiesLegacy.includes(name) && !dangerous.includes(name) && (!attribute || next && next !== 61 && notAlphanumericRegex.test(String.fromCharCode(next)))) {
      return value;
    }
    return value + ";";
  }
  return "";
}

// node_modules/stringify-entities/lib/util/format-smart.js
function formatSmart(code3, next, options) {
  let numeric = toHexadecimal(code3, next, options.omitOptionalSemicolons);
  let named;
  if (options.useNamedReferences || options.useShortestReferences) {
    named = toNamed(
      code3,
      next,
      options.omitOptionalSemicolons,
      options.attribute
    );
  }
  if ((options.useShortestReferences || !named) && options.useShortestReferences) {
    const decimal = toDecimal(code3, next, options.omitOptionalSemicolons);
    if (decimal.length < numeric.length) {
      numeric = decimal;
    }
  }
  return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;
}

// node_modules/stringify-entities/lib/index.js
function stringifyEntities(value, options) {
  return core(value, Object.assign({ format: formatSmart }, options));
}

// node_modules/hast-util-to-html/lib/handle/comment.js
var htmlCommentRegex = /^>|^->|<!--|-->|--!>|<!-$/g;
var bogusCommentEntitySubset = [">"];
var commentEntitySubset = ["<", ">"];
function comment(node2, _1, _2, state) {
  return state.settings.bogusComments ? "<?" + stringifyEntities(
    node2.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: bogusCommentEntitySubset
    })
  ) + ">" : "<!--" + node2.value.replace(htmlCommentRegex, encode2) + "-->";
  function encode2($0) {
    return stringifyEntities(
      $0,
      Object.assign({}, state.settings.characterReferences, {
        subset: commentEntitySubset
      })
    );
  }
}

// node_modules/hast-util-to-html/lib/handle/doctype.js
function doctype(_1, _2, _3, state) {
  return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
}

// node_modules/ccount/index.js
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = source.indexOf(character, index2 + character.length);
  }
  return count;
}

// node_modules/comma-separated-tokens/index.js
function stringify(values2, options) {
  const settings = options || {};
  const input = values2[values2.length - 1] === "" ? [...values2, ""] : values2;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}

// node_modules/space-separated-tokens/index.js
function stringify2(values2) {
  return values2.join(" ").trim();
}

// node_modules/hast-util-whitespace/lib/index.js
var re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
}
function empty(value) {
  return value.replace(re, "") === "";
}

// node_modules/hast-util-to-html/lib/omission/util/siblings.js
var siblingAfter = siblings(1);
var siblingBefore = siblings(-1);
var emptyChildren = [];
function siblings(increment2) {
  return sibling;
  function sibling(parent, index2, includeWhitespace) {
    const siblings2 = parent ? parent.children : emptyChildren;
    let offset = (index2 || 0) + increment2;
    let next = siblings2[offset];
    if (!includeWhitespace) {
      while (next && whitespace(next)) {
        offset += increment2;
        next = siblings2[offset];
      }
    }
    return next;
  }
}

// node_modules/hast-util-to-html/lib/omission/omission.js
var own3 = {}.hasOwnProperty;
function omission(handlers2) {
  return omit;
  function omit(node2, index2, parent) {
    return own3.call(handlers2, node2.tagName) && handlers2[node2.tagName](node2, index2, parent);
  }
}

// node_modules/hast-util-to-html/lib/omission/closing.js
var closing = omission({
  body,
  caption: headOrColgroupOrCaption,
  colgroup: headOrColgroupOrCaption,
  dd,
  dt,
  head: headOrColgroupOrCaption,
  html: html3,
  li,
  optgroup,
  option,
  p,
  rp: rubyElement,
  rt: rubyElement,
  tbody,
  td: cells,
  tfoot,
  th: cells,
  thead,
  tr
});
function headOrColgroupOrCaption(_, index2, parent) {
  const next = siblingAfter(parent, index2, true);
  return !next || next.type !== "comment" && !(next.type === "text" && whitespace(next.value.charAt(0)));
}
function html3(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type !== "comment";
}
function body(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type !== "comment";
}
function p(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return next ? next.type === "element" && (next.tagName === "address" || next.tagName === "article" || next.tagName === "aside" || next.tagName === "blockquote" || next.tagName === "details" || next.tagName === "div" || next.tagName === "dl" || next.tagName === "fieldset" || next.tagName === "figcaption" || next.tagName === "figure" || next.tagName === "footer" || next.tagName === "form" || next.tagName === "h1" || next.tagName === "h2" || next.tagName === "h3" || next.tagName === "h4" || next.tagName === "h5" || next.tagName === "h6" || next.tagName === "header" || next.tagName === "hgroup" || next.tagName === "hr" || next.tagName === "main" || next.tagName === "menu" || next.tagName === "nav" || next.tagName === "ol" || next.tagName === "p" || next.tagName === "pre" || next.tagName === "section" || next.tagName === "table" || next.tagName === "ul") : !parent || // Confusing parent.
  !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
}
function li(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "li";
}
function dt(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return Boolean(
    next && next.type === "element" && (next.tagName === "dt" || next.tagName === "dd")
  );
}
function dd(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
}
function rubyElement(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "rp" || next.tagName === "rt");
}
function optgroup(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "optgroup";
}
function option(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "option" || next.tagName === "optgroup");
}
function thead(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return Boolean(
    next && next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot")
  );
}
function tbody(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
}
function tfoot(_, index2, parent) {
  return !siblingAfter(parent, index2);
}
function tr(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "tr";
}
function cells(_, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "td" || next.tagName === "th");
}

// node_modules/hast-util-to-html/lib/omission/opening.js
var opening = omission({
  body: body2,
  colgroup,
  head,
  html: html4,
  tbody: tbody2
});
function html4(node2) {
  const head2 = siblingAfter(node2, -1);
  return !head2 || head2.type !== "comment";
}
function head(node2) {
  const seen2 = /* @__PURE__ */ new Set();
  for (const child2 of node2.children) {
    if (child2.type === "element" && (child2.tagName === "base" || child2.tagName === "title")) {
      if (seen2.has(child2.tagName)) return false;
      seen2.add(child2.tagName);
    }
  }
  const child = node2.children[0];
  return !child || child.type === "element";
}
function body2(node2) {
  const head2 = siblingAfter(node2, -1, true);
  return !head2 || head2.type !== "comment" && !(head2.type === "text" && whitespace(head2.value.charAt(0))) && !(head2.type === "element" && (head2.tagName === "meta" || head2.tagName === "link" || head2.tagName === "script" || head2.tagName === "style" || head2.tagName === "template"));
}
function colgroup(node2, index2, parent) {
  const previous3 = siblingBefore(parent, index2);
  const head2 = siblingAfter(node2, -1, true);
  if (parent && previous3 && previous3.type === "element" && previous3.tagName === "colgroup" && closing(previous3, parent.children.indexOf(previous3), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "col");
}
function tbody2(node2, index2, parent) {
  const previous3 = siblingBefore(parent, index2);
  const head2 = siblingAfter(node2, -1);
  if (parent && previous3 && previous3.type === "element" && (previous3.tagName === "thead" || previous3.tagName === "tbody") && closing(previous3, parent.children.indexOf(previous3), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "tr");
}

// node_modules/hast-util-to-html/lib/handle/element.js
var constants = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
    [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
    ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function element(node2, index2, parent, state) {
  const schema = state.schema;
  const omit = schema.space === "svg" ? false : state.settings.omitOptionalTags;
  let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node2.tagName.toLowerCase());
  const parts = [];
  let last;
  if (schema.space === "html" && node2.tagName === "svg") {
    state.schema = svg2;
  }
  const attributes = serializeAttributes(state, node2.properties);
  const content3 = state.all(
    schema.space === "html" && node2.tagName === "template" ? node2.content : node2
  );
  state.schema = schema;
  if (content3) selfClosing = false;
  if (attributes || !omit || !opening(node2, index2, parent)) {
    parts.push("<", node2.tagName, attributes ? " " + attributes : "");
    if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
      last = attributes.charAt(attributes.length - 1);
      if (!state.settings.tightSelfClosing || last === "/" || last && last !== '"' && last !== "'") {
        parts.push(" ");
      }
      parts.push("/");
    }
    parts.push(">");
  }
  parts.push(content3);
  if (!selfClosing && (!omit || !closing(node2, index2, parent))) {
    parts.push("</" + node2.tagName + ">");
  }
  return parts.join("");
}
function serializeAttributes(state, properties) {
  const values2 = [];
  let index2 = -1;
  let key2;
  if (properties) {
    for (key2 in properties) {
      if (properties[key2] !== null && properties[key2] !== void 0) {
        const value = serializeAttribute(state, key2, properties[key2]);
        if (value) values2.push(value);
      }
    }
  }
  while (++index2 < values2.length) {
    const last = state.settings.tightAttributes ? values2[index2].charAt(values2[index2].length - 1) : void 0;
    if (index2 !== values2.length - 1 && last !== '"' && last !== "'") {
      values2[index2] += " ";
    }
  }
  return values2.join("");
}
function serializeAttribute(state, key2, value) {
  const info = find(state.schema, key2);
  const x = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
  const y = state.settings.allowDangerousCharacters ? 0 : 1;
  let quote = state.quote;
  let result;
  if (info.overloadedBoolean && (value === info.attribute || value === "")) {
    value = true;
  } else if ((info.boolean || info.overloadedBoolean) && (typeof value !== "string" || value === info.attribute || value === "")) {
    value = Boolean(value);
  }
  if (value === null || value === void 0 || value === false || typeof value === "number" && Number.isNaN(value)) {
    return "";
  }
  const name = stringifyEntities(
    info.attribute,
    Object.assign({}, state.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: constants.name[x][y]
    })
  );
  if (value === true) return name;
  value = Array.isArray(value) ? (info.commaSeparated ? stringify : stringify2)(value, {
    padLeft: !state.settings.tightCommaSeparatedLists
  }) : String(value);
  if (state.settings.collapseEmptyAttributes && !value) return name;
  if (state.settings.preferUnquoted) {
    result = stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        attribute: true,
        subset: constants.unquoted[x][y]
      })
    );
  }
  if (result !== value) {
    if (state.settings.quoteSmart && ccount(value, quote) > ccount(value, state.alternative)) {
      quote = state.alternative;
    }
    result = quote + stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: (quote === "'" ? constants.single : constants.double)[x][y],
        attribute: true
      })
    ) + quote;
  }
  return name + (result ? "=" + result : result);
}

// node_modules/hast-util-to-html/lib/handle/text.js
var textEntitySubset = ["<", "&"];
function text(node2, _, parent, state) {
  return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node2.value : stringifyEntities(
    node2.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: textEntitySubset
    })
  );
}

// node_modules/hast-util-to-html/lib/handle/raw.js
function raw(node2, index2, parent, state) {
  return state.settings.allowDangerousHtml ? node2.value : text(node2, index2, parent, state);
}

// node_modules/hast-util-to-html/lib/handle/root.js
function root(node2, _1, _2, state) {
  return state.all(node2);
}

// node_modules/hast-util-to-html/lib/handle/index.js
var handle = zwitch("type", {
  invalid,
  unknown,
  handlers: { comment, doctype, element, raw, root, text }
});
function invalid(node2) {
  throw new Error("Expected node, not `" + node2 + "`");
}
function unknown(node_) {
  const node2 = (
    /** @type {Nodes} */
    node_
  );
  throw new Error("Cannot compile unknown node `" + node2.type + "`");
}

// node_modules/hast-util-to-html/lib/index.js
var emptyOptions = {};
var emptyCharacterReferences = {};
var emptyChildren2 = [];
function toHtml(tree, options) {
  const options_ = options || emptyOptions;
  const quote = options_.quote || '"';
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error("Invalid quote `" + quote + "`, expected `'` or `\"`");
  }
  const state = {
    one,
    all,
    settings: {
      omitOptionalTags: options_.omitOptionalTags || false,
      allowParseErrors: options_.allowParseErrors || false,
      allowDangerousCharacters: options_.allowDangerousCharacters || false,
      quoteSmart: options_.quoteSmart || false,
      preferUnquoted: options_.preferUnquoted || false,
      tightAttributes: options_.tightAttributes || false,
      upperDoctype: options_.upperDoctype || false,
      tightDoctype: options_.tightDoctype || false,
      bogusComments: options_.bogusComments || false,
      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
      tightSelfClosing: options_.tightSelfClosing || false,
      collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
      allowDangerousHtml: options_.allowDangerousHtml || false,
      voids: options_.voids || htmlVoidElements,
      characterReferences: options_.characterReferences || emptyCharacterReferences,
      closeSelfClosing: options_.closeSelfClosing || false,
      closeEmptyElements: options_.closeEmptyElements || false
    },
    schema: options_.space === "svg" ? svg2 : html2,
    quote,
    alternative
  };
  return state.one(
    Array.isArray(tree) ? { type: "root", children: tree } : tree,
    void 0,
    void 0
  );
}
function one(node2, index2, parent) {
  return handle(node2, index2, parent, this);
}
function all(parent) {
  const results = [];
  const children = parent && parent.children || emptyChildren2;
  let index2 = -1;
  while (++index2 < children.length) {
    results[index2] = this.one(children[index2], index2, parent);
  }
  return results.join("");
}

// node_modules/emoji-regex-xs/index.mjs
var r = String.raw;
var seq = r`(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation})`;
var sTags = r`\u{E0061}-\u{E007A}`;

// node_modules/regex-utilities/src/index.js
var Context = Object.freeze({
  DEFAULT: "DEFAULT",
  CHAR_CLASS: "CHAR_CLASS"
});

// node_modules/regex/src/subclass.js
var emulationGroupMarker = "$E$";

// node_modules/regex/src/utils-internals.js
var noncapturingDelim = String.raw`\(\?(?:[:=!>A-Za-z\-]|<[=!]|\(DEFINE\))`;

// node_modules/regex/src/atomic.js
var atomicPluginToken = new RegExp(String.raw`(?<noncapturingStart>${noncapturingDelim})|(?<capturingStart>\((?:\?<[^>]+>)?)|\\?.`, "gsu");
var baseQuantifier = String.raw`(?:[?*+]|\{\d+(?:,\d*)?\})`;
var possessivePluginToken = new RegExp(String.raw`
\\(?: \d+
  | c[A-Za-z]
  | [gk]<[^>]+>
  | [pPu]\{[^\}]+\}
  | u[A-Fa-f\d]{4}
  | x[A-Fa-f\d]{2}
  )
| \((?: \? (?: [:=!>]
  | <(?:[=!]|[^>]+>)
  | [A-Za-z\-]+:
  | \(DEFINE\)
  ))?
| (?<qBase>${baseQuantifier})(?<qMod>[?+]?)(?<invalidQ>[?*+\{]?)
| \\?.
`.replace(/\s+/g, ""), "gsu");

// node_modules/regex-recursion/src/index.js
var r2 = String.raw;
var gRToken = r2`\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`;
var recursiveToken = r2`\(\?R=(?<rDepth>[^\)]+)\)|${gRToken}`;
var namedCapturingDelim = r2`\(\?<(?![=!])(?<captureName>[^>]+)>`;
var token = new RegExp(r2`${namedCapturingDelim}|${recursiveToken}|\(\?|\\?.`, "gsu");
var emulationGroupMarkerRe = new RegExp(r2`(?:\$[1-9]\d*)?${emulationGroupMarker.replace(/\$/g, r2`\$`)}`, "y");

// node_modules/oniguruma-to-es/dist/esm/index.js
var cp = String.fromCodePoint;
var r3 = String.raw;
var envSupportsFlagGroups = (() => {
  try {
    new RegExp("(?i:)");
  } catch {
    return false;
  }
  return true;
})();
var envSupportsFlagV = (() => {
  try {
    new RegExp("", "v");
  } catch {
    return false;
  }
  return true;
})();
var CharsWithoutIgnoreCaseExpansion = /* @__PURE__ */ new Set([
  cp(304),
  // İ
  cp(305)
  // ı
]);
var JsUnicodeProperties = new Set(
  `C Other
Cc Control cntrl
Cf Format
Cn Unassigned
Co Private_Use
Cs Surrogate
L Letter
LC Cased_Letter
Ll Lowercase_Letter
Lm Modifier_Letter
Lo Other_Letter
Lt Titlecase_Letter
Lu Uppercase_Letter
M Mark Combining_Mark
Mc Spacing_Mark
Me Enclosing_Mark
Mn Nonspacing_Mark
N Number
Nd Decimal_Number digit
Nl Letter_Number
No Other_Number
P Punctuation punct
Pc Connector_Punctuation
Pd Dash_Punctuation
Pe Close_Punctuation
Pf Final_Punctuation
Pi Initial_Punctuation
Po Other_Punctuation
Ps Open_Punctuation
S Symbol
Sc Currency_Symbol
Sk Modifier_Symbol
Sm Math_Symbol
So Other_Symbol
Z Separator
Zl Line_Separator
Zp Paragraph_Separator
Zs Space_Separator
ASCII
ASCII_Hex_Digit AHex
Alphabetic Alpha
Any
Assigned
Bidi_Control Bidi_C
Bidi_Mirrored Bidi_M
Case_Ignorable CI
Cased
Changes_When_Casefolded CWCF
Changes_When_Casemapped CWCM
Changes_When_Lowercased CWL
Changes_When_NFKC_Casefolded CWKCF
Changes_When_Titlecased CWT
Changes_When_Uppercased CWU
Dash
Default_Ignorable_Code_Point DI
Deprecated Dep
Diacritic Dia
Emoji
Emoji_Component EComp
Emoji_Modifier EMod
Emoji_Modifier_Base EBase
Emoji_Presentation EPres
Extended_Pictographic ExtPict
Extender Ext
Grapheme_Base Gr_Base
Grapheme_Extend Gr_Ext
Hex_Digit Hex
IDS_Binary_Operator IDSB
IDS_Trinary_Operator IDST
ID_Continue IDC
ID_Start IDS
Ideographic Ideo
Join_Control Join_C
Logical_Order_Exception LOE
Lowercase Lower
Math
Noncharacter_Code_Point NChar
Pattern_Syntax Pat_Syn
Pattern_White_Space Pat_WS
Quotation_Mark QMark
Radical
Regional_Indicator RI
Sentence_Terminal STerm
Soft_Dotted SD
Terminal_Punctuation Term
Unified_Ideograph UIdeo
Uppercase Upper
Variation_Selector VS
White_Space space
XID_Continue XIDC
XID_Start XIDS`.split(/\s/)
);
var JsUnicodePropertiesMap = /* @__PURE__ */ new Map();
for (const p2 of JsUnicodeProperties) {
  JsUnicodePropertiesMap.set(slug(p2), p2);
}
var JsUnicodePropertiesOfStrings = /* @__PURE__ */ new Set([
  // ES2024 properties of strings; none are supported by Oniguruma
  "Basic_Emoji",
  "Emoji_Keycap_Sequence",
  "RGI_Emoji",
  "RGI_Emoji_Flag_Sequence",
  "RGI_Emoji_Modifier_Sequence",
  "RGI_Emoji_Tag_Sequence",
  "RGI_Emoji_ZWJ_Sequence"
]);
var JsUnicodePropertiesOfStringsMap = /* @__PURE__ */ new Map();
for (const p2 of JsUnicodePropertiesOfStrings) {
  JsUnicodePropertiesOfStringsMap.set(slug(p2), p2);
}
var LowerToAlternativeLowerCaseMap = /* @__PURE__ */ new Map([
  ["s", cp(383)],
  // s, ſ
  [cp(383), "s"]
  // ſ, s
]);
var LowerToAlternativeUpperCaseMap = /* @__PURE__ */ new Map([
  [cp(223), cp(7838)],
  // ß, ẞ
  [cp(107), cp(8490)],
  // k, K (Kelvin)
  [cp(229), cp(8491)],
  // å, Å (Angstrom)
  [cp(969), cp(8486)]
  // ω, Ω (Ohm)
]);
var LowerToTitleCaseMap = new Map([
  titleEntry(453),
  titleEntry(456),
  titleEntry(459),
  titleEntry(498),
  ...titleRange(8072, 8079),
  ...titleRange(8088, 8095),
  ...titleRange(8104, 8111),
  titleEntry(8124),
  titleEntry(8140),
  titleEntry(8188)
]);
var PosixClassesMap = /* @__PURE__ */ new Map([
  ["alnum", r3`[\p{Alpha}\p{Nd}]`],
  ["alpha", r3`\p{Alpha}`],
  ["ascii", r3`\p{ASCII}`],
  ["blank", r3`[\p{Zs}\t]`],
  ["cntrl", r3`\p{cntrl}`],
  ["digit", r3`\p{Nd}`],
  ["graph", r3`[\P{space}&&\P{cntrl}&&\P{Cn}&&\P{Cs}]`],
  ["lower", r3`\p{Lower}`],
  ["print", r3`[[\P{space}&&\P{cntrl}&&\P{Cn}&&\P{Cs}]\p{Zs}]`],
  ["punct", r3`[\p{P}\p{S}]`],
  // New value from Oniguruma 6.9.9
  ["space", r3`\p{space}`],
  ["upper", r3`\p{Upper}`],
  ["word", r3`[\p{Alpha}\p{M}\p{Nd}\p{Pc}]`],
  ["xdigit", r3`\p{AHex}`]
]);
function range(start, end) {
  const range22 = [];
  for (let i = start; i <= end; i++) {
    range22.push(i);
  }
  return range22;
}
function slug(name) {
  return name.replace(/[- _]+/g, "").toLowerCase();
}
function titleEntry(codePoint) {
  const char = cp(codePoint);
  return [char.toLowerCase(), char];
}
function titleRange(start, end) {
  return range(start, end).map((codePoint) => titleEntry(codePoint));
}
var charClassOpenPattern = r3`\[\^?`;
var sharedEscapesPattern = `${// Control char
"c.? | C(?:-.?)?"}|${// Unicode property; Onig considers `\p` an identity escape, but e.g. `\p{`, `\p{ ^L}`, and
// `\p{gc=L}` are invalid
r3`[pP]\{(?:\^?[-\x20_]*[A-Za-z][-\x20\w]*\})?`}|${// Hex encoded byte sequence; attempt match before other `\xNN` hex char
r3`x[89A-Fa-f]\p{AHex}(?:\\x[89A-Fa-f]\p{AHex})*`}|${// Hex char
r3`u(?:\p{AHex}{4})? | x\{[^\}]*\}? | x\p{AHex}{0,2}`}|${// Enclosed octal code point
r3`o\{[^\}]*\}?`}|${// Escaped number
r3`\d{1,3}`}`;
var quantifierRe = /[?*+][?+]?|\{(?:\d+(?:,\d*)?|,\d+)\}\??/;
var tokenRe = new RegExp(r3`
  \\ (?:
    ${sharedEscapesPattern}
    | [gk]<[^>]*>?
    | [gk]'[^']*'?
    | .
  )
  | \( (?: \? (?:
    [:=!>(]
    | <[=!]
    | <[^>]*>
    | '[^']*'
    | ~\|?
    | # (?:[^)\\] | \\.?)*
    | [imx\-]+[:)]
  )?)?
  | ${quantifierRe.source}
  | ${charClassOpenPattern}
  | .
`.replace(/\s+/g, ""), "gsu");
var charClassTokenRe = new RegExp(r3`
  \\ (?:
    ${sharedEscapesPattern}
    | .
  )
  | \[:[^:]*:\]
  | ${charClassOpenPattern}
  | &&
  | .
`.replace(/\s+/g, ""), "gsu");
var defaultWordChar = r3`[\p{L}\p{M}\p{N}\p{Pc}]`;
var CharCodeEscapeMap = /* @__PURE__ */ new Map([
  [9, r3`\t`],
  // horizontal tab
  [10, r3`\n`],
  // line feed
  [11, r3`\v`],
  // vertical tab
  [12, r3`\f`],
  // form feed
  [13, r3`\r`],
  // carriage return
  [8232, r3`\u2028`],
  // line separator
  [8233, r3`\u2029`],
  // paragraph separator
  [65279, r3`\uFEFF`]
  // ZWNBSP/BOM
]);
var casedRe = new RegExp("^\\p{Cased}$", "u");

// node_modules/@shikijs/core/dist/index.mjs
function toArray(x) {
  return Array.isArray(x) ? x : [x];
}
function splitLines(code3, preserveEnding = false) {
  var _a;
  const parts = code3.split(/(\r?\n)/g);
  let index2 = 0;
  const lines = [];
  for (let i = 0; i < parts.length; i += 2) {
    const line = preserveEnding ? parts[i] + (parts[i + 1] || "") : parts[i];
    lines.push([line, index2]);
    index2 += parts[i].length;
    index2 += ((_a = parts[i + 1]) == null ? void 0 : _a.length) || 0;
  }
  return lines;
}
function isPlainLang(lang) {
  return !lang || ["plaintext", "txt", "text", "plain"].includes(lang);
}
function isSpecialLang(lang) {
  return lang === "ansi" || isPlainLang(lang);
}
function isNoneTheme(theme) {
  return theme === "none";
}
function isSpecialTheme(theme) {
  return isNoneTheme(theme);
}
function addClassToHast(node2, className) {
  var _a;
  if (!className)
    return node2;
  node2.properties || (node2.properties = {});
  (_a = node2.properties).class || (_a.class = []);
  if (typeof node2.properties.class === "string")
    node2.properties.class = node2.properties.class.split(/\s+/g);
  if (!Array.isArray(node2.properties.class))
    node2.properties.class = [];
  const targets = Array.isArray(className) ? className : className.split(/\s+/g);
  for (const c of targets) {
    if (c && !node2.properties.class.includes(c))
      node2.properties.class.push(c);
  }
  return node2;
}
function splitToken(token2, offsets) {
  let lastOffset = 0;
  const tokens = [];
  for (const offset of offsets) {
    if (offset > lastOffset) {
      tokens.push({
        ...token2,
        content: token2.content.slice(lastOffset, offset),
        offset: token2.offset + lastOffset
      });
    }
    lastOffset = offset;
  }
  if (lastOffset < token2.content.length) {
    tokens.push({
      ...token2,
      content: token2.content.slice(lastOffset),
      offset: token2.offset + lastOffset
    });
  }
  return tokens;
}
function splitTokens(tokens, breakpoints) {
  const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b) => a - b);
  if (!sorted.length)
    return tokens;
  return tokens.map((line) => {
    return line.flatMap((token2) => {
      const breakpointsInToken = sorted.filter((i) => token2.offset < i && i < token2.offset + token2.content.length).map((i) => i - token2.offset).sort((a, b) => a - b);
      if (!breakpointsInToken.length)
        return token2;
      return splitToken(token2, breakpointsInToken);
    });
  });
}
async function normalizeGetter(p2) {
  return Promise.resolve(typeof p2 === "function" ? p2() : p2).then((r4) => r4.default || r4);
}
function resolveColorReplacements(theme, options) {
  const replacements = typeof theme === "string" ? {} : { ...theme.colorReplacements };
  const themeName = typeof theme === "string" ? theme : theme.name;
  for (const [key2, value] of Object.entries((options == null ? void 0 : options.colorReplacements) || {})) {
    if (typeof value === "string")
      replacements[key2] = value;
    else if (key2 === themeName)
      Object.assign(replacements, value);
  }
  return replacements;
}
function applyColorReplacements(color2, replacements) {
  if (!color2)
    return color2;
  return (replacements == null ? void 0 : replacements[color2 == null ? void 0 : color2.toLowerCase()]) || color2;
}
function getTokenStyleObject(token2) {
  const styles = {};
  if (token2.color)
    styles.color = token2.color;
  if (token2.bgColor)
    styles["background-color"] = token2.bgColor;
  if (token2.fontStyle) {
    if (token2.fontStyle & FontStyle.Italic)
      styles["font-style"] = "italic";
    if (token2.fontStyle & FontStyle.Bold)
      styles["font-weight"] = "bold";
    if (token2.fontStyle & FontStyle.Underline)
      styles["text-decoration"] = "underline";
  }
  return styles;
}
function stringifyTokenStyle(token2) {
  if (typeof token2 === "string")
    return token2;
  return Object.entries(token2).map(([key2, value]) => `${key2}:${value}`).join(";");
}
function createPositionConverter(code3) {
  const lines = splitLines(code3, true).map(([line]) => line);
  function indexToPos(index2) {
    if (index2 === code3.length) {
      return {
        line: lines.length - 1,
        character: lines[lines.length - 1].length
      };
    }
    let character = index2;
    let line = 0;
    for (const lineText of lines) {
      if (character < lineText.length)
        break;
      character -= lineText.length;
      line++;
    }
    return { line, character };
  }
  function posToIndex(line, character) {
    let index2 = 0;
    for (let i = 0; i < line; i++)
      index2 += lines[i].length;
    index2 += character;
    return index2;
  }
  return {
    lines,
    indexToPos,
    posToIndex
  };
}
var ShikiError3 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ShikiError";
  }
};
var _grammarStateMap = /* @__PURE__ */ new WeakMap();
function setLastGrammarStateToMap(keys2, state) {
  _grammarStateMap.set(keys2, state);
}
function getLastGrammarStateFromMap(keys2) {
  return _grammarStateMap.get(keys2);
}
var GrammarState = class _GrammarState {
  constructor(...args) {
    /**
     * Theme to Stack mapping
     */
    __publicField(this, "_stacks", {});
    __publicField(this, "lang");
    if (args.length === 2) {
      const [stacksMap, lang] = args;
      this.lang = lang;
      this._stacks = stacksMap;
    } else {
      const [stack2, lang, theme] = args;
      this.lang = lang;
      this._stacks = { [theme]: stack2 };
    }
  }
  get themes() {
    return Object.keys(this._stacks);
  }
  get theme() {
    return this.themes[0];
  }
  get _stack() {
    return this._stacks[this.theme];
  }
  /**
   * Static method to create a initial grammar state.
   */
  static initial(lang, themes) {
    return new _GrammarState(
      Object.fromEntries(toArray(themes).map((theme) => [theme, INITIAL])),
      lang
    );
  }
  /**
   * Get the internal stack object.
   * @internal
   */
  getInternalStack(theme = this.theme) {
    return this._stacks[theme];
  }
  /**
   * @deprecated use `getScopes` instead
   */
  get scopes() {
    warnDeprecated("GrammarState.scopes is deprecated, use GrammarState.getScopes() instead");
    return getScopes(this._stacks[this.theme]);
  }
  getScopes(theme = this.theme) {
    return getScopes(this._stacks[theme]);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      themes: this.themes,
      scopes: this.scopes
    };
  }
};
function getScopes(stack2) {
  const scopes = [];
  const visited = /* @__PURE__ */ new Set();
  function pushScope(stack22) {
    var _a;
    if (visited.has(stack22))
      return;
    visited.add(stack22);
    const name = (_a = stack22 == null ? void 0 : stack22.nameScopesList) == null ? void 0 : _a.scopeName;
    if (name)
      scopes.push(name);
    if (stack22.parent)
      pushScope(stack22.parent);
  }
  pushScope(stack2);
  return scopes;
}
function getGrammarStack(state, theme) {
  if (!(state instanceof GrammarState))
    throw new ShikiError3("Invalid grammar state");
  return state.getInternalStack(theme);
}
function transformerDecorations() {
  const map = /* @__PURE__ */ new WeakMap();
  function getContext(shiki) {
    if (!map.has(shiki.meta)) {
      let normalizePosition = function(p2) {
        if (typeof p2 === "number") {
          if (p2 < 0 || p2 > shiki.source.length)
            throw new ShikiError3(`Invalid decoration offset: ${p2}. Code length: ${shiki.source.length}`);
          return {
            ...converter.indexToPos(p2),
            offset: p2
          };
        } else {
          const line = converter.lines[p2.line];
          if (line === void 0)
            throw new ShikiError3(`Invalid decoration position ${JSON.stringify(p2)}. Lines length: ${converter.lines.length}`);
          if (p2.character < 0 || p2.character > line.length)
            throw new ShikiError3(`Invalid decoration position ${JSON.stringify(p2)}. Line ${p2.line} length: ${line.length}`);
          return {
            ...p2,
            offset: converter.posToIndex(p2.line, p2.character)
          };
        }
      };
      const converter = createPositionConverter(shiki.source);
      const decorations2 = (shiki.options.decorations || []).map((d) => ({
        ...d,
        start: normalizePosition(d.start),
        end: normalizePosition(d.end)
      }));
      verifyIntersections(decorations2);
      map.set(shiki.meta, {
        decorations: decorations2,
        converter,
        source: shiki.source
      });
    }
    return map.get(shiki.meta);
  }
  return {
    name: "shiki:decorations",
    tokens(tokens) {
      var _a;
      if (!((_a = this.options.decorations) == null ? void 0 : _a.length))
        return;
      const ctx = getContext(this);
      const breakpoints = ctx.decorations.flatMap((d) => [d.start.offset, d.end.offset]);
      const splitted = splitTokens(tokens, breakpoints);
      return splitted;
    },
    code(codeEl) {
      var _a;
      if (!((_a = this.options.decorations) == null ? void 0 : _a.length))
        return;
      const ctx = getContext(this);
      const lines = Array.from(codeEl.children).filter((i) => i.type === "element" && i.tagName === "span");
      if (lines.length !== ctx.converter.lines.length)
        throw new ShikiError3(`Number of lines in code element (${lines.length}) does not match the number of lines in the source (${ctx.converter.lines.length}). Failed to apply decorations.`);
      function applyLineSection(line, start, end, decoration) {
        const lineEl = lines[line];
        let text6 = "";
        let startIndex = -1;
        let endIndex = -1;
        if (start === 0)
          startIndex = 0;
        if (end === 0)
          endIndex = 0;
        if (end === Number.POSITIVE_INFINITY)
          endIndex = lineEl.children.length;
        if (startIndex === -1 || endIndex === -1) {
          for (let i = 0; i < lineEl.children.length; i++) {
            text6 += stringify3(lineEl.children[i]);
            if (startIndex === -1 && text6.length === start)
              startIndex = i + 1;
            if (endIndex === -1 && text6.length === end)
              endIndex = i + 1;
          }
        }
        if (startIndex === -1)
          throw new ShikiError3(`Failed to find start index for decoration ${JSON.stringify(decoration.start)}`);
        if (endIndex === -1)
          throw new ShikiError3(`Failed to find end index for decoration ${JSON.stringify(decoration.end)}`);
        const children = lineEl.children.slice(startIndex, endIndex);
        if (!decoration.alwaysWrap && children.length === lineEl.children.length) {
          applyDecoration(lineEl, decoration, "line");
        } else if (!decoration.alwaysWrap && children.length === 1 && children[0].type === "element") {
          applyDecoration(children[0], decoration, "token");
        } else {
          const wrapper = {
            type: "element",
            tagName: "span",
            properties: {},
            children
          };
          applyDecoration(wrapper, decoration, "wrapper");
          lineEl.children.splice(startIndex, children.length, wrapper);
        }
      }
      function applyLine(line, decoration) {
        lines[line] = applyDecoration(lines[line], decoration, "line");
      }
      function applyDecoration(el, decoration, type) {
        var _a2;
        const properties = decoration.properties || {};
        const transform2 = decoration.transform || ((i) => i);
        el.tagName = decoration.tagName || "span";
        el.properties = {
          ...el.properties,
          ...properties,
          class: el.properties.class
        };
        if ((_a2 = decoration.properties) == null ? void 0 : _a2.class)
          addClassToHast(el, decoration.properties.class);
        el = transform2(el, type) || el;
        return el;
      }
      const lineApplies = [];
      const sorted = ctx.decorations.sort((a, b) => b.start.offset - a.start.offset);
      for (const decoration of sorted) {
        const { start, end } = decoration;
        if (start.line === end.line) {
          applyLineSection(start.line, start.character, end.character, decoration);
        } else if (start.line < end.line) {
          applyLineSection(start.line, start.character, Number.POSITIVE_INFINITY, decoration);
          for (let i = start.line + 1; i < end.line; i++)
            lineApplies.unshift(() => applyLine(i, decoration));
          applyLineSection(end.line, 0, end.character, decoration);
        }
      }
      lineApplies.forEach((i) => i());
    }
  };
}
function verifyIntersections(items) {
  for (let i = 0; i < items.length; i++) {
    const foo = items[i];
    if (foo.start.offset > foo.end.offset)
      throw new ShikiError3(`Invalid decoration range: ${JSON.stringify(foo.start)} - ${JSON.stringify(foo.end)}`);
    for (let j = i + 1; j < items.length; j++) {
      const bar = items[j];
      const isFooHasBarStart = foo.start.offset < bar.start.offset && bar.start.offset < foo.end.offset;
      const isFooHasBarEnd = foo.start.offset < bar.end.offset && bar.end.offset < foo.end.offset;
      const isBarHasFooStart = bar.start.offset < foo.start.offset && foo.start.offset < bar.end.offset;
      const isBarHasFooEnd = bar.start.offset < foo.end.offset && foo.end.offset < bar.end.offset;
      if (isFooHasBarStart || isFooHasBarEnd || isBarHasFooStart || isBarHasFooEnd) {
        if (isFooHasBarEnd && isFooHasBarEnd)
          continue;
        if (isBarHasFooStart && isBarHasFooEnd)
          continue;
        throw new ShikiError3(`Decorations ${JSON.stringify(foo.start)} and ${JSON.stringify(bar.start)} intersect.`);
      }
    }
  }
}
function stringify3(el) {
  if (el.type === "text")
    return el.value;
  if (el.type === "element")
    return el.children.map(stringify3).join("");
  return "";
}
var builtInTransformers = [
  transformerDecorations()
];
function getTransformers(options) {
  return [
    ...options.transformers || [],
    ...builtInTransformers
  ];
}
var namedColors = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
];
var decorations = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  9: "strikethrough"
};
function findSequence(value, position3) {
  const nextEscape = value.indexOf("\x1B[", position3);
  if (nextEscape !== -1) {
    const nextClose = value.indexOf("m", nextEscape);
    return {
      sequence: value.substring(nextEscape + 2, nextClose).split(";"),
      startPosition: nextEscape,
      position: nextClose + 1
    };
  }
  return {
    position: value.length
  };
}
function parseColor(sequence, index2) {
  let offset = 1;
  const colorMode = sequence[index2 + offset++];
  let color2;
  if (colorMode === "2") {
    const rgb = [
      sequence[index2 + offset++],
      sequence[index2 + offset++],
      sequence[index2 + offset]
    ].map((x) => Number.parseInt(x));
    if (rgb.length === 3 && !rgb.some((x) => Number.isNaN(x))) {
      color2 = {
        type: "rgb",
        rgb
      };
    }
  } else if (colorMode === "5") {
    const colorIndex = Number.parseInt(sequence[index2 + offset]);
    if (!Number.isNaN(colorIndex)) {
      color2 = { type: "table", index: Number(colorIndex) };
    }
  }
  return [offset, color2];
}
function parseSequence(sequence) {
  const commands = [];
  for (let i = 0; i < sequence.length; i++) {
    const code3 = sequence[i];
    const codeInt = Number.parseInt(code3);
    if (Number.isNaN(codeInt))
      continue;
    if (codeInt === 0) {
      commands.push({ type: "resetAll" });
    } else if (codeInt <= 9) {
      const decoration = decorations[codeInt];
      if (decoration) {
        commands.push({
          type: "setDecoration",
          value: decorations[codeInt]
        });
      }
    } else if (codeInt <= 29) {
      const decoration = decorations[codeInt - 20];
      if (decoration) {
        commands.push({
          type: "resetDecoration",
          value: decoration
        });
      }
    } else if (codeInt <= 37) {
      commands.push({
        type: "setForegroundColor",
        value: { type: "named", name: namedColors[codeInt - 30] }
      });
    } else if (codeInt === 38) {
      const [offset, color2] = parseColor(sequence, i);
      if (color2) {
        commands.push({
          type: "setForegroundColor",
          value: color2
        });
      }
      i += offset;
    } else if (codeInt === 39) {
      commands.push({
        type: "resetForegroundColor"
      });
    } else if (codeInt <= 47) {
      commands.push({
        type: "setBackgroundColor",
        value: { type: "named", name: namedColors[codeInt - 40] }
      });
    } else if (codeInt === 48) {
      const [offset, color2] = parseColor(sequence, i);
      if (color2) {
        commands.push({
          type: "setBackgroundColor",
          value: color2
        });
      }
      i += offset;
    } else if (codeInt === 49) {
      commands.push({
        type: "resetBackgroundColor"
      });
    } else if (codeInt >= 90 && codeInt <= 97) {
      commands.push({
        type: "setForegroundColor",
        value: { type: "named", name: namedColors[codeInt - 90 + 8] }
      });
    } else if (codeInt >= 100 && codeInt <= 107) {
      commands.push({
        type: "setBackgroundColor",
        value: { type: "named", name: namedColors[codeInt - 100 + 8] }
      });
    }
  }
  return commands;
}
function createAnsiSequenceParser() {
  let foreground = null;
  let background = null;
  let decorations2 = /* @__PURE__ */ new Set();
  return {
    parse(value) {
      const tokens = [];
      let position3 = 0;
      do {
        const findResult = findSequence(value, position3);
        const text6 = findResult.sequence ? value.substring(position3, findResult.startPosition) : value.substring(position3);
        if (text6.length > 0) {
          tokens.push({
            value: text6,
            foreground,
            background,
            decorations: new Set(decorations2)
          });
        }
        if (findResult.sequence) {
          const commands = parseSequence(findResult.sequence);
          for (const styleToken of commands) {
            if (styleToken.type === "resetAll") {
              foreground = null;
              background = null;
              decorations2.clear();
            } else if (styleToken.type === "resetForegroundColor") {
              foreground = null;
            } else if (styleToken.type === "resetBackgroundColor") {
              background = null;
            } else if (styleToken.type === "resetDecoration") {
              decorations2.delete(styleToken.value);
            }
          }
          for (const styleToken of commands) {
            if (styleToken.type === "setForegroundColor") {
              foreground = styleToken.value;
            } else if (styleToken.type === "setBackgroundColor") {
              background = styleToken.value;
            } else if (styleToken.type === "setDecoration") {
              decorations2.add(styleToken.value);
            }
          }
        }
        position3 = findResult.position;
      } while (position3 < value.length);
      return tokens;
    }
  };
}
var defaultNamedColorsMap = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function createColorPalette(namedColorsMap = defaultNamedColorsMap) {
  function namedColor(name) {
    return namedColorsMap[name];
  }
  function rgbColor(rgb) {
    return `#${rgb.map((x) => Math.max(0, Math.min(x, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let colorTable;
  function getColorTable() {
    if (colorTable) {
      return colorTable;
    }
    colorTable = [];
    for (let i = 0; i < namedColors.length; i++) {
      colorTable.push(namedColor(namedColors[i]));
    }
    let levels = [0, 95, 135, 175, 215, 255];
    for (let r4 = 0; r4 < 6; r4++) {
      for (let g = 0; g < 6; g++) {
        for (let b = 0; b < 6; b++) {
          colorTable.push(rgbColor([levels[r4], levels[g], levels[b]]));
        }
      }
    }
    let level = 8;
    for (let i = 0; i < 24; i++, level += 10) {
      colorTable.push(rgbColor([level, level, level]));
    }
    return colorTable;
  }
  function tableColor(index2) {
    return getColorTable()[index2];
  }
  function value(color2) {
    switch (color2.type) {
      case "named":
        return namedColor(color2.name);
      case "rgb":
        return rgbColor(color2.rgb);
      case "table":
        return tableColor(color2.index);
    }
  }
  return {
    value
  };
}
function tokenizeAnsiWithTheme(theme, fileContents, options) {
  const colorReplacements = resolveColorReplacements(theme, options);
  const lines = splitLines(fileContents);
  const colorPalette = createColorPalette(
    Object.fromEntries(
      namedColors.map((name) => {
        var _a;
        return [
          name,
          (_a = theme.colors) == null ? void 0 : _a[`terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`]
        ];
      })
    )
  );
  const parser = createAnsiSequenceParser();
  return lines.map(
    (line) => parser.parse(line[0]).map((token2) => {
      let color2;
      let bgColor;
      if (token2.decorations.has("reverse")) {
        color2 = token2.background ? colorPalette.value(token2.background) : theme.bg;
        bgColor = token2.foreground ? colorPalette.value(token2.foreground) : theme.fg;
      } else {
        color2 = token2.foreground ? colorPalette.value(token2.foreground) : theme.fg;
        bgColor = token2.background ? colorPalette.value(token2.background) : void 0;
      }
      color2 = applyColorReplacements(color2, colorReplacements);
      bgColor = applyColorReplacements(bgColor, colorReplacements);
      if (token2.decorations.has("dim"))
        color2 = dimColor(color2);
      let fontStyle = FontStyle.None;
      if (token2.decorations.has("bold"))
        fontStyle |= FontStyle.Bold;
      if (token2.decorations.has("italic"))
        fontStyle |= FontStyle.Italic;
      if (token2.decorations.has("underline"))
        fontStyle |= FontStyle.Underline;
      return {
        content: token2.value,
        offset: line[1],
        // TODO: more accurate offset? might need to fork ansi-sequence-parser
        color: color2,
        bgColor,
        fontStyle
      };
    })
  );
}
function dimColor(color2) {
  const hexMatch = color2.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (hexMatch) {
    if (hexMatch[3]) {
      const alpha = Math.round(Number.parseInt(hexMatch[3], 16) / 2).toString(16).padStart(2, "0");
      return `#${hexMatch[1]}${hexMatch[2]}${alpha}`;
    } else if (hexMatch[2]) {
      return `#${hexMatch[1]}${hexMatch[2]}80`;
    } else {
      return `#${Array.from(hexMatch[1]).map((x) => `${x}${x}`).join("")}80`;
    }
  }
  const cssVarMatch = color2.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  if (cssVarMatch)
    return `var(${cssVarMatch[1]}-dim)`;
  return color2;
}
function codeToTokensBase(internal, code3, options = {}) {
  const {
    lang = "text",
    theme: themeName = internal.getLoadedThemes()[0]
  } = options;
  if (isPlainLang(lang) || isNoneTheme(themeName))
    return splitLines(code3).map((line) => [{ content: line[0], offset: line[1] }]);
  const { theme, colorMap } = internal.setTheme(themeName);
  if (lang === "ansi")
    return tokenizeAnsiWithTheme(theme, code3, options);
  const _grammar = internal.getLanguage(lang);
  if (options.grammarState) {
    if (options.grammarState.lang !== _grammar.name) {
      throw new ShikiError(`Grammar state language "${options.grammarState.lang}" does not match highlight language "${_grammar.name}"`);
    }
    if (!options.grammarState.themes.includes(theme.name)) {
      throw new ShikiError(`Grammar state themes "${options.grammarState.themes}" do not contain highlight theme "${theme.name}"`);
    }
  }
  return tokenizeWithTheme(code3, _grammar, theme, colorMap, options);
}
function getLastGrammarState(...args) {
  if (args.length === 2) {
    return getLastGrammarStateFromMap(args[1]);
  }
  const [internal, code3, options = {}] = args;
  const {
    lang = "text",
    theme: themeName = internal.getLoadedThemes()[0]
  } = options;
  if (isPlainLang(lang) || isNoneTheme(themeName))
    throw new ShikiError("Plain language does not have grammar state");
  if (lang === "ansi")
    throw new ShikiError("ANSI language does not have grammar state");
  const { theme, colorMap } = internal.setTheme(themeName);
  const _grammar = internal.getLanguage(lang);
  return new GrammarState(
    _tokenizeWithTheme(code3, _grammar, theme, colorMap, options).stateStack,
    _grammar.name,
    theme.name
  );
}
function tokenizeWithTheme(code3, grammar, theme, colorMap, options) {
  const result = _tokenizeWithTheme(code3, grammar, theme, colorMap, options);
  const grammarState = new GrammarState(
    _tokenizeWithTheme(code3, grammar, theme, colorMap, options).stateStack,
    grammar.name,
    theme.name
  );
  setLastGrammarStateToMap(result.tokens, grammarState);
  return result.tokens;
}
function _tokenizeWithTheme(code3, grammar, theme, colorMap, options) {
  const colorReplacements = resolveColorReplacements(theme, options);
  const {
    tokenizeMaxLineLength = 0,
    tokenizeTimeLimit = 500
  } = options;
  const lines = splitLines(code3);
  let stateStack = options.grammarState ? getGrammarStack(options.grammarState, theme.name) ?? INITIAL : options.grammarContextCode != null ? _tokenizeWithTheme(
    options.grammarContextCode,
    grammar,
    theme,
    colorMap,
    {
      ...options,
      grammarState: void 0,
      grammarContextCode: void 0
    }
  ).stateStack : INITIAL;
  let actual = [];
  const final = [];
  for (let i = 0, len = lines.length; i < len; i++) {
    const [line, lineOffset] = lines[i];
    if (line === "") {
      actual = [];
      final.push([]);
      continue;
    }
    if (tokenizeMaxLineLength > 0 && line.length >= tokenizeMaxLineLength) {
      actual = [];
      final.push([{
        content: line,
        offset: lineOffset,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let resultWithScopes;
    let tokensWithScopes;
    let tokensWithScopesIndex;
    if (options.includeExplanation) {
      resultWithScopes = grammar.tokenizeLine(line, stateStack);
      tokensWithScopes = resultWithScopes.tokens;
      tokensWithScopesIndex = 0;
    }
    const result = grammar.tokenizeLine2(line, stateStack, tokenizeTimeLimit);
    const tokensLength = result.tokens.length / 2;
    for (let j = 0; j < tokensLength; j++) {
      const startIndex = result.tokens[2 * j];
      const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;
      if (startIndex === nextStartIndex)
        continue;
      const metadata = result.tokens[2 * j + 1];
      const color2 = applyColorReplacements(
        colorMap[EncodedTokenMetadata.getForeground(metadata)],
        colorReplacements
      );
      const fontStyle = EncodedTokenMetadata.getFontStyle(metadata);
      const token2 = {
        content: line.substring(startIndex, nextStartIndex),
        offset: lineOffset + startIndex,
        color: color2,
        fontStyle
      };
      if (options.includeExplanation) {
        const themeSettingsSelectors = [];
        if (options.includeExplanation !== "scopeName") {
          for (const setting of theme.settings) {
            let selectors;
            switch (typeof setting.scope) {
              case "string":
                selectors = setting.scope.split(/,/).map((scope) => scope.trim());
                break;
              case "object":
                selectors = setting.scope;
                break;
              default:
                continue;
            }
            themeSettingsSelectors.push({
              settings: setting,
              selectors: selectors.map((selector) => selector.split(/ /))
            });
          }
        }
        token2.explanation = [];
        let offset = 0;
        while (startIndex + offset < nextStartIndex) {
          const tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];
          const tokenWithScopesText = line.substring(
            tokenWithScopes.startIndex,
            tokenWithScopes.endIndex
          );
          offset += tokenWithScopesText.length;
          token2.explanation.push({
            content: tokenWithScopesText,
            scopes: options.includeExplanation === "scopeName" ? explainThemeScopesNameOnly(
              tokenWithScopes.scopes
            ) : explainThemeScopesFull(
              themeSettingsSelectors,
              tokenWithScopes.scopes
            )
          });
          tokensWithScopesIndex += 1;
        }
      }
      actual.push(token2);
    }
    final.push(actual);
    actual = [];
    stateStack = result.ruleStack;
  }
  return {
    tokens: final,
    stateStack
  };
}
function explainThemeScopesNameOnly(scopes) {
  return scopes.map((scope) => ({ scopeName: scope }));
}
function explainThemeScopesFull(themeSelectors, scopes) {
  const result = [];
  for (let i = 0, len = scopes.length; i < len; i++) {
    const scope = scopes[i];
    result[i] = {
      scopeName: scope,
      themeMatches: explainThemeScope(themeSelectors, scope, scopes.slice(0, i))
    };
  }
  return result;
}
function matchesOne(selector, scope) {
  return selector === scope || scope.substring(0, selector.length) === selector && scope[selector.length] === ".";
}
function matches(selectors, scope, parentScopes) {
  if (!matchesOne(selectors[selectors.length - 1], scope))
    return false;
  let selectorParentIndex = selectors.length - 2;
  let parentIndex = parentScopes.length - 1;
  while (selectorParentIndex >= 0 && parentIndex >= 0) {
    if (matchesOne(selectors[selectorParentIndex], parentScopes[parentIndex]))
      selectorParentIndex -= 1;
    parentIndex -= 1;
  }
  if (selectorParentIndex === -1)
    return true;
  return false;
}
function explainThemeScope(themeSettingsSelectors, scope, parentScopes) {
  const result = [];
  for (const { selectors, settings } of themeSettingsSelectors) {
    for (const selectorPieces of selectors) {
      if (matches(selectorPieces, scope, parentScopes)) {
        result.push(settings);
        break;
      }
    }
  }
  return result;
}
function codeToTokensWithThemes(internal, code3, options) {
  const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] }));
  const themedTokens = themes.map((t) => {
    const tokens2 = codeToTokensBase(internal, code3, {
      ...options,
      theme: t.theme
    });
    const state = getLastGrammarStateFromMap(tokens2);
    const theme = typeof t.theme === "string" ? t.theme : t.theme.name;
    return {
      tokens: tokens2,
      state,
      theme
    };
  });
  const tokens = syncThemesTokenization(
    ...themedTokens.map((i) => i.tokens)
  );
  const mergedTokens = tokens[0].map(
    (line, lineIdx) => line.map((_token, tokenIdx) => {
      const mergedToken = {
        content: _token.content,
        variants: {},
        offset: _token.offset
      };
      if ("includeExplanation" in options && options.includeExplanation) {
        mergedToken.explanation = _token.explanation;
      }
      tokens.forEach((t, themeIdx) => {
        const {
          content: _,
          explanation: __,
          offset: ___,
          ...styles
        } = t[lineIdx][tokenIdx];
        mergedToken.variants[themes[themeIdx].color] = styles;
      });
      return mergedToken;
    })
  );
  const mergedGrammarState = themedTokens[0].state ? new GrammarState(
    Object.fromEntries(themedTokens.map((s) => {
      var _a;
      return [s.theme, (_a = s.state) == null ? void 0 : _a.getInternalStack(s.theme)];
    })),
    themedTokens[0].state.lang
  ) : void 0;
  if (mergedGrammarState)
    setLastGrammarStateToMap(mergedTokens, mergedGrammarState);
  return mergedTokens;
}
function syncThemesTokenization(...themes) {
  const outThemes = themes.map(() => []);
  const count = themes.length;
  for (let i = 0; i < themes[0].length; i++) {
    const lines = themes.map((t) => t[i]);
    const outLines = outThemes.map(() => []);
    outThemes.forEach((t, i2) => t.push(outLines[i2]));
    const indexes = lines.map(() => 0);
    const current = lines.map((l) => l[0]);
    while (current.every((t) => t)) {
      const minLength = Math.min(...current.map((t) => t.content.length));
      for (let n = 0; n < count; n++) {
        const token2 = current[n];
        if (token2.content.length === minLength) {
          outLines[n].push(token2);
          indexes[n] += 1;
          current[n] = lines[n][indexes[n]];
        } else {
          outLines[n].push({
            ...token2,
            content: token2.content.slice(0, minLength)
          });
          current[n] = {
            ...token2,
            content: token2.content.slice(minLength),
            offset: token2.offset + minLength
          };
        }
      }
    }
  }
  return outThemes;
}
function codeToTokens(internal, code3, options) {
  let bg;
  let fg;
  let tokens;
  let themeName;
  let rootStyle;
  let grammarState;
  if ("themes" in options) {
    const {
      defaultColor = "light",
      cssVariablePrefix = "--shiki-"
    } = options;
    const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] })).sort((a, b) => a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);
    if (themes.length === 0)
      throw new ShikiError("`themes` option must not be empty");
    const themeTokens = codeToTokensWithThemes(
      internal,
      code3,
      options
    );
    grammarState = getLastGrammarStateFromMap(themeTokens);
    if (defaultColor && !themes.find((t) => t.color === defaultColor))
      throw new ShikiError(`\`themes\` option must contain the defaultColor key \`${defaultColor}\``);
    const themeRegs = themes.map((t) => internal.getTheme(t.theme));
    const themesOrder = themes.map((t) => t.color);
    tokens = themeTokens.map((line) => line.map((token2) => mergeToken(token2, themesOrder, cssVariablePrefix, defaultColor)));
    if (grammarState)
      setLastGrammarStateToMap(tokens, grammarState);
    const themeColorReplacements = themes.map((t) => resolveColorReplacements(t.theme, options));
    fg = themes.map((t, idx) => (idx === 0 && defaultColor ? "" : `${cssVariablePrefix + t.color}:`) + (applyColorReplacements(themeRegs[idx].fg, themeColorReplacements[idx]) || "inherit")).join(";");
    bg = themes.map((t, idx) => (idx === 0 && defaultColor ? "" : `${cssVariablePrefix + t.color}-bg:`) + (applyColorReplacements(themeRegs[idx].bg, themeColorReplacements[idx]) || "inherit")).join(";");
    themeName = `shiki-themes ${themeRegs.map((t) => t.name).join(" ")}`;
    rootStyle = defaultColor ? void 0 : [fg, bg].join(";");
  } else if ("theme" in options) {
    const colorReplacements = resolveColorReplacements(options.theme, options);
    tokens = codeToTokensBase(
      internal,
      code3,
      options
    );
    const _theme = internal.getTheme(options.theme);
    bg = applyColorReplacements(_theme.bg, colorReplacements);
    fg = applyColorReplacements(_theme.fg, colorReplacements);
    themeName = _theme.name;
    grammarState = getLastGrammarStateFromMap(tokens);
  } else {
    throw new ShikiError("Invalid options, either `theme` or `themes` must be provided");
  }
  return {
    tokens,
    fg,
    bg,
    themeName,
    rootStyle,
    grammarState
  };
}
function mergeToken(merged, variantsOrder, cssVariablePrefix, defaultColor) {
  const token2 = {
    content: merged.content,
    explanation: merged.explanation,
    offset: merged.offset
  };
  const styles = variantsOrder.map((t) => getTokenStyleObject(merged.variants[t]));
  const styleKeys = new Set(styles.flatMap((t) => Object.keys(t)));
  const mergedStyles = {};
  styles.forEach((cur, idx) => {
    for (const key2 of styleKeys) {
      const value = cur[key2] || "inherit";
      if (idx === 0 && defaultColor) {
        mergedStyles[key2] = value;
      } else {
        const keyName = key2 === "color" ? "" : key2 === "background-color" ? "-bg" : `-${key2}`;
        const varKey = cssVariablePrefix + variantsOrder[idx] + (key2 === "color" ? "" : keyName);
        mergedStyles[varKey] = value;
      }
    }
  });
  token2.htmlStyle = mergedStyles;
  return token2;
}
function codeToHast(internal, code3, options, transformerContext = {
  meta: {},
  options,
  codeToHast: (_code, _options) => codeToHast(internal, _code, _options),
  codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)
}) {
  var _a, _b;
  let input = code3;
  for (const transformer of getTransformers(options))
    input = ((_a = transformer.preprocess) == null ? void 0 : _a.call(transformerContext, input, options)) || input;
  let {
    tokens,
    fg,
    bg,
    themeName,
    rootStyle,
    grammarState
  } = codeToTokens(internal, input, options);
  const {
    mergeWhitespaces = true
  } = options;
  if (mergeWhitespaces === true)
    tokens = mergeWhitespaceTokens(tokens);
  else if (mergeWhitespaces === "never")
    tokens = splitWhitespaceTokens(tokens);
  const contextSource = {
    ...transformerContext,
    get source() {
      return input;
    }
  };
  for (const transformer of getTransformers(options))
    tokens = ((_b = transformer.tokens) == null ? void 0 : _b.call(contextSource, tokens)) || tokens;
  return tokensToHast(
    tokens,
    {
      ...options,
      fg,
      bg,
      themeName,
      rootStyle
    },
    contextSource,
    grammarState
  );
}
function tokensToHast(tokens, options, transformerContext, grammarState = getLastGrammarStateFromMap(tokens)) {
  var _a, _b, _c;
  const transformers = getTransformers(options);
  const lines = [];
  const root4 = {
    type: "root",
    children: []
  };
  const {
    structure = "classic",
    tabindex = "0"
  } = options;
  let preNode = {
    type: "element",
    tagName: "pre",
    properties: {
      class: `shiki ${options.themeName || ""}`,
      style: options.rootStyle || `background-color:${options.bg};color:${options.fg}`,
      ...tabindex !== false && tabindex != null ? {
        tabindex: tabindex.toString()
      } : {},
      ...Object.fromEntries(
        Array.from(
          Object.entries(options.meta || {})
        ).filter(([key2]) => !key2.startsWith("_"))
      )
    },
    children: []
  };
  let codeNode = {
    type: "element",
    tagName: "code",
    properties: {},
    children: lines
  };
  const lineNodes = [];
  const context = {
    ...transformerContext,
    structure,
    addClassToHast,
    get source() {
      return transformerContext.source;
    },
    get tokens() {
      return tokens;
    },
    get options() {
      return options;
    },
    get root() {
      return root4;
    },
    get pre() {
      return preNode;
    },
    get code() {
      return codeNode;
    },
    get lines() {
      return lineNodes;
    }
  };
  tokens.forEach((line, idx) => {
    var _a2, _b2;
    if (idx) {
      if (structure === "inline")
        root4.children.push({ type: "element", tagName: "br", properties: {}, children: [] });
      else if (structure === "classic")
        lines.push({ type: "text", value: "\n" });
    }
    let lineNode = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    };
    let col = 0;
    for (const token2 of line) {
      let tokenNode = {
        type: "element",
        tagName: "span",
        properties: {
          ...token2.htmlAttrs
        },
        children: [{ type: "text", value: token2.content }]
      };
      if (typeof token2.htmlStyle === "string")
        warnDeprecated("`htmlStyle` as a string is deprecated. Use an object instead.");
      const style = stringifyTokenStyle(token2.htmlStyle || getTokenStyleObject(token2));
      if (style)
        tokenNode.properties.style = style;
      for (const transformer of transformers)
        tokenNode = ((_a2 = transformer == null ? void 0 : transformer.span) == null ? void 0 : _a2.call(context, tokenNode, idx + 1, col, lineNode, token2)) || tokenNode;
      if (structure === "inline")
        root4.children.push(tokenNode);
      else if (structure === "classic")
        lineNode.children.push(tokenNode);
      col += token2.content.length;
    }
    if (structure === "classic") {
      for (const transformer of transformers)
        lineNode = ((_b2 = transformer == null ? void 0 : transformer.line) == null ? void 0 : _b2.call(context, lineNode, idx + 1)) || lineNode;
      lineNodes.push(lineNode);
      lines.push(lineNode);
    }
  });
  if (structure === "classic") {
    for (const transformer of transformers)
      codeNode = ((_a = transformer == null ? void 0 : transformer.code) == null ? void 0 : _a.call(context, codeNode)) || codeNode;
    preNode.children.push(codeNode);
    for (const transformer of transformers)
      preNode = ((_b = transformer == null ? void 0 : transformer.pre) == null ? void 0 : _b.call(context, preNode)) || preNode;
    root4.children.push(preNode);
  }
  let result = root4;
  for (const transformer of transformers)
    result = ((_c = transformer == null ? void 0 : transformer.root) == null ? void 0 : _c.call(context, result)) || result;
  if (grammarState)
    setLastGrammarStateToMap(result, grammarState);
  return result;
}
function mergeWhitespaceTokens(tokens) {
  return tokens.map((line) => {
    const newLine = [];
    let carryOnContent = "";
    let firstOffset = 0;
    line.forEach((token2, idx) => {
      const isUnderline = token2.fontStyle && token2.fontStyle & FontStyle.Underline;
      const couldMerge = !isUnderline;
      if (couldMerge && token2.content.match(/^\s+$/) && line[idx + 1]) {
        if (!firstOffset)
          firstOffset = token2.offset;
        carryOnContent += token2.content;
      } else {
        if (carryOnContent) {
          if (couldMerge) {
            newLine.push({
              ...token2,
              offset: firstOffset,
              content: carryOnContent + token2.content
            });
          } else {
            newLine.push(
              {
                content: carryOnContent,
                offset: firstOffset
              },
              token2
            );
          }
          firstOffset = 0;
          carryOnContent = "";
        } else {
          newLine.push(token2);
        }
      }
    });
    return newLine;
  });
}
function splitWhitespaceTokens(tokens) {
  return tokens.map((line) => {
    return line.flatMap((token2) => {
      if (token2.content.match(/^\s+$/))
        return token2;
      const match = token2.content.match(/^(\s*)(.*?)(\s*)$/);
      if (!match)
        return token2;
      const [, leading, content3, trailing] = match;
      if (!leading && !trailing)
        return token2;
      const expanded = [{
        ...token2,
        offset: token2.offset + leading.length,
        content: content3
      }];
      if (leading) {
        expanded.unshift({
          content: leading,
          offset: token2.offset
        });
      }
      if (trailing) {
        expanded.push({
          content: trailing,
          offset: token2.offset + leading.length + content3.length
        });
      }
      return expanded;
    });
  });
}
function codeToHtml(internal, code3, options) {
  var _a;
  const context = {
    meta: {},
    options,
    codeToHast: (_code, _options) => codeToHast(internal, _code, _options),
    codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)
  };
  let result = toHtml(codeToHast(internal, code3, options, context));
  for (const transformer of getTransformers(options))
    result = ((_a = transformer.postprocess) == null ? void 0 : _a.call(context, result, options)) || result;
  return result;
}
var VSCODE_FALLBACK_EDITOR_FG = { light: "#333333", dark: "#bbbbbb" };
var VSCODE_FALLBACK_EDITOR_BG = { light: "#fffffe", dark: "#1e1e1e" };
var RESOLVED_KEY = "__shiki_resolved";
function normalizeTheme(rawTheme) {
  var _a, _b, _c, _d, _e;
  if (rawTheme == null ? void 0 : rawTheme[RESOLVED_KEY])
    return rawTheme;
  const theme = {
    ...rawTheme
  };
  if (theme.tokenColors && !theme.settings) {
    theme.settings = theme.tokenColors;
    delete theme.tokenColors;
  }
  theme.type || (theme.type = "dark");
  theme.colorReplacements = { ...theme.colorReplacements };
  theme.settings || (theme.settings = []);
  let { bg, fg } = theme;
  if (!bg || !fg) {
    const globalSetting = theme.settings ? theme.settings.find((s) => !s.name && !s.scope) : void 0;
    if ((_a = globalSetting == null ? void 0 : globalSetting.settings) == null ? void 0 : _a.foreground)
      fg = globalSetting.settings.foreground;
    if ((_b = globalSetting == null ? void 0 : globalSetting.settings) == null ? void 0 : _b.background)
      bg = globalSetting.settings.background;
    if (!fg && ((_c = theme == null ? void 0 : theme.colors) == null ? void 0 : _c["editor.foreground"]))
      fg = theme.colors["editor.foreground"];
    if (!bg && ((_d = theme == null ? void 0 : theme.colors) == null ? void 0 : _d["editor.background"]))
      bg = theme.colors["editor.background"];
    if (!fg)
      fg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;
    if (!bg)
      bg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;
    theme.fg = fg;
    theme.bg = bg;
  }
  if (!(theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope)) {
    theme.settings.unshift({
      settings: {
        foreground: theme.fg,
        background: theme.bg
      }
    });
  }
  let replacementCount = 0;
  const replacementMap = /* @__PURE__ */ new Map();
  function getReplacementColor(value) {
    var _a2;
    if (replacementMap.has(value))
      return replacementMap.get(value);
    replacementCount += 1;
    const hex = `#${replacementCount.toString(16).padStart(8, "0").toLowerCase()}`;
    if ((_a2 = theme.colorReplacements) == null ? void 0 : _a2[`#${hex}`])
      return getReplacementColor(value);
    replacementMap.set(value, hex);
    return hex;
  }
  theme.settings = theme.settings.map((setting) => {
    var _a2, _b2;
    const replaceFg = ((_a2 = setting.settings) == null ? void 0 : _a2.foreground) && !setting.settings.foreground.startsWith("#");
    const replaceBg = ((_b2 = setting.settings) == null ? void 0 : _b2.background) && !setting.settings.background.startsWith("#");
    if (!replaceFg && !replaceBg)
      return setting;
    const clone = {
      ...setting,
      settings: {
        ...setting.settings
      }
    };
    if (replaceFg) {
      const replacement = getReplacementColor(setting.settings.foreground);
      theme.colorReplacements[replacement] = setting.settings.foreground;
      clone.settings.foreground = replacement;
    }
    if (replaceBg) {
      const replacement = getReplacementColor(setting.settings.background);
      theme.colorReplacements[replacement] = setting.settings.background;
      clone.settings.background = replacement;
    }
    return clone;
  });
  for (const key2 of Object.keys(theme.colors || {})) {
    if (key2 === "editor.foreground" || key2 === "editor.background" || key2.startsWith("terminal.ansi")) {
      if (!((_e = theme.colors[key2]) == null ? void 0 : _e.startsWith("#"))) {
        const replacement = getReplacementColor(theme.colors[key2]);
        theme.colorReplacements[replacement] = theme.colors[key2];
        theme.colors[key2] = replacement;
      }
    }
  }
  Object.defineProperty(theme, RESOLVED_KEY, {
    enumerable: false,
    writable: false,
    value: true
  });
  return theme;
}
async function resolveLangs(langs) {
  return Array.from(new Set((await Promise.all(
    langs.filter((l) => !isSpecialLang(l)).map(async (lang) => await normalizeGetter(lang).then((r4) => Array.isArray(r4) ? r4 : [r4]))
  )).flat()));
}
async function resolveThemes(themes) {
  const resolved = await Promise.all(
    themes.map(
      async (theme) => isSpecialTheme(theme) ? null : normalizeTheme(await normalizeGetter(theme))
    )
  );
  return resolved.filter((i) => !!i);
}
var Registry2 = class extends Registry {
  constructor(_resolver, _themes, _langs, _alias = {}) {
    super(_resolver);
    __publicField(this, "_resolvedThemes", /* @__PURE__ */ new Map());
    __publicField(this, "_resolvedGrammars", /* @__PURE__ */ new Map());
    __publicField(this, "_langMap", /* @__PURE__ */ new Map());
    __publicField(this, "_langGraph", /* @__PURE__ */ new Map());
    __publicField(this, "_textmateThemeCache", /* @__PURE__ */ new WeakMap());
    __publicField(this, "_loadedThemesCache", null);
    __publicField(this, "_loadedLanguagesCache", null);
    this._resolver = _resolver;
    this._themes = _themes;
    this._langs = _langs;
    this._alias = _alias;
    this._themes.map((t) => this.loadTheme(t));
    this.loadLanguages(this._langs);
  }
  getTheme(theme) {
    if (typeof theme === "string")
      return this._resolvedThemes.get(theme);
    else
      return this.loadTheme(theme);
  }
  loadTheme(theme) {
    const _theme = normalizeTheme(theme);
    if (_theme.name) {
      this._resolvedThemes.set(_theme.name, _theme);
      this._loadedThemesCache = null;
    }
    return _theme;
  }
  getLoadedThemes() {
    if (!this._loadedThemesCache)
      this._loadedThemesCache = [...this._resolvedThemes.keys()];
    return this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(theme) {
    let textmateTheme = this._textmateThemeCache.get(theme);
    if (!textmateTheme) {
      textmateTheme = Theme.createFromRawTheme(theme);
      this._textmateThemeCache.set(theme, textmateTheme);
    }
    this._syncRegistry.setTheme(textmateTheme);
  }
  getGrammar(name) {
    if (this._alias[name]) {
      const resolved = /* @__PURE__ */ new Set([name]);
      while (this._alias[name]) {
        name = this._alias[name];
        if (resolved.has(name))
          throw new ShikiError3(`Circular alias \`${Array.from(resolved).join(" -> ")} -> ${name}\``);
        resolved.add(name);
      }
    }
    return this._resolvedGrammars.get(name);
  }
  loadLanguage(lang) {
    var _a, _b, _c, _d;
    if (this.getGrammar(lang.name))
      return;
    const embeddedLazilyBy = new Set(
      [...this._langMap.values()].filter((i) => {
        var _a2;
        return (_a2 = i.embeddedLangsLazy) == null ? void 0 : _a2.includes(lang.name);
      })
    );
    this._resolver.addLanguage(lang);
    const grammarConfig = {
      balancedBracketSelectors: lang.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(lang.scopeName, lang);
    const g = this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);
    g.name = lang.name;
    this._resolvedGrammars.set(lang.name, g);
    if (lang.aliases) {
      lang.aliases.forEach((alias) => {
        this._alias[alias] = lang.name;
      });
    }
    this._loadedLanguagesCache = null;
    if (embeddedLazilyBy.size) {
      for (const e of embeddedLazilyBy) {
        this._resolvedGrammars.delete(e.name);
        this._loadedLanguagesCache = null;
        (_b = (_a = this._syncRegistry) == null ? void 0 : _a._injectionGrammars) == null ? void 0 : _b.delete(e.scopeName);
        (_d = (_c = this._syncRegistry) == null ? void 0 : _c._grammars) == null ? void 0 : _d.delete(e.scopeName);
        this.loadLanguage(this._langMap.get(e.name));
      }
    }
  }
  dispose() {
    super.dispose();
    this._resolvedThemes.clear();
    this._resolvedGrammars.clear();
    this._langMap.clear();
    this._langGraph.clear();
    this._loadedThemesCache = null;
  }
  loadLanguages(langs) {
    for (const lang of langs)
      this.resolveEmbeddedLanguages(lang);
    const langsGraphArray = Array.from(this._langGraph.entries());
    const missingLangs = langsGraphArray.filter(([_, lang]) => !lang);
    if (missingLangs.length) {
      const dependents = langsGraphArray.filter(([_, lang]) => {
        var _a;
        return lang && ((_a = lang.embeddedLangs) == null ? void 0 : _a.some((l) => missingLangs.map(([name]) => name).includes(l)));
      }).filter((lang) => !missingLangs.includes(lang));
      throw new ShikiError3(`Missing languages ${missingLangs.map(([name]) => `\`${name}\``).join(", ")}, required by ${dependents.map(([name]) => `\`${name}\``).join(", ")}`);
    }
    for (const [_, lang] of langsGraphArray)
      this._resolver.addLanguage(lang);
    for (const [_, lang] of langsGraphArray)
      this.loadLanguage(lang);
  }
  getLoadedLanguages() {
    if (!this._loadedLanguagesCache) {
      this._loadedLanguagesCache = [
        .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
      ];
    }
    return this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(lang) {
    this._langMap.set(lang.name, lang);
    this._langGraph.set(lang.name, lang);
    if (lang.embeddedLangs) {
      for (const embeddedLang of lang.embeddedLangs)
        this._langGraph.set(embeddedLang, this._langMap.get(embeddedLang));
    }
  }
};
var Resolver = class {
  constructor(engine, langs) {
    __publicField(this, "_langs", /* @__PURE__ */ new Map());
    __publicField(this, "_scopeToLang", /* @__PURE__ */ new Map());
    __publicField(this, "_injections", /* @__PURE__ */ new Map());
    __publicField(this, "_onigLib");
    this._onigLib = {
      createOnigScanner: (patterns) => engine.createScanner(patterns),
      createOnigString: (s) => engine.createString(s)
    };
    langs.forEach((i) => this.addLanguage(i));
  }
  get onigLib() {
    return this._onigLib;
  }
  getLangRegistration(langIdOrAlias) {
    return this._langs.get(langIdOrAlias);
  }
  loadGrammar(scopeName) {
    return this._scopeToLang.get(scopeName);
  }
  addLanguage(l) {
    this._langs.set(l.name, l);
    if (l.aliases) {
      l.aliases.forEach((a) => {
        this._langs.set(a, l);
      });
    }
    this._scopeToLang.set(l.scopeName, l);
    if (l.injectTo) {
      l.injectTo.forEach((i) => {
        if (!this._injections.get(i))
          this._injections.set(i, []);
        this._injections.get(i).push(l.scopeName);
      });
    }
  }
  getInjections(scopeName) {
    const scopeParts = scopeName.split(".");
    let injections = [];
    for (let i = 1; i <= scopeParts.length; i++) {
      const subScopeName = scopeParts.slice(0, i).join(".");
      injections = [...injections, ...this._injections.get(subScopeName) || []];
    }
    return injections;
  }
};
var instancesCount = 0;
function createShikiInternalSync(options) {
  instancesCount += 1;
  if (options.warnings !== false && instancesCount >= 10 && instancesCount % 10 === 0)
    console.warn(`[Shiki] ${instancesCount} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let isDisposed = false;
  if (!options.engine)
    throw new ShikiError3("`engine` option is required for synchronous mode");
  const langs = (options.langs || []).flat(1);
  const themes = (options.themes || []).flat(1).map(normalizeTheme);
  const resolver2 = new Resolver(options.engine, langs);
  const _registry = new Registry2(resolver2, themes, langs, options.langAlias);
  let _lastTheme;
  function getLanguage(name) {
    ensureNotDisposed();
    const _lang = _registry.getGrammar(typeof name === "string" ? name : name.name);
    if (!_lang)
      throw new ShikiError3(`Language \`${name}\` not found, you may need to load it first`);
    return _lang;
  }
  function getTheme(name) {
    if (name === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    ensureNotDisposed();
    const _theme = _registry.getTheme(name);
    if (!_theme)
      throw new ShikiError3(`Theme \`${name}\` not found, you may need to load it first`);
    return _theme;
  }
  function setTheme(name) {
    ensureNotDisposed();
    const theme = getTheme(name);
    if (_lastTheme !== name) {
      _registry.setTheme(theme);
      _lastTheme = name;
    }
    const colorMap = _registry.getColorMap();
    return {
      theme,
      colorMap
    };
  }
  function getLoadedThemes() {
    ensureNotDisposed();
    return _registry.getLoadedThemes();
  }
  function getLoadedLanguages() {
    ensureNotDisposed();
    return _registry.getLoadedLanguages();
  }
  function loadLanguageSync(...langs2) {
    ensureNotDisposed();
    _registry.loadLanguages(langs2.flat(1));
  }
  async function loadLanguage(...langs2) {
    return loadLanguageSync(await resolveLangs(langs2));
  }
  function loadThemeSync(...themes2) {
    ensureNotDisposed();
    for (const theme of themes2.flat(1)) {
      _registry.loadTheme(theme);
    }
  }
  async function loadTheme(...themes2) {
    ensureNotDisposed();
    return loadThemeSync(await resolveThemes(themes2));
  }
  function ensureNotDisposed() {
    if (isDisposed)
      throw new ShikiError3("Shiki instance has been disposed");
  }
  function dispose() {
    if (isDisposed)
      return;
    isDisposed = true;
    _registry.dispose();
    instancesCount -= 1;
  }
  return {
    setTheme,
    getTheme,
    getLanguage,
    getLoadedThemes,
    getLoadedLanguages,
    loadLanguage,
    loadLanguageSync,
    loadTheme,
    loadThemeSync,
    dispose,
    [Symbol.dispose]: dispose
  };
}
async function createShikiInternal(options = {}) {
  if (options.loadWasm) {
    warnDeprecated("`loadWasm` option is deprecated. Use `engine: createOnigurumaEngine(loadWasm)` instead.");
  }
  const [
    themes,
    langs,
    engine
  ] = await Promise.all([
    resolveThemes(options.themes || []),
    resolveLangs(options.langs || []),
    options.engine || createOnigurumaEngine(options.loadWasm || getDefaultWasmLoader())
  ]);
  return createShikiInternalSync({
    ...options,
    loadWasm: void 0,
    themes,
    langs,
    engine
  });
}
async function createHighlighterCore(options = {}) {
  const internal = await createShikiInternal(options);
  return {
    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),
    codeToTokensBase: (code3, options2) => codeToTokensBase(internal, code3, options2),
    codeToTokensWithThemes: (code3, options2) => codeToTokensWithThemes(internal, code3, options2),
    codeToTokens: (code3, options2) => codeToTokens(internal, code3, options2),
    codeToHast: (code3, options2) => codeToHast(internal, code3, options2),
    codeToHtml: (code3, options2) => codeToHtml(internal, code3, options2),
    ...internal,
    getInternalContext: () => internal
  };
}
function makeSingletonHighlighterCore(createHighlighter) {
  let _shiki;
  async function getSingletonHighlighterCore2(options = {}) {
    if (!_shiki) {
      _shiki = createHighlighter({
        ...options,
        themes: options.themes || [],
        langs: options.langs || []
      });
      return _shiki;
    } else {
      const s = await _shiki;
      await Promise.all([
        s.loadTheme(...options.themes || []),
        s.loadLanguage(...options.langs || [])
      ]);
      return s;
    }
  }
  return getSingletonHighlighterCore2;
}
var getSingletonHighlighterCore = makeSingletonHighlighterCore(createHighlighterCore);

// node_modules/@shikijs/twoslash/dist/core.mjs
var ShikiTwoslashError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ShikiTwoslashError";
  }
};
var TwoslashIncludesManager = class {
  constructor(map = /* @__PURE__ */ new Map()) {
    this.map = map;
  }
  add(name, code3) {
    const lines = [];
    code3.split("\n").forEach((l, _i) => {
      const trimmed = l.trim();
      if (trimmed.startsWith("// - ")) {
        const key2 = trimmed.split("// - ")[1].split(" ")[0];
        this.map.set(`${name}-${key2}`, lines.join("\n"));
      } else {
        lines.push(l);
      }
    });
    this.map.set(name, lines.join("\n"));
  }
  applyInclude(code3) {
    const reMarker = /\/\/ @include: (.*)$/gm;
    const toReplace = [];
    for (const match of code3.matchAll(reMarker)) {
      const key2 = match[1];
      const replaceWith = this.map.get(key2);
      if (!replaceWith) {
        const msg = `Could not find an include with the key: '${key2}'.
There is: ${Array.from(this.map.keys())}.`;
        throw new Error(msg);
      } else {
        toReplace.push([match.index, match[0].length, replaceWith]);
      }
    }
    let newCode = code3.toString();
    toReplace.reverse().forEach(([index2, length, replacementCode]) => {
      newCode = newCode.slice(0, index2) + replacementCode + newCode.slice(index2 + length);
    });
    return newCode;
  }
};
var INCLUDE_META_REGEX = /include\s+([\w-]+)\b.*/;
function parseIncludeMeta(meta) {
  if (!meta)
    return null;
  const match = meta.match(INCLUDE_META_REGEX);
  return (match == null ? void 0 : match[1]) ?? null;
}
var module = {
  type: "element",
  tagName: "svg",
  properties: {
    viewBox: "0 0 32 32"
  },
  children: [
    {
      type: "element",
      tagName: "path",
      properties: {
        d: "M11 2H2v9h2V4h7V2z",
        fill: "currentColor"
      },
      children: []
    },
    {
      type: "element",
      tagName: "path",
      properties: {
        d: "M2 21v9h9v-2H4v-7H2z",
        fill: "currentColor"
      },
      children: []
    },
    {
      type: "element",
      tagName: "path",
      properties: {
        d: "M30 11V2h-9v2h7v7h2z",
        fill: "currentColor"
      },
      children: []
    },
    {
      type: "element",
      tagName: "path",
      properties: {
        d: "M21 30h9v-9h-2v7h-7v2z",
        fill: "currentColor"
      },
      children: []
    },
    {
      type: "element",
      tagName: "path",
      properties: {
        d: "M25.49 10.13l-9-5a1 1 0 0 0-1 0l-9 5A1 1 0 0 0 6 11v10a1 1 0 0 0 .51.87l9 5a1 1 0 0 0 1 0l9-5A1 1 0 0 0 26 21V11a1 1 0 0 0-.51-.87zM16 7.14L22.94 11L16 14.86L9.06 11zM8 12.7l7 3.89v7.71l-7-3.89zm9 11.6v-7.71l7-3.89v7.71z",
        fill: "currentColor"
      },
      children: []
    }
  ]
};
var method = {
  type: "element",
  tagName: "svg",
  properties: {
    viewBox: "0 0 32 32"
  },
  children: [
    {
      type: "element",
      tagName: "path",
      properties: {
        fill: "currentColor",
        d: "m19.626 29.526l-.516-1.933a12.004 12.004 0 0 0 6.121-19.26l1.538-1.28a14.003 14.003 0 0 1-7.143 22.473"
      },
      children: []
    },
    {
      type: "element",
      tagName: "path",
      properties: {
        fill: "currentColor",
        d: "M10 29H8v-3.82l.804-.16C10.262 24.727 12 23.62 12 20v-1.382l-4-2v-2.236l4-2V12c0-5.467 3.925-9 10-9h2v3.82l-.804.16C21.738 7.273 20 8.38 20 12v.382l4 2v2.236l-4 2V20c0 5.467-3.925 9-10 9m0-2c4.935 0 8-2.682 8-7v-2.618l3.764-1.882L18 13.618V12c0-4.578 2.385-6.192 4-6.76V5c-4.935 0-8 2.682-8 7v1.618L10.236 15.5L14 17.382V20c0 4.578-2.385 6.192-4 6.76Z"
      },
      children: []
    },
    {
      type: "element",
      tagName: "path",
      properties: {
        fill: "currentColor",
        d: "M5.231 24.947a14.003 14.003 0 0 1 7.147-22.474l.516 1.932a12.004 12.004 0 0 0-6.125 19.263Z"
      },
      children: []
    }
  ]
};
var property = {
  type: "element",
  tagName: "svg",
  properties: {
    viewBox: "0 0 32 32"
  },
  children: [
    {
      type: "element",
      tagName: "path",
      properties: {
        fill: "currentColor",
        d: "M12.1 2a9.8 9.8 0 0 0-5.4 1.6l6.4 6.4a2.1 2.1 0 0 1 .2 3a2.1 2.1 0 0 1-3-.2L3.7 6.4A9.84 9.84 0 0 0 2 12.1a10.14 10.14 0 0 0 10.1 10.1a10.9 10.9 0 0 0 2.6-.3l6.7 6.7a5 5 0 0 0 7.1-7.1l-6.7-6.7a10.9 10.9 0 0 0 .3-2.6A10 10 0 0 0 12.1 2m8 10.1a7.61 7.61 0 0 1-.3 2.1l-.3 1.1l.8.8l6.7 6.7a2.88 2.88 0 0 1 .9 2.1A2.72 2.72 0 0 1 27 27a2.9 2.9 0 0 1-4.2 0l-6.7-6.7l-.8-.8l-1.1.3a7.61 7.61 0 0 1-2.1.3a8.27 8.27 0 0 1-5.7-2.3A7.63 7.63 0 0 1 4 12.1a8.33 8.33 0 0 1 .3-2.2l4.4 4.4a4.14 4.14 0 0 0 5.9.2a4.14 4.14 0 0 0-.2-5.9L10 4.2a6.45 6.45 0 0 1 2-.3a8.27 8.27 0 0 1 5.7 2.3a8.49 8.49 0 0 1 2.4 5.9"
      },
      children: []
    }
  ]
};
var constructor = {
  type: "element",
  tagName: "svg",
  properties: {
    viewBox: "0 0 32 32"
  },
  children: [
    {
      type: "element",
      tagName: "path",
      properties: {
        d: "M21.49 13.115l-9-5a1 1 0 0 0-1 0l-9 5A1.008 1.008 0 0 0 2 14v9.995a1 1 0 0 0 .52.87l9 5A1.004 1.004 0 0 0 12 30a1.056 1.056 0 0 0 .49-.135l9-5A.992.992 0 0 0 22 24V14a1.008 1.008 0 0 0-.51-.885zM11 27.295l-7-3.89v-7.72l7 3.89zm1-9.45L5.06 14L12 10.135l6.94 3.86zm8 5.56l-7 3.89v-7.72l7-3.89z",
        fill: "currentColor"
      },
      children: []
    },
    {
      type: "element",
      tagName: "path",
      properties: {
        d: "M30 6h-4V2h-2v4h-4v2h4v4h2V8h4V6z",
        fill: "currentColor"
      },
      children: []
    }
  ]
};
var string = {
  type: "element",
  tagName: "svg",
  properties: {
    viewBox: "0 0 32 32"
  },
  children: [
    {
      type: "element",
      tagName: "path",
      properties: {
        fill: "currentColor",
        d: "M29 22h-5a2.003 2.003 0 0 1-2-2v-6a2.002 2.002 0 0 1 2-2h5v2h-5v6h5zM18 12h-4V8h-2v14h6a2.003 2.003 0 0 0 2-2v-6a2.002 2.002 0 0 0-2-2m-4 8v-6h4v6zm-6-8H3v2h5v2H4a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h6v-8a2.002 2.002 0 0 0-2-2m0 8H4v-2h4z"
      },
      children: []
    }
  ]
};
var completionIcons = {
  module,
  "class": {
    type: "element",
    tagName: "svg",
    properties: {
      viewBox: "0 0 32 32"
    },
    children: [
      {
        type: "element",
        tagName: "path",
        properties: {
          fill: "currentColor",
          d: "M26 16a3.961 3.961 0 0 0-2.02.566l-2.859-2.859l2.293-2.293a2 2 0 0 0 0-2.828l-6-6a2 2 0 0 0-2.828 0l-6 6a2 2 0 0 0 0 2.828l2.293 2.293l-2.859 2.859a4.043 4.043 0 1 0 1.414 1.414l2.859-2.859l2.293 2.293a1.977 1.977 0 0 0 .414.31V22h-3v8h8v-8h-3v-4.277a1.977 1.977 0 0 0 .414-.309l2.293-2.293l2.859 2.859A3.989 3.989 0 1 0 26 16M8 20a2 2 0 1 1-2-2a2.002 2.002 0 0 1 2 2m10 4v4h-4v-4zm-2-8l-6-6l6-6l6 6Zm10 6a2 2 0 1 1 2-2a2.002 2.002 0 0 1-2 2"
        },
        children: []
      }
    ]
  },
  method,
  property,
  constructor,
  "interface": {
    type: "element",
    tagName: "svg",
    properties: {
      viewBox: "0 0 32 32"
    },
    children: [
      {
        type: "element",
        tagName: "path",
        properties: {
          fill: "currentColor",
          d: "M23 16.01a7 7 0 0 0-4.18 1.39l-4.22-4.22A6.86 6.86 0 0 0 16 9.01a7 7 0 1 0-2.81 5.59l4.21 4.22a7 7 0 1 0 5.6-2.81m-19-7a5 5 0 1 1 5 5a5 5 0 0 1-5-5"
        },
        children: []
      }
    ]
  },
  "function": {
    type: "element",
    tagName: "svg",
    properties: {
      viewBox: "0 0 32 32"
    },
    children: [
      {
        type: "element",
        tagName: "path",
        properties: {
          fill: "currentColor",
          d: "m19.626 29.526l-.516-1.933a12.004 12.004 0 0 0 6.121-19.26l1.538-1.28a14.003 14.003 0 0 1-7.143 22.473"
        },
        children: []
      },
      {
        type: "element",
        tagName: "path",
        properties: {
          fill: "currentColor",
          d: "M10 29H8v-3.82l.804-.16C10.262 24.727 12 23.62 12 20v-1.382l-4-2v-2.236l4-2V12c0-5.467 3.925-9 10-9h2v3.82l-.804.16C21.738 7.273 20 8.38 20 12v.382l4 2v2.236l-4 2V20c0 5.467-3.925 9-10 9m0-2c4.935 0 8-2.682 8-7v-2.618l3.764-1.882L18 13.618V12c0-4.578 2.385-6.192 4-6.76V5c-4.935 0-8 2.682-8 7v1.618L10.236 15.5L14 17.382V20c0 4.578-2.385 6.192-4 6.76Z"
        },
        children: []
      },
      {
        type: "element",
        tagName: "path",
        properties: {
          fill: "currentColor",
          d: "M5.231 24.947a14.003 14.003 0 0 1 7.147-22.474l.516 1.932a12.004 12.004 0 0 0-6.125 19.263Z"
        },
        children: []
      }
    ]
  },
  string
};
var log = {
  type: "element",
  tagName: "svg",
  properties: {
    viewBox: "0 0 32 32"
  },
  children: [
    {
      type: "element",
      tagName: "path",
      properties: {
        fill: "currentColor",
        d: "M17 22v-8h-4v2h2v6h-3v2h8v-2zM16 8a1.5 1.5 0 1 0 1.5 1.5A1.5 1.5 0 0 0 16 8"
      },
      children: []
    },
    {
      type: "element",
      tagName: "path",
      properties: {
        fill: "currentColor",
        d: "M26 28H6a2.002 2.002 0 0 1-2-2V6a2.002 2.002 0 0 1 2-2h20a2.002 2.002 0 0 1 2 2v20a2.002 2.002 0 0 1-2 2M6 6v20h20V6Z"
      },
      children: []
    }
  ]
};
var error = {
  type: "element",
  tagName: "svg",
  properties: {
    viewBox: "0 0 32 32"
  },
  children: [
    {
      type: "element",
      tagName: "path",
      properties: {
        fill: "currentColor",
        d: "M16 2a14 14 0 1 0 14 14A14 14 0 0 0 16 2m0 26a12 12 0 1 1 12-12a12 12 0 0 1-12 12"
      },
      children: []
    },
    {
      type: "element",
      tagName: "path",
      properties: {
        fill: "currentColor",
        d: "M15 8h2v11h-2zm1 14a1.5 1.5 0 1 0 1.5 1.5A1.5 1.5 0 0 0 16 22"
      },
      children: []
    }
  ]
};
var warn = {
  type: "element",
  tagName: "svg",
  properties: {
    viewBox: "0 0 32 32"
  },
  children: [
    {
      type: "element",
      tagName: "path",
      properties: {
        fill: "currentColor",
        d: "M16 23a1.5 1.5 0 1 0 1.5 1.5A1.5 1.5 0 0 0 16 23m-1-11h2v9h-2z"
      },
      children: []
    },
    {
      type: "element",
      tagName: "path",
      properties: {
        fill: "currentColor",
        d: "M29 30H3a1 1 0 0 1-.887-1.461l13-25a1 1 0 0 1 1.774 0l13 25A1 1 0 0 1 29 30M4.65 28h22.7l.001-.003L16.002 6.17h-.004L4.648 27.997Z"
      },
      children: []
    }
  ]
};
var annotate = {
  type: "element",
  tagName: "svg",
  properties: {
    viewBox: "0 0 32 32"
  },
  children: [
    {
      type: "element",
      tagName: "path",
      properties: {
        fill: "currentColor",
        d: "M11 24h10v2H11zm2 4h6v2h-6zm3-26A10 10 0 0 0 6 12a9.19 9.19 0 0 0 3.46 7.62c1 .93 1.54 1.46 1.54 2.38h2c0-1.84-1.11-2.87-2.19-3.86A7.2 7.2 0 0 1 8 12a8 8 0 0 1 16 0a7.2 7.2 0 0 1-2.82 6.14c-1.07 1-2.18 2-2.18 3.86h2c0-.92.53-1.45 1.54-2.39A9.18 9.18 0 0 0 26 12A10 10 0 0 0 16 2"
      },
      children: []
    }
  ]
};
var tagIcons = {
  log,
  error,
  warn,
  annotate
};
var defaultCompletionIcons = completionIcons;
var defaultCustomTagIcons = tagIcons;
function extend(extension2, node2) {
  var _a, _b;
  if (!extension2)
    return node2;
  return {
    ...node2,
    tagName: extension2.tagName ?? node2.tagName,
    properties: {
      ...node2.properties,
      class: extension2.class || ((_a = node2.properties) == null ? void 0 : _a.class),
      ...extension2.properties
    },
    children: ((_b = extension2.children) == null ? void 0 : _b.call(extension2, node2.children)) ?? node2.children
  };
}
function renderMarkdownPassThrough(markdown) {
  return [
    {
      type: "text",
      value: markdown
    }
  ];
}
function rendererRich(options = {}) {
  const {
    completionIcons: completionIcons2 = defaultCompletionIcons,
    customTagIcons = defaultCustomTagIcons,
    processHoverInfo = defaultHoverInfoProcessor,
    processHoverDocs = (docs) => docs,
    classExtra = "",
    jsdoc = true,
    errorRendering = "line",
    queryRendering = "popup",
    renderMarkdown: renderMarkdown2 = renderMarkdownPassThrough,
    renderMarkdownInline: renderMarkdownInline2 = renderMarkdownPassThrough,
    hast
  } = options;
  function highlightPopupContent(info) {
    var _a;
    if (!info.text)
      return [];
    const content3 = processHoverInfo(info.text);
    if (!content3 || content3 === "any")
      return [];
    const popupContents = [];
    const typeCode = {
      type: "element",
      tagName: "code",
      properties: {},
      children: this.codeToHast(
        content3,
        {
          ...this.options,
          meta: {},
          transformers: [],
          lang: this.options.lang === "tsx" || this.options.lang === "jsx" ? "tsx" : "ts",
          structure: content3.trim().includes("\n") ? "classic" : "inline"
        }
      ).children
    };
    typeCode.properties.class = "twoslash-popup-code";
    popupContents.push(
      extend(
        hast == null ? void 0 : hast.popupTypes,
        typeCode
      )
    );
    if (jsdoc && info.docs) {
      const docs = processHoverDocs(info.docs) ?? info.docs;
      if (docs) {
        const children = renderMarkdown2.call(this, docs);
        popupContents.push(extend(
          hast == null ? void 0 : hast.popupDocs,
          {
            type: "element",
            tagName: "div",
            properties: { class: "twoslash-popup-docs" },
            children
          }
        ));
      }
    }
    if (jsdoc && ((_a = info.tags) == null ? void 0 : _a.length)) {
      popupContents.push(extend(
        hast == null ? void 0 : hast.popupDocsTags,
        {
          type: "element",
          tagName: "div",
          properties: {
            class: "twoslash-popup-docs twoslash-popup-docs-tags"
          },
          children: info.tags.map((tag) => ({
            type: "element",
            tagName: "span",
            properties: {
              class: `twoslash-popup-docs-tag`
            },
            children: [
              {
                type: "element",
                tagName: "span",
                properties: {
                  class: "twoslash-popup-docs-tag-name"
                },
                children: [
                  {
                    type: "text",
                    value: `@${tag[0]}`
                  }
                ]
              },
              ...tag[1] ? [
                {
                  type: "element",
                  tagName: "span",
                  properties: {
                    class: "twoslash-popup-docs-tag-value"
                  },
                  children: renderMarkdownInline2.call(this, tag[1], `tag:${tag[0]}`)
                }
              ] : []
            ]
          }))
        }
      ));
    }
    return popupContents;
  }
  return {
    nodeStaticInfo(info, node2) {
      const themedContent = highlightPopupContent.call(this, info);
      if (!themedContent.length)
        return node2;
      const popup = extend(
        hast == null ? void 0 : hast.hoverPopup,
        {
          type: "element",
          tagName: "span",
          properties: {
            class: ["twoslash-popup-container", classExtra].filter(Boolean).join(" ")
          },
          children: themedContent
        }
      );
      return extend(
        hast == null ? void 0 : hast.hoverToken,
        {
          type: "element",
          tagName: "span",
          properties: {
            class: "twoslash-hover"
          },
          children: (hast == null ? void 0 : hast.hoverCompose) ? hast == null ? void 0 : hast.hoverCompose({ popup, token: node2 }) : [popup, node2]
        }
      );
    },
    nodeQuery(query, node2) {
      if (!query.text)
        return {};
      const themedContent = highlightPopupContent.call(this, query);
      if (queryRendering !== "popup") {
        return extend(
          hast == null ? void 0 : hast.queryToken,
          {
            type: "element",
            tagName: "span",
            properties: {
              class: "twoslash-hover"
            },
            children: [
              node2
            ]
          }
        );
      }
      const popup = extend(
        hast == null ? void 0 : hast.queryPopup,
        {
          type: "element",
          tagName: "span",
          properties: {
            class: ["twoslash-popup-container", classExtra].filter(Boolean).join(" ")
          },
          children: [
            {
              type: "element",
              tagName: "div",
              properties: { class: "twoslash-popup-arrow" },
              children: []
            },
            ...themedContent
          ]
        }
      );
      return extend(
        hast == null ? void 0 : hast.queryToken,
        {
          type: "element",
          tagName: "span",
          properties: {
            class: "twoslash-hover twoslash-query-presisted"
          },
          children: (hast == null ? void 0 : hast.queryCompose) ? hast == null ? void 0 : hast.queryCompose({ popup, token: node2 }) : [popup, node2]
        }
      );
    },
    nodeCompletion(query, node2) {
      if (node2.type !== "text")
        throw new ShikiTwoslashError(`Renderer hook nodeCompletion only works on text nodes, got ${node2.type}`);
      const items = query.completions.map((i) => {
        var _a;
        const kind = i.kind || "default";
        const isDeprecated = "kindModifiers" in i && typeof i.kindModifiers === "string" && ((_a = i.kindModifiers) == null ? void 0 : _a.split(",").includes("deprecated"));
        return {
          type: "element",
          tagName: "li",
          properties: {},
          children: [
            ...completionIcons2 ? [{
              type: "element",
              tagName: "span",
              properties: { class: `twoslash-completions-icon completions-${kind.replace(/\s/g, "-")}` },
              children: [
                completionIcons2[kind] || completionIcons2.property
              ].filter(Boolean)
            }] : [],
            {
              type: "element",
              tagName: "span",
              properties: {
                class: isDeprecated ? "deprecated" : void 0
              },
              children: [
                {
                  type: "element",
                  tagName: "span",
                  properties: { class: "twoslash-completions-matched" },
                  children: [
                    {
                      type: "text",
                      value: i.name.startsWith(query.completionsPrefix) ? query.completionsPrefix : ""
                    }
                  ]
                },
                {
                  type: "element",
                  tagName: "span",
                  properties: { class: "twoslash-completions-unmatched" },
                  children: [
                    {
                      type: "text",
                      value: i.name.startsWith(query.completionsPrefix) ? i.name.slice(query.completionsPrefix.length || 0) : i.name
                    }
                  ]
                }
              ]
            }
          ]
        };
      });
      const cursor = extend(
        hast == null ? void 0 : hast.completionCursor,
        {
          type: "element",
          tagName: "span",
          properties: {
            class: ["twoslash-completion-cursor", classExtra].filter(Boolean).join(" ")
          },
          children: []
        }
      );
      const popup = extend(
        hast == null ? void 0 : hast.completionPopup,
        {
          type: "element",
          tagName: "ul",
          properties: {
            class: ["twoslash-completion-list", classExtra].filter(Boolean).join(" ")
          },
          children: items
        }
      );
      const children = [];
      if (node2.value)
        children.push({ type: "text", value: node2.value });
      if (hast == null ? void 0 : hast.completionCompose) {
        children.push(...hast.completionCompose({ popup, cursor }));
      } else {
        children.push({
          ...cursor,
          children: [popup]
        });
      }
      return extend(
        hast == null ? void 0 : hast.completionToken,
        {
          type: "element",
          tagName: "span",
          properties: {},
          children
        }
      );
    },
    nodesError(error2, children) {
      if (errorRendering !== "hover") {
        return [
          extend(
            hast == null ? void 0 : hast.errorToken,
            {
              type: "element",
              tagName: "span",
              properties: {
                class: [`twoslash-error`, getErrorLevelClass(error2)].filter(Boolean).join(" ")
              },
              children
            }
          )
        ];
      }
      const popup = extend(
        hast == null ? void 0 : hast.errorPopup,
        {
          type: "element",
          tagName: "span",
          properties: {
            class: ["twoslash-popup-container", classExtra].filter(Boolean).join(" ")
          },
          children: [
            extend(
              hast == null ? void 0 : hast.popupError,
              {
                type: "element",
                tagName: "div",
                properties: {
                  class: "twoslash-popup-error"
                },
                children: renderMarkdown2.call(this, error2.text)
              }
            )
          ]
        }
      );
      const token2 = {
        type: "element",
        tagName: "span",
        children,
        properties: {}
      };
      return [
        extend(
          hast == null ? void 0 : hast.errorToken,
          {
            type: "element",
            tagName: "span",
            properties: {
              class: `twoslash-error twoslash-error-hover ${getErrorLevelClass(error2)}`
            },
            children: (hast == null ? void 0 : hast.errorCompose) ? hast == null ? void 0 : hast.errorCompose({ popup, token: token2 }) : [popup, token2]
          }
        )
      ];
    },
    lineQuery(query, node2) {
      if (queryRendering !== "line")
        return [];
      const themedContent = highlightPopupContent.call(this, query);
      const targetNode = (node2 == null ? void 0 : node2.type) === "element" ? node2.children[0] : void 0;
      const targetText = (targetNode == null ? void 0 : targetNode.type) === "text" ? targetNode.value : "";
      const offset = Math.max(0, (query.character || 0) + Math.floor(targetText.length / 2) - 2);
      return [
        {
          type: "element",
          tagName: "div",
          properties: {
            class: ["twoslash-meta-line twoslash-query-line", classExtra].filter(Boolean).join(" ")
          },
          children: [
            { type: "text", value: " ".repeat(offset) },
            {
              type: "element",
              tagName: "span",
              properties: {
                class: ["twoslash-popup-container", classExtra].filter(Boolean).join(" ")
              },
              children: [
                {
                  type: "element",
                  tagName: "div",
                  properties: { class: "twoslash-popup-arrow" },
                  children: []
                },
                ...themedContent
              ]
            }
          ]
        }
      ];
    },
    lineError(error2) {
      if (errorRendering !== "line")
        return [];
      return [
        {
          type: "element",
          tagName: "div",
          properties: {
            class: ["twoslash-meta-line twoslash-error-line", getErrorLevelClass(error2), classExtra].filter(Boolean).join(" ")
          },
          children: [
            {
              type: "text",
              value: error2.text
            }
          ]
        }
      ];
    },
    lineCustomTag(tag) {
      return [
        {
          type: "element",
          tagName: "div",
          properties: {
            class: [`twoslash-tag-line twoslash-tag-${tag.name}-line`, classExtra].filter(Boolean).join(" ")
          },
          children: [
            ...customTagIcons ? [{
              type: "element",
              tagName: "span",
              properties: { class: `twoslash-tag-icon tag-${tag.name}-icon` },
              children: [
                customTagIcons[tag.name]
              ].filter(Boolean)
            }] : [],
            {
              type: "text",
              value: tag.text || ""
            }
          ]
        }
      ];
    },
    nodesHighlight(highlight, nodes) {
      return [
        extend(
          hast == null ? void 0 : hast.nodesHighlight,
          {
            type: "element",
            tagName: "span",
            properties: {
              class: "twoslash-highlighted"
            },
            children: nodes
          }
        )
      ];
    }
  };
}
var regexType = /^[A-Z]\w*(<[^>]*>)?:/;
var regexFunction = /^\w*\(/;
function defaultHoverInfoProcessor(type) {
  let content3 = type.replace(/^\(([\w-]+)\)\s+/gm, "").replace(/\nimport .*$/, "").replace(/^(interface|namespace) \w+$/gm, "").trim();
  if (content3.match(regexType))
    content3 = `type ${content3}`;
  else if (content3.match(regexFunction))
    content3 = `function ${content3}`;
  return content3;
}
function getErrorLevelClass(error2) {
  switch (error2.level) {
    case "warning":
      return "twoslash-error-level-warning";
    case "suggestion":
      return "twoslash-error-level-suggestion";
    case "message":
      return "twoslash-error-level-message";
    default:
      return "";
  }
}
function defaultTwoslashOptions() {
  return {
    customTags: ["annotate", "log", "warn", "error"]
  };
}
function createTransformerFactory(defaultTwoslasher, defaultRenderer) {
  return function transformerTwoslash2(options = {}) {
    const {
      langs = ["ts", "tsx"],
      twoslashOptions = defaultTwoslashOptions(),
      langAlias = {
        typescript: "ts",
        json5: "json",
        yml: "yaml"
      },
      twoslasher: twoslasher2 = defaultTwoslasher,
      explicitTrigger = false,
      disableTriggers = ["notwoslash", "no-twoslash"],
      renderer = defaultRenderer,
      throws = true,
      includesMap = /* @__PURE__ */ new Map()
    } = options;
    const onTwoslashError = options.onTwoslashError || (throws ? (error2) => {
      throw error2;
    } : () => false);
    const onShikiError = options.onShikiError || (throws ? (error2) => {
      throw error2;
    } : () => false);
    const trigger = explicitTrigger instanceof RegExp ? explicitTrigger : /\btwoslash\b/;
    if (!renderer)
      throw new ShikiTwoslashError("Missing renderer");
    const map = /* @__PURE__ */ new WeakMap();
    const {
      filter = (lang, _, options2) => {
        var _a;
        return langs.includes(lang) && (!explicitTrigger || trigger.test(((_a = options2.meta) == null ? void 0 : _a.__raw) || "")) && !disableTriggers.some((i) => {
          var _a2, _b, _c;
          return typeof i === "string" ? (_b = (_a2 = options2.meta) == null ? void 0 : _a2.__raw) == null ? void 0 : _b.includes(i) : i.test(((_c = options2.meta) == null ? void 0 : _c.__raw) || "");
        });
      }
    } = options;
    const includes = new TwoslashIncludesManager(includesMap);
    return {
      preprocess(code3) {
        var _a, _b;
        let lang = this.options.lang;
        if (lang in langAlias)
          lang = langAlias[this.options.lang];
        if (filter(lang, code3, this.options)) {
          try {
            const codeWithIncludes = includes.applyInclude(code3);
            const include = parseIncludeMeta((_a = this.options.meta) == null ? void 0 : _a.__raw);
            if (include)
              includes.add(include, codeWithIncludes);
            const twoslash = twoslasher2(codeWithIncludes, lang, twoslashOptions);
            map.set(this.meta, twoslash);
            this.meta.twoslash = twoslash;
            this.options.lang = ((_b = twoslash.meta) == null ? void 0 : _b.extension) || lang;
            return twoslash.code;
          } catch (error2) {
            const result = onTwoslashError(error2, code3, lang, this.options);
            if (typeof result === "string")
              return code3;
          }
        }
      },
      tokens(tokens) {
        const twoslash = map.get(this.meta);
        if (!twoslash)
          return;
        return splitTokens(
          tokens,
          twoslash.nodes.flatMap(
            (i) => ["hover", "error", "query", "highlight", "completion"].includes(i.type) ? [i.start, i.start + i.length] : []
          )
        );
      },
      pre(pre) {
        const twoslash = map.get(this.meta);
        if (!twoslash)
          return;
        this.addClassToHast(pre, "twoslash lsp");
      },
      code(codeEl) {
        const twoslash = map.get(this.meta);
        if (!twoslash)
          return;
        const insertAfterLine = (line, nodes) => {
          if (!nodes.length)
            return;
          let index2;
          if (line >= this.lines.length) {
            index2 = codeEl.children.length;
          } else {
            const lineEl = this.lines[line];
            index2 = codeEl.children.indexOf(lineEl);
            if (index2 === -1) {
              onShikiError(new ShikiTwoslashError(`Cannot find line ${line} in code element`), this.source, this.options.lang);
              return;
            }
          }
          const nodeAfter = codeEl.children[index2 + 1];
          if (nodeAfter && nodeAfter.type === "text" && nodeAfter.value === "\n")
            codeEl.children.splice(index2 + 1, 1);
          codeEl.children.splice(index2 + 1, 0, ...nodes);
        };
        const tokensMap = [];
        this.lines.forEach((lineEl, line) => {
          let index2 = 0;
          for (const token2 of lineEl.children.flatMap((i) => i.type === "element" ? i.children || [] : [])) {
            if ("value" in token2 && typeof token2.value === "string") {
              tokensMap.push([line, index2, index2 + token2.value.length, token2]);
              index2 += token2.value.length;
            }
          }
        });
        const locateTextTokens = (line, character, length) => {
          const start = character;
          const end = character + length;
          if (length === 0) {
            return tokensMap.filter(([l, s, e]) => l === line && s < start && start <= e).map((i) => i[3]);
          }
          return tokensMap.filter(([l, s, e]) => l === line && (start <= s && s < end) && (start < e && e <= end)).map((i) => i[3]);
        };
        const tokensSkipHover = /* @__PURE__ */ new Set();
        const actionsHovers = [];
        const actionsHighlights = [];
        for (const node2 of twoslash.nodes) {
          if (node2.type === "tag") {
            if (renderer.lineCustomTag)
              insertAfterLine(node2.line, renderer.lineCustomTag.call(this, node2));
            continue;
          }
          const tokens = locateTextTokens(node2.line, node2.character, node2.length);
          if (!tokens.length && !(node2.type === "error" && renderer.nodesError)) {
            onShikiError(new ShikiTwoslashError(`Cannot find tokens for node: ${JSON.stringify(node2)}`), this.source, this.options.lang);
            continue;
          }
          const wrapTokens = (fn) => {
            const line = this.lines[node2.line];
            let charIndex = 0;
            let itemStart = line.children.length;
            let itemEnd = 0;
            line.children.forEach((token2, index2) => {
              if (charIndex >= node2.character && index2 < itemStart)
                itemStart = index2;
              if (charIndex <= node2.character + node2.length && index2 > itemEnd)
                itemEnd = index2;
              charIndex += getTokenString(token2).length;
            });
            if (charIndex <= node2.character + node2.length)
              itemEnd = line.children.length;
            const targets = line.children.slice(itemStart, itemEnd);
            const length = targets.length;
            line.children.splice(itemStart, length, ...fn(targets));
          };
          switch (node2.type) {
            case "error": {
              if (renderer.nodeError) {
                tokens.forEach((token2) => {
                  tokensSkipHover.add(token2);
                  const clone = { ...token2 };
                  Object.assign(token2, renderer.nodeError.call(this, node2, clone));
                });
              }
              if (renderer.nodesError) {
                tokens.forEach((token2) => {
                  tokensSkipHover.add(token2);
                });
                actionsHighlights.push(() => {
                  wrapTokens((targets) => {
                    var _a;
                    return ((_a = renderer.nodesError) == null ? void 0 : _a.call(this, node2, targets)) || targets;
                  });
                });
              }
              if (renderer.lineError)
                insertAfterLine(node2.line, renderer.lineError.call(this, node2));
              break;
            }
            case "query": {
              const token2 = tokens[0];
              if (token2 && renderer.nodeQuery) {
                tokensSkipHover.add(token2);
                const clone = { ...token2 };
                Object.assign(token2, renderer.nodeQuery.call(this, node2, clone));
              }
              if (renderer.lineQuery)
                insertAfterLine(node2.line, renderer.lineQuery.call(this, node2, token2));
              break;
            }
            case "completion": {
              if (renderer.nodeCompletion) {
                tokens.forEach((token2) => {
                  tokensSkipHover.add(token2);
                  const clone = { ...token2 };
                  Object.assign(token2, renderer.nodeCompletion.call(this, node2, clone));
                });
              }
              if (renderer.lineCompletion)
                insertAfterLine(node2.line, renderer.lineCompletion.call(this, node2));
              break;
            }
            case "highlight": {
              if (renderer.nodesHighlight) {
                actionsHighlights.push(() => {
                  wrapTokens((targets) => {
                    var _a;
                    return ((_a = renderer.nodesHighlight) == null ? void 0 : _a.call(this, node2, targets)) || targets;
                  });
                });
              }
              break;
            }
            case "hover": {
              if (renderer.nodeStaticInfo) {
                actionsHovers.push(() => {
                  tokens.forEach((token2) => {
                    if (tokensSkipHover.has(token2))
                      return;
                    tokensSkipHover.add(token2);
                    const clone = { ...token2 };
                    Object.assign(token2, renderer.nodeStaticInfo.call(this, node2, clone));
                  });
                });
              }
              break;
            }
            default: {
              onShikiError(new ShikiTwoslashError(`Unknown node type: ${node2 == null ? void 0 : node2.type}`), this.source, this.options.lang);
            }
          }
        }
        actionsHovers.forEach((i) => i());
        actionsHighlights.forEach((i) => i());
      }
    };
  };
}
function getTokenString(token2) {
  var _a;
  if ("value" in token2)
    return token2.value;
  return ((_a = token2.children) == null ? void 0 : _a.map(getTokenString).join("")) || "";
}

// node_modules/twoslash/dist/index.mjs
var import_typescript = __toESM(require_typescript(), 1);

// node_modules/@typescript/vfs/dist/vfs.esm.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var hasLocalStorage = false;
try {
  hasLocalStorage = typeof localStorage !== "undefined";
} catch (error2) {
}
var hasProcess = typeof process !== "undefined";
var shouldDebug = hasLocalStorage && localStorage.getItem("DEBUG") || hasProcess && process.env.DEBUG;
var debugLog = shouldDebug ? console.log : function(_message) {
  return "";
};
function createVirtualTypeScriptEnvironment(sys, rootFiles, ts3, compilerOptions, customTransformers) {
  if (compilerOptions === void 0) {
    compilerOptions = {};
  }
  var mergedCompilerOpts = _extends({}, defaultCompilerOptions(ts3), compilerOptions);
  var _createVirtualLanguag = createVirtualLanguageServiceHost(sys, rootFiles, mergedCompilerOpts, ts3, customTransformers), languageServiceHost = _createVirtualLanguag.languageServiceHost, _updateFile = _createVirtualLanguag.updateFile, _deleteFile = _createVirtualLanguag.deleteFile;
  var languageService = ts3.createLanguageService(languageServiceHost);
  var diagnostics = languageService.getCompilerOptionsDiagnostics();
  if (diagnostics.length) {
    var compilerHost = createVirtualCompilerHost(sys, compilerOptions, ts3);
    throw new Error(ts3.formatDiagnostics(diagnostics, compilerHost.compilerHost));
  }
  return {
    // @ts-ignore
    name: "vfs",
    sys,
    languageService,
    getSourceFile: function getSourceFile(fileName) {
      var _languageService$getP;
      return (_languageService$getP = languageService.getProgram()) == null ? void 0 : _languageService$getP.getSourceFile(fileName);
    },
    createFile: function createFile(fileName, content3) {
      _updateFile(ts3.createSourceFile(fileName, content3, mergedCompilerOpts.target, false));
    },
    updateFile: function updateFile(fileName, content3, optPrevTextSpan) {
      var prevSourceFile = languageService.getProgram().getSourceFile(fileName);
      if (!prevSourceFile) {
        throw new Error("Did not find a source file for " + fileName);
      }
      var prevFullContents = prevSourceFile.text;
      var prevTextSpan = optPrevTextSpan != null ? optPrevTextSpan : ts3.createTextSpan(0, prevFullContents.length);
      var newText = prevFullContents.slice(0, prevTextSpan.start) + content3 + prevFullContents.slice(prevTextSpan.start + prevTextSpan.length);
      var newSourceFile = ts3.updateSourceFile(prevSourceFile, newText, {
        span: prevTextSpan,
        newLength: content3.length
      });
      _updateFile(newSourceFile);
    },
    deleteFile: function deleteFile(fileName) {
      var sourceFile = languageService.getProgram().getSourceFile(fileName);
      if (sourceFile) {
        _deleteFile(sourceFile);
      }
    }
  };
}
function notImplemented(methodName) {
  throw new Error("Method '" + methodName + "' is not implemented.");
}
function audit(name, fn) {
  return function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var res = fn.apply(void 0, args);
    var smallres = typeof res === "string" ? res.slice(0, 80) + "..." : res;
    debugLog.apply(void 0, ["> " + name].concat(args));
    debugLog("< " + smallres);
    return res;
  };
}
var defaultCompilerOptions = function defaultCompilerOptions2(ts3) {
  return _extends({}, ts3.getDefaultCompilerOptions(), {
    jsx: ts3.JsxEmit.React,
    strict: true,
    esModuleInterop: true,
    module: ts3.ModuleKind.ESNext,
    suppressOutputPathCheck: true,
    skipLibCheck: true,
    skipDefaultLibCheck: true,
    moduleResolution: ts3.ModuleResolutionKind.NodeJs
  });
};
var libize = function libize2(path) {
  return path.replace("/", "/lib.").toLowerCase();
};
function createSystem(files) {
  return {
    args: [],
    createDirectory: function createDirectory() {
      return notImplemented("createDirectory");
    },
    // TODO: could make a real file tree
    directoryExists: audit("directoryExists", function(directory) {
      return Array.from(files.keys()).some(function(path) {
        return path.startsWith(directory);
      });
    }),
    exit: function exit3() {
      return notImplemented("exit");
    },
    fileExists: audit("fileExists", function(fileName) {
      return files.has(fileName) || files.has(libize(fileName));
    }),
    getCurrentDirectory: function getCurrentDirectory() {
      return "/";
    },
    getDirectories: function getDirectories() {
      return [];
    },
    getExecutingFilePath: function getExecutingFilePath() {
      return notImplemented("getExecutingFilePath");
    },
    readDirectory: audit("readDirectory", function(directory) {
      return directory === "/" ? Array.from(files.keys()) : [];
    }),
    readFile: audit("readFile", function(fileName) {
      var _files$get;
      return (_files$get = files.get(fileName)) != null ? _files$get : files.get(libize(fileName));
    }),
    resolvePath: function resolvePath(path) {
      return path;
    },
    newLine: "\n",
    useCaseSensitiveFileNames: true,
    write: function write() {
      return notImplemented("write");
    },
    writeFile: function writeFile(fileName, contents) {
      files.set(fileName, contents);
    },
    deleteFile: function deleteFile(fileName) {
      files["delete"](fileName);
    }
  };
}
function createFSBackedSystem(files, _projectRoot, ts3, tsLibDirectory) {
  var root4 = _projectRoot + "/vfs";
  var path = requirePath();
  var nodeSys = ts3.sys;
  var tsLib = tsLibDirectory != null ? tsLibDirectory : path.dirname(__require.resolve("typescript"));
  return {
    // @ts-ignore
    name: "fs-vfs",
    root: root4,
    args: [],
    createDirectory: function createDirectory() {
      return notImplemented("createDirectory");
    },
    // TODO: could make a real file tree
    directoryExists: audit("directoryExists", function(directory) {
      return Array.from(files.keys()).some(function(path2) {
        return path2.startsWith(directory);
      }) || nodeSys.directoryExists(directory);
    }),
    exit: nodeSys.exit,
    fileExists: audit("fileExists", function(fileName) {
      if (files.has(fileName)) return true;
      if (fileName.includes("tsconfig.json") || fileName.includes("tsconfig.json")) return false;
      if (fileName.startsWith("/lib")) {
        var tsLibName = tsLib + "/" + fileName.replace("/", "");
        return nodeSys.fileExists(tsLibName);
      }
      return nodeSys.fileExists(fileName);
    }),
    getCurrentDirectory: function getCurrentDirectory() {
      return root4;
    },
    getDirectories: nodeSys.getDirectories,
    getExecutingFilePath: function getExecutingFilePath() {
      return notImplemented("getExecutingFilePath");
    },
    readDirectory: audit("readDirectory", function() {
      if ((arguments.length <= 0 ? void 0 : arguments[0]) === "/") {
        return Array.from(files.keys());
      } else {
        return nodeSys.readDirectory.apply(nodeSys, arguments);
      }
    }),
    readFile: audit("readFile", function(fileName) {
      if (files.has(fileName)) return files.get(fileName);
      if (fileName.startsWith("/lib")) {
        var tsLibName = tsLib + "/" + fileName.replace("/", "");
        var result = nodeSys.readFile(tsLibName);
        if (!result) {
          var libs = nodeSys.readDirectory(tsLib);
          throw new Error("TSVFS: A request was made for " + tsLibName + " but there wasn't a file found in the file map. You likely have a mismatch in the compiler options for the CDN download vs the compiler program. Existing Libs: " + libs + ".");
        }
        return result;
      }
      return nodeSys.readFile(fileName);
    }),
    resolvePath: function resolvePath(path2) {
      if (files.has(path2)) return path2;
      return nodeSys.resolvePath(path2);
    },
    newLine: "\n",
    useCaseSensitiveFileNames: true,
    write: function write() {
      return notImplemented("write");
    },
    writeFile: function writeFile(fileName, contents) {
      files.set(fileName, contents);
    },
    deleteFile: function deleteFile(fileName) {
      files["delete"](fileName);
    },
    realpath: nodeSys.realpath
  };
}
function createVirtualCompilerHost(sys, compilerOptions, ts3) {
  var sourceFiles = /* @__PURE__ */ new Map();
  var save = function save2(sourceFile) {
    sourceFiles.set(sourceFile.fileName, sourceFile);
    return sourceFile;
  };
  var vHost = {
    compilerHost: _extends({}, sys, {
      getCanonicalFileName: function getCanonicalFileName(fileName) {
        return fileName;
      },
      getDefaultLibFileName: function getDefaultLibFileName() {
        return "/" + ts3.getDefaultLibFileName(compilerOptions);
      },
      // '/lib.d.ts',
      // getDefaultLibLocation: () => '/',
      getNewLine: function getNewLine() {
        return sys.newLine;
      },
      getSourceFile: function getSourceFile(fileName, languageVersionOrOptions) {
        var _ref;
        return sourceFiles.get(fileName) || save(ts3.createSourceFile(fileName, sys.readFile(fileName), (_ref = languageVersionOrOptions != null ? languageVersionOrOptions : compilerOptions.target) != null ? _ref : defaultCompilerOptions(ts3).target, false));
      },
      useCaseSensitiveFileNames: function useCaseSensitiveFileNames() {
        return sys.useCaseSensitiveFileNames;
      }
    }),
    updateFile: function updateFile(sourceFile) {
      var alreadyExists = sourceFiles.has(sourceFile.fileName);
      sys.writeFile(sourceFile.fileName, sourceFile.text);
      sourceFiles.set(sourceFile.fileName, sourceFile);
      return alreadyExists;
    },
    deleteFile: function deleteFile(sourceFile) {
      var alreadyExists = sourceFiles.has(sourceFile.fileName);
      sourceFiles["delete"](sourceFile.fileName);
      sys.deleteFile(sourceFile.fileName);
      return alreadyExists;
    }
  };
  return vHost;
}
function createVirtualLanguageServiceHost(sys, rootFiles, compilerOptions, ts3, customTransformers) {
  var fileNames = [].concat(rootFiles);
  var _createVirtualCompile = createVirtualCompilerHost(sys, compilerOptions, ts3), compilerHost = _createVirtualCompile.compilerHost, _updateFile2 = _createVirtualCompile.updateFile, _deleteFile2 = _createVirtualCompile.deleteFile;
  var fileVersions = /* @__PURE__ */ new Map();
  var projectVersion = 0;
  var languageServiceHost = _extends({}, compilerHost, {
    getProjectVersion: function getProjectVersion() {
      return projectVersion.toString();
    },
    getCompilationSettings: function getCompilationSettings() {
      return compilerOptions;
    },
    getCustomTransformers: function getCustomTransformers() {
      return customTransformers;
    },
    // A couple weeks of 4.8 TypeScript nightlies had a bug where the Program's
    // list of files was just a reference to the array returned by this host method,
    // which means mutations by the host that ought to result in a new Program being
    // created were not detected, since the old list of files and the new list of files
    // were in fact a reference to the same underlying array. That was fixed in
    // https://github.com/microsoft/TypeScript/pull/49813, but since the twoslash runner
    // is used in bisecting for changes, it needs to guard against being busted in that
    // couple-week period, so we defensively make a slice here.
    getScriptFileNames: function getScriptFileNames() {
      return fileNames.slice();
    },
    getScriptSnapshot: function getScriptSnapshot(fileName) {
      var contents = sys.readFile(fileName);
      if (contents && typeof contents === "string") {
        return ts3.ScriptSnapshot.fromString(contents);
      }
      return;
    },
    getScriptVersion: function getScriptVersion(fileName) {
      return fileVersions.get(fileName) || "0";
    },
    writeFile: sys.writeFile
  });
  var lsHost = {
    languageServiceHost,
    updateFile: function updateFile(sourceFile) {
      projectVersion++;
      fileVersions.set(sourceFile.fileName, projectVersion.toString());
      if (!fileNames.includes(sourceFile.fileName)) {
        fileNames.push(sourceFile.fileName);
      }
      _updateFile2(sourceFile);
    },
    deleteFile: function deleteFile(sourceFile) {
      projectVersion++;
      fileVersions.set(sourceFile.fileName, projectVersion.toString());
      var index2 = fileNames.indexOf(sourceFile.fileName);
      if (index2 !== -1) {
        fileNames.splice(index2, 1);
      }
      _deleteFile2(sourceFile);
    }
  };
  return lsHost;
}
var requirePath = function requirePath2() {
  return __require(String.fromCharCode(112, 97, 116, 104));
};

// node_modules/twoslash-protocol/dist/index.mjs
function isInRange(index2, range3, inclusive = true) {
  if (inclusive)
    return range3[0] <= index2 && index2 <= range3[1];
  else
    return range3[0] < index2 && index2 < range3[1];
}
function isInRanges(index2, ranges, inclusive = true) {
  return ranges.find((range3) => isInRange(index2, range3, inclusive));
}
function mergeRanges(ranges) {
  ranges.sort((a, b) => a[0] - b[0]);
  const merged = [];
  for (const range3 of ranges) {
    const last = merged[merged.length - 1];
    if (last && last[1] >= range3[0])
      last[1] = Math.max(last[1], range3[1]);
    else
      merged.push(range3);
  }
  return merged;
}
function splitLines2(code3, preserveEnding = false) {
  var _a;
  const parts = code3.split(/(\r?\n)/g);
  let index2 = 0;
  const lines = [];
  for (let i = 0; i < parts.length; i += 2) {
    const line = preserveEnding ? parts[i] + (parts[i + 1] || "") : parts[i];
    lines.push([line, index2]);
    index2 += parts[i].length;
    index2 += ((_a = parts[i + 1]) == null ? void 0 : _a.length) || 0;
  }
  return lines;
}
function createPositionConverter2(code3) {
  const lines = splitLines2(code3, true).map(([line]) => line);
  function indexToPos(index2) {
    let character = index2;
    let line = 0;
    for (const lineText of lines) {
      if (character < lineText.length)
        break;
      character -= lineText.length;
      line++;
    }
    return { line, character };
  }
  function posToIndex(line, character) {
    let index2 = 0;
    for (let i = 0; i < line; i++)
      index2 += lines[i].length;
    index2 += character;
    return index2;
  }
  return {
    lines,
    indexToPos,
    posToIndex
  };
}
function removeCodeRanges(code3, removals, nodes) {
  const ranges = mergeRanges(removals).sort((a, b) => b[0] - a[0]);
  let outputCode = code3;
  for (const remove2 of ranges) {
    const removalLength = remove2[1] - remove2[0];
    outputCode = outputCode.slice(0, remove2[0]) + outputCode.slice(remove2[1]);
    nodes == null ? void 0 : nodes.forEach((node2) => {
      if (node2.start + node2.length <= remove2[0])
        return void 0;
      else if (node2.start < remove2[1])
        node2.start = -1;
      else
        node2.start -= removalLength;
    });
  }
  return {
    code: outputCode,
    removals: ranges,
    nodes
  };
}
function resolveNodePositions(nodes, options) {
  const indexToPos = typeof options === "string" ? createPositionConverter2(options).indexToPos : options;
  const resolved = nodes.filter((node2) => node2.start >= 0).sort((a, b) => a.start - b.start || a.type.localeCompare(b.type));
  resolved.forEach((node2) => Object.assign(node2, indexToPos(node2.start)));
  return resolved;
}

// node_modules/twoslash/dist/shared/twoslash.a8564bda.mjs
var defaultCompilerOptions3 = {
  strict: true,
  module: 99,
  target: 99,
  allowJs: true,
  skipDefaultLibCheck: true,
  skipLibCheck: true,
  moduleDetection: 3
};
var defaultHandbookOptions = {
  errors: [],
  noErrors: false,
  noErrorsCutted: false,
  noErrorValidation: false,
  noStaticSemanticInfo: false,
  showEmit: false,
  showEmittedFile: void 0,
  keepNotations: false
};
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key2, value) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField3 = (obj, key2, value) => {
  __defNormalProp2(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var TwoslashError = class extends Error {
  constructor(title, description, recommendation, code3) {
    let message = `
## ${title}

${description}
`;
    if (recommendation)
      message += `
${recommendation}`;
    if (code3)
      message += `
${code3}`;
    super(message);
    __publicField3(this, "title");
    __publicField3(this, "description");
    __publicField3(this, "recommendation");
    __publicField3(this, "code");
    this.title = title;
    this.description = description;
    this.recommendation = recommendation;
    this.code = code3;
  }
};
var defaults = Object.freeze({
  ignoreUnknown: false,
  respectType: false,
  respectFunctionNames: false,
  respectFunctionProperties: false,
  unorderedObjects: true,
  unorderedArrays: false,
  unorderedSets: false,
  excludeKeys: void 0,
  excludeValues: void 0,
  replacer: void 0
});
function objectHash(object, options) {
  if (options) {
    options = { ...defaults, ...options };
  } else {
    options = defaults;
  }
  const hasher = createHasher(options);
  hasher.dispatch(object);
  return hasher.toString();
}
var defaultPrototypesKeys = Object.freeze([
  "prototype",
  "__proto__",
  "constructor"
]);
function createHasher(options) {
  let buff = "";
  let context = /* @__PURE__ */ new Map();
  const write = (str) => {
    buff += str;
  };
  return {
    toString() {
      return buff;
    },
    getContext() {
      return context;
    },
    dispatch(value) {
      if (options.replacer) {
        value = options.replacer(value);
      }
      const type = value === null ? "null" : typeof value;
      return this[type](value);
    },
    object(object) {
      if (object && typeof object.toJSON === "function") {
        return this.object(object.toJSON());
      }
      const objString = Object.prototype.toString.call(object);
      let objType = "";
      const objectLength = objString.length;
      if (objectLength < 10) {
        objType = "unknown:[" + objString + "]";
      } else {
        objType = objString.slice(8, objectLength - 1);
      }
      objType = objType.toLowerCase();
      let objectNumber = null;
      if ((objectNumber = context.get(object)) === void 0) {
        context.set(object, context.size);
      } else {
        return this.dispatch("[CIRCULAR:" + objectNumber + "]");
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
        write("buffer:");
        return write(object.toString("utf8"));
      }
      if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
        if (this[objType]) {
          this[objType](object);
        } else if (!options.ignoreUnknown) {
          this.unkown(object, objType);
        }
      } else {
        let keys2 = Object.keys(object);
        if (options.unorderedObjects) {
          keys2 = keys2.sort();
        }
        let extraKeys = [];
        if (options.respectType !== false && !isNativeFunction(object)) {
          extraKeys = defaultPrototypesKeys;
        }
        if (options.excludeKeys) {
          keys2 = keys2.filter((key2) => {
            return !options.excludeKeys(key2);
          });
          extraKeys = extraKeys.filter((key2) => {
            return !options.excludeKeys(key2);
          });
        }
        write("object:" + (keys2.length + extraKeys.length) + ":");
        const dispatchForKey = (key2) => {
          this.dispatch(key2);
          write(":");
          if (!options.excludeValues) {
            this.dispatch(object[key2]);
          }
          write(",");
        };
        for (const key2 of keys2) {
          dispatchForKey(key2);
        }
        for (const key2 of extraKeys) {
          dispatchForKey(key2);
        }
      }
    },
    array(arr, unordered) {
      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;
      write("array:" + arr.length + ":");
      if (!unordered || arr.length <= 1) {
        for (const entry of arr) {
          this.dispatch(entry);
        }
        return;
      }
      const contextAdditions = /* @__PURE__ */ new Map();
      const entries = arr.map((entry) => {
        const hasher = createHasher(options);
        hasher.dispatch(entry);
        for (const [key2, value] of hasher.getContext()) {
          contextAdditions.set(key2, value);
        }
        return hasher.toString();
      });
      context = contextAdditions;
      entries.sort();
      return this.array(entries, false);
    },
    date(date) {
      return write("date:" + date.toJSON());
    },
    symbol(sym) {
      return write("symbol:" + sym.toString());
    },
    unkown(value, type) {
      write(type);
      if (!value) {
        return;
      }
      write(":");
      if (value && typeof value.entries === "function") {
        return this.array(
          Array.from(value.entries()),
          true
          /* ordered */
        );
      }
    },
    error(err) {
      return write("error:" + err.toString());
    },
    boolean(bool) {
      return write("bool:" + bool);
    },
    string(string4) {
      write("string:" + string4.length + ":");
      write(string4);
    },
    function(fn) {
      write("fn:");
      if (isNativeFunction(fn)) {
        this.dispatch("[native]");
      } else {
        this.dispatch(fn.toString());
      }
      if (options.respectFunctionNames !== false) {
        this.dispatch("function-name:" + String(fn.name));
      }
      if (options.respectFunctionProperties) {
        this.object(fn);
      }
    },
    number(number2) {
      return write("number:" + number2);
    },
    xml(xml2) {
      return write("xml:" + xml2.toString());
    },
    null() {
      return write("Null");
    },
    undefined() {
      return write("Undefined");
    },
    regexp(regex) {
      return write("regex:" + regex.toString());
    },
    uint8array(arr) {
      write("uint8array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    uint8clampedarray(arr) {
      write("uint8clampedarray:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    int8array(arr) {
      write("int8array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    uint16array(arr) {
      write("uint16array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    int16array(arr) {
      write("int16array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    uint32array(arr) {
      write("uint32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    int32array(arr) {
      write("int32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    float32array(arr) {
      write("float32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    float64array(arr) {
      write("float64array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    arraybuffer(arr) {
      write("arraybuffer:");
      return this.dispatch(new Uint8Array(arr));
    },
    url(url) {
      return write("url:" + url.toString());
    },
    map(map) {
      write("map:");
      const arr = [...map];
      return this.array(arr, options.unorderedSets !== false);
    },
    set(set) {
      write("set:");
      const arr = [...set];
      return this.array(arr, options.unorderedSets !== false);
    },
    file(file) {
      write("file:");
      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);
    },
    blob() {
      if (options.ignoreUnknown) {
        return write("[blob]");
      }
      throw new Error(
        'Hashing Blob objects is currently not supported\nUse "options.replacer" or "options.ignoreUnknown"\n'
      );
    },
    domwindow() {
      return write("domwindow");
    },
    bigint(number2) {
      return write("bigint:" + number2.toString());
    },
    /* Node.js standard native objects */
    process() {
      return write("process");
    },
    timer() {
      return write("timer");
    },
    pipe() {
      return write("pipe");
    },
    tcp() {
      return write("tcp");
    },
    udp() {
      return write("udp");
    },
    tty() {
      return write("tty");
    },
    statwatcher() {
      return write("statwatcher");
    },
    securecontext() {
      return write("securecontext");
    },
    connection() {
      return write("connection");
    },
    zlib() {
      return write("zlib");
    },
    context() {
      return write("context");
    },
    nodescript() {
      return write("nodescript");
    },
    httpparser() {
      return write("httpparser");
    },
    dataview() {
      return write("dataview");
    },
    signal() {
      return write("signal");
    },
    fsevent() {
      return write("fsevent");
    },
    tlswrap() {
      return write("tlswrap");
    }
  };
}
var nativeFunc = "[native code] }";
var nativeFuncLength = nativeFunc.length;
function isNativeFunction(f) {
  if (typeof f !== "function") {
    return false;
  }
  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;
}
var reConfigBoolean = /^\/\/\s?@(\w+)$/gm;
var reConfigValue = /^\/\/\s?@(\w+):\s?(.+)$/gm;
var reAnnonateMarkers = /^\s*\/\/\s*\^(\?|\||\^+)( .*)?$/gm;
var reCutBefore = /^[\t\v\f ]*\/\/\s?---cut(-before)?---\r?\n/gm;
var reCutAfter = /^[\t\v\f ]*\/\/\s?---cut-after---$/gm;
var reCutStart = /^[\t\v\f ]*\/\/\s?---cut-start---$/gm;
var reCutEnd = /^[\t\v\f ]*\/\/\s?---cut-end---\r?\n/gm;
var reFilenamesMakers = /^[\t\v\f ]*\/\/\s?@filename: (.+)$/gm;
function getObjectHash(obj) {
  return objectHash(obj);
}
function parsePrimitive(value, type) {
  if (typeof value === type)
    return value;
  switch (type) {
    case "number":
      return +value;
    case "string":
      return value;
    case "boolean":
      return value.toLowerCase() === "true" || value.length === 0;
  }
  throw new TwoslashError(
    `Unknown primitive value in compiler flag`,
    `The only recognized primitives are number, string and boolean. Got ${type} with ${value}.`,
    `This is likely a typo.`
  );
}
function typesToExtension(types2) {
  const map = {
    js: "js",
    javascript: "js",
    ts: "ts",
    typescript: "ts",
    tsx: "tsx",
    jsx: "jsx",
    json: "json",
    jsn: "json",
    map: "json",
    mts: "ts",
    cts: "ts",
    mjs: "js",
    cjs: "js"
  };
  if (map[types2])
    return map[types2];
  throw new TwoslashError(
    `Unknown TypeScript extension given to Twoslash`,
    `Received ${types2} but Twoslash only accepts: ${Object.keys(map)} `,
    ``
  );
}
function getIdentifierTextSpans(ts3, sourceFile, fileOffset) {
  const textSpans = [];
  checkChildren(sourceFile);
  return textSpans;
  function checkChildren(node2) {
    ts3.forEachChild(node2, (child) => {
      if (ts3.isIdentifier(child)) {
        const text6 = child.getText(sourceFile);
        const start = child.getStart(sourceFile, false) + fileOffset;
        const end = start + text6.length;
        textSpans.push([start, end, text6]);
      }
      checkChildren(child);
    });
  }
}
function getOptionValueFromMap(name, key2, optMap) {
  const result = optMap.get(key2.toLowerCase());
  if (result === void 0) {
    const keys2 = Array.from(optMap.keys());
    throw new TwoslashError(
      `Invalid inline compiler value`,
      `Got ${key2} for ${name} but it is not a supported value by the TS compiler.`,
      `Allowed values: ${keys2.join(",")}`
    );
  }
  return result;
}
function splitFiles(code3, defaultFileName, root4) {
  const matches2 = Array.from(code3.matchAll(reFilenamesMakers));
  const allFilenames = matches2.map((match) => match[1].trimEnd());
  let currentFileName = allFilenames.includes(defaultFileName) ? "__index__.ts" : defaultFileName;
  const files = [];
  let index2 = 0;
  for (const match of matches2) {
    const offset = match.index;
    const content3 = code3.slice(index2, offset);
    if (content3) {
      files.push({
        offset: index2,
        filename: currentFileName,
        filepath: root4 + currentFileName,
        content: content3,
        extension: getExtension(currentFileName)
      });
    }
    currentFileName = match[1].trimEnd();
    index2 = offset;
  }
  if (index2 < code3.length) {
    const content3 = code3.slice(index2);
    files.push({
      offset: index2,
      filename: currentFileName,
      filepath: root4 + currentFileName,
      content: content3,
      extension: getExtension(currentFileName)
    });
  }
  return files;
}
function getExtension(fileName) {
  return fileName.split(".").pop();
}
function parseFlag(name, value, start, end, customTags, tsOptionDeclarations) {
  if (customTags.includes(name)) {
    return {
      type: "tag",
      name,
      value,
      start,
      end
    };
  }
  const compilerDecl = tsOptionDeclarations.find((d) => d.name.toLocaleLowerCase() === name.toLocaleLowerCase());
  if (compilerDecl) {
    switch (compilerDecl.type) {
      case "number":
      case "string":
      case "boolean":
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: parsePrimitive(value, compilerDecl.type),
          start,
          end
        };
      case "list": {
        const elementType = compilerDecl.element.type;
        const strings = value.split(",");
        const resolved = typeof elementType === "string" ? strings.map((v) => parsePrimitive(v, elementType)) : strings.map((v) => getOptionValueFromMap(compilerDecl.name, v, elementType));
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: resolved,
          start,
          end
        };
      }
      case "object":
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: JSON.parse(value),
          start,
          end
        };
      default: {
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: getOptionValueFromMap(compilerDecl.name, value, compilerDecl.type),
          start,
          end
        };
      }
    }
  }
  if (Object.keys(defaultHandbookOptions).includes(name)) {
    if (name === "errors" && typeof value === "string")
      value = value.split(" ").map(Number);
    if (name === "noErrors" && typeof value === "string") {
      if (value === "true")
        value = true;
      else if (value === "false")
        value = false;
      else
        value = value.split(" ").map(Number);
    }
    return {
      type: "handbookOptions",
      name,
      value,
      start,
      end
    };
  }
  return {
    type: "unknown",
    name,
    value,
    start,
    end
  };
}
function findFlagNotations(code3, customTags, tsOptionDeclarations) {
  const flagNotations = [];
  Array.from(code3.matchAll(reConfigBoolean)).forEach((match) => {
    const index2 = match.index;
    const name = match[1];
    flagNotations.push(
      parseFlag(name, true, index2, index2 + match[0].length + 1, customTags, tsOptionDeclarations)
    );
  });
  Array.from(code3.matchAll(reConfigValue)).forEach((match) => {
    const name = match[1];
    if (name === "filename")
      return;
    const index2 = match.index;
    const value = match[2];
    flagNotations.push(
      parseFlag(name, value, index2, index2 + match[0].length + 1, customTags, tsOptionDeclarations)
    );
  });
  return flagNotations;
}
function findCutNotations(code3, meta) {
  const removals = [];
  const cutBefore = [...code3.matchAll(reCutBefore)];
  const cutAfter = [...code3.matchAll(reCutAfter)];
  const cutStart = [...code3.matchAll(reCutStart)];
  const cutEnd = [...code3.matchAll(reCutEnd)];
  if (cutBefore.length) {
    const last = cutBefore[cutBefore.length - 1];
    removals.push([0, last.index + last[0].length]);
  }
  if (cutAfter.length) {
    const first = cutAfter[0];
    removals.push([first.index, code3.length]);
  }
  if (cutStart.length !== cutEnd.length) {
    throw new TwoslashError(
      `Mismatched cut markers`,
      `You have ${cutStart.length} cut-starts and ${cutEnd.length} cut-ends`,
      `Make sure you have a matching pair for each.`
    );
  }
  for (let i = 0; i < cutStart.length; i++) {
    const start = cutStart[i];
    const end = cutEnd[i];
    if (start.index > end.index) {
      throw new TwoslashError(
        `Mismatched cut markers`,
        `You have a cut-start at ${start.index} which is after the cut-end at ${end.index}`,
        `Make sure you have a matching pair for each.`
      );
    }
    removals.push([start.index, end.index + end[0].length]);
  }
  if (meta)
    meta.removals.push(...removals);
  return removals;
}
function findQueryMarkers(code3, meta, pc) {
  if (code3.includes("//")) {
    const linesQuery = /* @__PURE__ */ new Set();
    Array.from(code3.matchAll(reAnnonateMarkers)).forEach((match) => {
      var _a;
      const type = match[1];
      const index2 = match.index;
      meta.removals.push([index2, index2 + match[0].length + 1]);
      const markerIndex = match[0].indexOf("^");
      const pos = pc.indexToPos(index2 + markerIndex);
      let targetLine = pos.line - 1;
      while (linesQuery.has(targetLine) && targetLine >= 0)
        targetLine -= 1;
      const targetIndex = pc.posToIndex(targetLine, pos.character);
      if (type === "?") {
        meta.positionQueries.push(targetIndex);
      } else if (type === "|") {
        meta.positionCompletions.push(targetIndex);
      } else {
        const markerLength = match[0].lastIndexOf("^") - markerIndex + 1;
        meta.positionHighlights.push([
          targetIndex,
          targetIndex + markerLength,
          (_a = match[2]) == null ? void 0 : _a.trim()
        ]);
      }
      linesQuery.add(pos.line);
    });
  }
  return meta;
}
function removeTsExtension(filename) {
  const sansMapOrDTS = filename.replace(/\.map$/, "").replace(/\.d\.ts$/, ".ts").replace(/\.map$/, "");
  return sansMapOrDTS.replace(/\.[^/.]+$/, "");
}
var flagKeys = [
  "all",
  "allowArbitraryExtensions",
  "allowImportingTsExtensions",
  "allowJs",
  "allowSyntheticDefaultImports",
  "allowUmdGlobalAccess",
  "allowUnreachableCode",
  "allowUnusedLabels",
  "alwaysStrict",
  "assumeChangesOnlyAffectDirectDependencies",
  "baseUrl",
  "build",
  "charset",
  "checkJs",
  "composite",
  "customConditions",
  "declaration",
  "declarationDir",
  "declarationMap",
  "diagnostics",
  "disableReferencedProjectLoad",
  "disableSizeLimit",
  "disableSolutionSearching",
  "disableSourceOfProjectReferenceRedirect",
  "downlevelIteration",
  "emitBOM",
  "emitDeclarationOnly",
  "emitDecoratorMetadata",
  "errors",
  "esModuleInterop",
  "exactOptionalPropertyTypes",
  "experimentalDecorators",
  "explainFiles",
  "extendedDiagnostics",
  "forceConsistentCasingInFileNames",
  "generateCpuProfile",
  "generateTrace",
  "help",
  "help",
  "ignoreDeprecations",
  "importHelpers",
  "importsNotUsedAsValues",
  "incremental",
  "init",
  "inlineSourceMap",
  "inlineSources",
  "isolatedModules",
  "jsx",
  "jsxFactory",
  "jsxFragmentFactory",
  "jsxImportSource",
  "keepNotations",
  "keyofStringsOnly",
  "lib",
  "listEmittedFiles",
  "listFiles",
  "listFilesOnly",
  "locale",
  "mapRoot",
  "maxNodeModuleJsDepth",
  "module",
  "moduleDetection",
  "moduleResolution",
  "moduleSuffixes",
  "newLine",
  "noEmit",
  "noEmitHelpers",
  "noEmitOnError",
  "noErrorTruncation",
  "noErrorValidation",
  "noErrors",
  "noErrorsCutted",
  "noFallthroughCasesInSwitch",
  "noImplicitAny",
  "noImplicitOverride",
  "noImplicitReturns",
  "noImplicitThis",
  "noImplicitUseStrict",
  "noLib",
  "noPropertyAccessFromIndexSignature",
  "noResolve",
  "noStaticSemanticInfo",
  "noStrictGenericChecks",
  "noUncheckedIndexedAccess",
  "noUnusedLocals",
  "noUnusedParameters",
  "out",
  "outDir",
  "outFile",
  "paths",
  "plugins",
  "preserveConstEnums",
  "preserveSymlinks",
  "preserveValueImports",
  "preserveWatchOutput",
  "pretty",
  "project",
  "reactNamespace",
  "removeComments",
  "resolveJsonModule",
  "resolvePackageJsonExports",
  "resolvePackageJsonImports",
  "rootDir",
  "rootDirs",
  "showConfig",
  "showEmit",
  "showEmittedFile",
  "skipDefaultLibCheck",
  "skipLibCheck",
  "sourceMap",
  "sourceRoot",
  "strict",
  "strictBindCallApply",
  "strictFunctionTypes",
  "strictNullChecks",
  "strictPropertyInitialization",
  "stripInternal",
  "suppressExcessPropertyErrors",
  "suppressImplicitAnyIndexErrors",
  "target",
  "traceResolution",
  "tsBuildInfoFile",
  "typeRoots",
  "types",
  "useDefineForClassFields",
  "useUnknownInCatchVariables",
  "verbatimModuleSyntax",
  "version",
  "watch"
];
function removeTwoslashNotations(code3, customTags) {
  const meta = {
    removals: []
  };
  const tags = [
    ...customTags ?? [],
    ...flagKeys
  ];
  Array.from(code3.matchAll(reConfigBoolean)).forEach((match) => {
    if (!tags.includes(match[1]))
      return;
    meta.removals.push([match.index, match.index + match[0].length + 1]);
  });
  Array.from(code3.matchAll(reConfigValue)).forEach((match) => {
    if (!tags.includes(match[1]))
      return;
    meta.removals.push([match.index, match.index + match[0].length + 1]);
  });
  findCutNotations(code3, meta);
  Array.from(code3.matchAll(reAnnonateMarkers)).forEach((match) => {
    const index2 = match.index;
    meta.removals.push([index2, index2 + match[0].length + 1]);
  });
  return removeCodeRanges(code3, meta.removals).code;
}

// node_modules/twoslash/dist/core.mjs
function validateCodeForErrors(relevantErrors, handbookOptions, vfsRoot) {
  const unspecifiedErrors = relevantErrors.filter((e) => e.code && !handbookOptions.errors.includes(e.code));
  const errorsFound = Array.from(new Set(unspecifiedErrors.map((e) => e.code))).join(" ");
  if (unspecifiedErrors.length) {
    const errorsToShow = new Set(relevantErrors.map((e) => e.code));
    const codeToAdd = `// @errors: ${Array.from(errorsToShow).join(" ")}`;
    const missing = handbookOptions.errors.length ? `
The existing annotation specified ${handbookOptions.errors.join(" ")}` : `
Expected: ${codeToAdd}`;
    const filesToErrors = {};
    const noFiles = [];
    unspecifiedErrors.forEach((d) => {
      var _a;
      const fileRef = (_a = d.filename) == null ? void 0 : _a.replace(vfsRoot, "");
      if (!fileRef) {
        noFiles.push(d);
      } else {
        const existing = filesToErrors[fileRef];
        if (existing)
          existing.push(d);
        else
          filesToErrors[fileRef] = [d];
      }
    });
    const showDiagnostics = (title, diags) => {
      return `${title}
  ${diags.map((e) => `[${e.code}] ${e.start} - ${e.text}`).join("\n  ")}`;
    };
    const innerDiags = [];
    if (noFiles.length)
      innerDiags.push(showDiagnostics("Ambient Errors", noFiles));
    Object.keys(filesToErrors).forEach((filepath) => {
      innerDiags.push(showDiagnostics(filepath, filesToErrors[filepath]));
    });
    const allMessages = innerDiags.join("\n\n");
    const newErr = new TwoslashError(
      `Errors were thrown in the sample, but not included in an error tag`,
      `These errors were not marked as being expected: ${errorsFound}. ${missing}`,
      `Compiler Errors:

${allMessages}`
    );
    throw newErr;
  }
}
function createTwoslasher(createOptions = {}) {
  const ts3 = createOptions.tsModule;
  const tsOptionDeclarations = ts3.optionDeclarations;
  const useFS = !!createOptions.fsMap;
  const _root = createOptions.vfsRoot.replace(/\\/g, "/");
  const vfs = createOptions.fsMap || /* @__PURE__ */ new Map();
  const system = useFS ? createSystem(vfs) : createCacheableFSBackedSystem(vfs, _root, ts3, createOptions.tsLibDirectory, createOptions.fsCache);
  const fsRoot = useFS ? "/" : `${_root}/`;
  const cache = createOptions.cache === false ? void 0 : createOptions.cache instanceof Map ? createOptions.cache : /* @__PURE__ */ new Map();
  function getEnv(compilerOptions) {
    if (!cache)
      return createVirtualTypeScriptEnvironment(system, [], ts3, compilerOptions, createOptions.customTransformers);
    const key2 = getObjectHash(compilerOptions);
    if (!(cache == null ? void 0 : cache.has(key2))) {
      const env2 = createVirtualTypeScriptEnvironment(system, [], ts3, compilerOptions, createOptions.customTransformers);
      cache == null ? void 0 : cache.set(key2, env2);
      return env2;
    }
    return cache.get(key2);
  }
  function twoslasher2(code3, extension2 = "ts", options = {}) {
    var _a, _b, _c, _d, _e, _f, _g;
    const meta = {
      extension: typesToExtension(extension2),
      compilerOptions: {
        ...defaultCompilerOptions3,
        baseUrl: fsRoot,
        ...createOptions.compilerOptions,
        ...options.compilerOptions
      },
      handbookOptions: {
        ...defaultHandbookOptions,
        ...createOptions.handbookOptions,
        ...options.handbookOptions
      },
      removals: [],
      flagNotations: [],
      virtualFiles: [],
      positionQueries: options.positionQueries || [],
      positionCompletions: options.positionCompletions || [],
      positionHighlights: options.positionHighlights || []
    };
    const {
      customTags = createOptions.customTags || [],
      shouldGetHoverInfo = createOptions.shouldGetHoverInfo || (() => true),
      filterNode = createOptions.filterNode,
      extraFiles = createOptions.extraFiles || {}
    } = options;
    const defaultFilename = `index.${meta.extension}`;
    let nodes = [];
    const isInRemoval = (index2) => index2 >= code3.length || index2 < 0 || isInRanges(index2, meta.removals, false);
    meta.flagNotations = findFlagNotations(code3, customTags, tsOptionDeclarations);
    for (const flag of meta.flagNotations) {
      switch (flag.type) {
        case "unknown":
          continue;
        case "compilerOptions":
          meta.compilerOptions[flag.name] = flag.value;
          break;
        case "handbookOptions":
          meta.handbookOptions[flag.name] = flag.value;
          break;
        case "tag":
          nodes.push({
            type: "tag",
            name: flag.name,
            start: flag.end,
            length: 0,
            text: flag.value
          });
          break;
      }
      meta.removals.push([flag.start, flag.end]);
    }
    if (!meta.handbookOptions.noErrorValidation) {
      const unknownFlags = meta.flagNotations.filter((i) => i.type === "unknown");
      if (unknownFlags.length) {
        throw new TwoslashError(
          `Unknown inline compiler flags`,
          `The following flags are either valid TSConfig nor handbook options:
${unknownFlags.map((i) => `@${i.name}`).join(", ")}`,
          `This is likely a typo, you can check all the compiler flags in the TSConfig reference, or check the additional Twoslash flags in the npm page for @typescript/twoslash.`
        );
      }
    }
    const env2 = getEnv(meta.compilerOptions);
    const ls = env2.languageService;
    const pc = createPositionConverter2(code3);
    findCutNotations(code3, meta);
    findQueryMarkers(code3, meta, pc);
    const supportedFileTyes = ["js", "jsx", "ts", "tsx"];
    meta.virtualFiles = splitFiles(code3, defaultFilename, fsRoot);
    const identifiersMap = /* @__PURE__ */ new Map();
    function getIdentifiersOfFile(file) {
      var _a2;
      if (!identifiersMap.has(file.filename)) {
        const source = env2.getSourceFile(file.filepath);
        identifiersMap.set(file.filename, getIdentifierTextSpans(ts3, source, file.offset - (((_a2 = file.prepend) == null ? void 0 : _a2.length) || 0)));
      }
      return identifiersMap.get(file.filename);
    }
    function getFileAtPosition(pos) {
      return meta.virtualFiles.find((i) => isInRange(pos, [i.offset, i.offset + i.content.length]));
    }
    function getQuickInfo(file, start, target) {
      var _a2, _b2;
      const quickInfo = ls.getQuickInfoAtPosition(file.filepath, getOffsetInFile(start, file));
      if (quickInfo && quickInfo.displayParts) {
        const text6 = quickInfo.displayParts.map((dp) => dp.text).join("");
        const docs = ((_a2 = quickInfo.documentation) == null ? void 0 : _a2.map((d) => d.text).join("\n")) || void 0;
        const tags = (_b2 = quickInfo.tags) == null ? void 0 : _b2.map((t) => {
          var _a3;
          return [t.name, (_a3 = t.text) == null ? void 0 : _a3.map((i) => i.text).join("")];
        });
        return {
          type: "hover",
          text: text6,
          docs,
          tags,
          start,
          length: target.length,
          target
        };
      }
    }
    Object.entries(extraFiles).forEach(([filename, content3]) => {
      if (!meta.virtualFiles.find((i) => i.filename === filename)) {
        env2.createFile(
          fsRoot + filename,
          typeof content3 === "string" ? content3 : (content3.prepend || "") + (content3.append || "")
        );
      }
    });
    for (const file of meta.virtualFiles) {
      if (supportedFileTyes.includes(file.extension) || file.extension === "json" && meta.compilerOptions.resolveJsonModule) {
        file.supportLsp = true;
        const extra = extraFiles[file.filename];
        if (extra && typeof extra !== "string") {
          file.append = extra.append;
          file.prepend = extra.prepend;
        }
        env2.createFile(file.filepath, getFileContent(file));
        getIdentifiersOfFile(file);
      }
    }
    function getOffsetInFile(offset, file) {
      var _a2;
      return offset - file.offset + (((_a2 = file.prepend) == null ? void 0 : _a2.length) || 0);
    }
    function getFileContent(file) {
      return (file.prepend || "") + file.content + (file.append || "");
    }
    if (!meta.handbookOptions.showEmit) {
      for (const file of meta.virtualFiles) {
        if (!file.supportLsp)
          continue;
        if (!meta.handbookOptions.noStaticSemanticInfo) {
          const identifiers = getIdentifiersOfFile(file);
          for (const [start, _end, target] of identifiers) {
            if (isInRemoval(start))
              continue;
            if (!shouldGetHoverInfo(target, start, file.filename))
              continue;
            const node2 = getQuickInfo(file, start, target);
            if (node2)
              nodes.push(node2);
          }
        }
      }
      for (const query of meta.positionQueries) {
        if (isInRemoval(query)) {
          throw new TwoslashError(
            `Invalid quick info query`,
            `The request on line ${pc.indexToPos(query).line + 2} for quickinfo via ^? is in a removal range.`,
            `This is likely that the positioning is off.`
          );
        }
        const file = getFileAtPosition(query);
        const identifiers = getIdentifiersOfFile(file);
        const id = identifiers.find((i) => isInRange(query, i));
        let node2;
        if (id)
          node2 = getQuickInfo(file, id[0], id[2]);
        if (node2) {
          node2.type = "query";
          nodes.push(node2);
        } else {
          const pos = pc.indexToPos(query);
          throw new TwoslashError(
            `Invalid quick info query`,
            `The request on line ${pos.line + 2} in ${file.filename} for quickinfo via ^? returned nothing from the compiler.`,
            `This is likely that the positioning is off.`
          );
        }
      }
      for (const highlight of meta.positionHighlights) {
        nodes.push({
          type: "highlight",
          start: highlight[0],
          length: highlight[1] - highlight[0],
          text: highlight[2]
        });
      }
      for (const target of meta.positionCompletions) {
        const file = getFileAtPosition(target);
        if (isInRemoval(target) || !file) {
          throw new TwoslashError(
            `Invalid completion query`,
            `The request on line ${pc.indexToPos(target).line + 2} for completions via ^| is in a removal range.`,
            `This is likely that the positioning is off.`
          );
        }
        let prefix = ((_a = code3.slice(0, target).match(/[$\w]+$/)) == null ? void 0 : _a[0]) || "";
        prefix = prefix.split(".").pop();
        let completions = [];
        if (prefix) {
          const result = ls.getCompletionsAtPosition(file.filepath, getOffsetInFile(target, file) - 1, {
            triggerKind: 1,
            includeCompletionsForModuleExports: false
          });
          completions = (result == null ? void 0 : result.entries) ?? [];
          prefix = ((_b = completions[0]) == null ? void 0 : _b.replacementSpan) && code3.slice(
            completions[0].replacementSpan.start,
            target
          ) || prefix;
          completions = completions.filter((i) => i.name.startsWith(prefix));
        } else {
          prefix = code3[target - 1];
          if (prefix) {
            const result = ls.getCompletionsAtPosition(file.filepath, getOffsetInFile(target, file), {
              triggerKind: 2,
              triggerCharacter: prefix,
              includeCompletionsForModuleExports: false
            });
            completions = (result == null ? void 0 : result.entries) ?? [];
            if ((_d = (_c = completions[0]) == null ? void 0 : _c.replacementSpan) == null ? void 0 : _d.length) {
              prefix = code3.slice(
                completions[0].replacementSpan.start,
                target
              ) || prefix;
              const newCompletions = completions.filter((i) => i.name.startsWith(prefix));
              if (newCompletions.length)
                completions = newCompletions;
            }
          }
        }
        if (!(completions == null ? void 0 : completions.length) && !meta.handbookOptions.noErrorValidation) {
          const pos = pc.indexToPos(target);
          throw new TwoslashError(
            `Invalid completion query`,
            `The request on line ${pos.line} in ${file.filename} for completions via ^| returned no completions from the compiler. (prefix: ${prefix})`,
            `This is likely that the positioning is off.`
          );
        }
        nodes.push({
          type: "completion",
          start: target,
          length: 0,
          completions,
          completionsPrefix: prefix
        });
      }
    }
    let errorNodes = [];
    for (const file of meta.virtualFiles) {
      if (!file.supportLsp)
        continue;
      if (meta.handbookOptions.noErrors !== true) {
        env2.updateFile(file.filepath, getFileContent(file));
        const diagnostics = [
          ...ls.getSemanticDiagnostics(file.filepath),
          ...ls.getSyntacticDiagnostics(file.filepath)
        ];
        const ignores = Array.isArray(meta.handbookOptions.noErrors) ? meta.handbookOptions.noErrors : [];
        for (const diagnostic of diagnostics) {
          if (((_e = diagnostic.file) == null ? void 0 : _e.fileName) !== file.filepath)
            continue;
          if (ignores.includes(diagnostic.code))
            continue;
          const start = diagnostic.start + file.offset - (((_f = file.prepend) == null ? void 0 : _f.length) || 0);
          if (meta.handbookOptions.noErrorsCutted && isInRemoval(start))
            continue;
          errorNodes.push({
            type: "error",
            start,
            length: diagnostic.length,
            code: diagnostic.code,
            filename: file.filename,
            id: `err-${diagnostic.code}-${start}-${diagnostic.length}`,
            text: ts3.flattenDiagnosticMessageText(diagnostic.messageText, "\n"),
            level: diagnosticCategoryToErrorLevel(diagnostic.category)
          });
        }
      }
    }
    if (filterNode) {
      nodes = nodes.filter(filterNode);
      errorNodes = errorNodes.filter(filterNode);
    }
    nodes.push(...errorNodes);
    if (!meta.handbookOptions.noErrorValidation && errorNodes.length)
      validateCodeForErrors(errorNodes, meta.handbookOptions, fsRoot);
    let outputCode = code3;
    if (meta.handbookOptions.showEmit) {
      if (meta.handbookOptions.keepNotations) {
        throw new TwoslashError(
          `Option 'showEmit' cannot be used with 'keepNotations'`,
          "With `showEmit` enabled, the output will always be the emitted code",
          "Remove either option to continue"
        );
      }
      if (!meta.handbookOptions.keepNotations) {
        const { code: removedCode } = removeCodeRanges(outputCode, meta.removals);
        const files = splitFiles(removedCode, defaultFilename, fsRoot);
        for (const file of files)
          env2.updateFile(file.filepath, getFileContent(file));
      }
      const emitFilename = meta.handbookOptions.showEmittedFile ? meta.handbookOptions.showEmittedFile : meta.compilerOptions.jsx === 1 ? "index.jsx" : "index.js";
      let emitSource = (_g = meta.virtualFiles.find((i) => removeTsExtension(i.filename) === removeTsExtension(emitFilename))) == null ? void 0 : _g.filename;
      if (!emitSource && !meta.compilerOptions.outFile) {
        const allFiles = meta.virtualFiles.map((i) => i.filename).join(", ");
        throw new TwoslashError(
          `Could not find source file to show the emit for`,
          `Cannot find the corresponding **source** file: '${emitFilename}'`,
          `Looked for: ${emitSource} in the vfs - which contains: ${allFiles}`
        );
      }
      if (meta.compilerOptions.outFile)
        emitSource = meta.virtualFiles[0].filename;
      const output = ls.getEmitOutput(fsRoot + emitSource);
      const outfile = output.outputFiles.find((o) => o.name === fsRoot + emitFilename || o.name === emitFilename);
      if (!outfile) {
        const allFiles = output.outputFiles.map((o) => o.name).join(", ");
        throw new TwoslashError(
          `Cannot find the output file in the Twoslash VFS`,
          `Looking for ${emitFilename} in the Twoslash vfs after compiling`,
          `Looked for" ${fsRoot + emitFilename} in the vfs - which contains ${allFiles}.`
        );
      }
      outputCode = outfile.text;
      meta.extension = typesToExtension(getExtension(outfile.name));
      meta.removals.length = 0;
      nodes.length = 0;
    }
    if (!meta.handbookOptions.keepNotations) {
      const removed = removeCodeRanges(outputCode, meta.removals, nodes);
      outputCode = removed.code;
      nodes = removed.nodes;
      meta.removals = removed.removals;
    }
    const indexToPos = outputCode === code3 ? pc.indexToPos : createPositionConverter2(outputCode).indexToPos;
    const resolvedNodes = resolveNodePositions(nodes, indexToPos);
    for (const file of meta.virtualFiles)
      env2.createFile(file.filepath, "");
    for (const file of Object.keys(extraFiles))
      env2.createFile(fsRoot + file, "");
    return {
      code: outputCode,
      nodes: resolvedNodes,
      meta,
      get queries() {
        return this.nodes.filter((i) => i.type === "query");
      },
      get completions() {
        return this.nodes.filter((i) => i.type === "completion");
      },
      get errors() {
        return this.nodes.filter((i) => i.type === "error");
      },
      get highlights() {
        return this.nodes.filter((i) => i.type === "highlight");
      },
      get hovers() {
        return this.nodes.filter((i) => i.type === "hover");
      },
      get tags() {
        return this.nodes.filter((i) => i.type === "tag");
      }
    };
  }
  twoslasher2.getCacheMap = () => {
    return cache;
  };
  return twoslasher2;
}
function createCacheableFSBackedSystem(vfs, root4, ts3, tsLibDirectory, enableFsCache = true) {
  function withCache(fn) {
    const cache = /* @__PURE__ */ new Map();
    return (key2) => {
      const cached = cache.get(key2);
      if (cached !== void 0)
        return cached;
      const result = fn(key2);
      cache.set(key2, result);
      return result;
    };
  }
  const cachedReadFile = withCache(ts3.sys.readFile);
  const cachedTs = enableFsCache ? {
    ...ts3,
    sys: {
      ...ts3.sys,
      directoryExists: withCache(ts3.sys.directoryExists),
      fileExists: withCache(ts3.sys.fileExists),
      ...ts3.sys.realpath ? { realpath: withCache(ts3.sys.realpath) } : {},
      readFile(path, encoding) {
        if (encoding === void 0)
          return cachedReadFile(path);
        return ts3.sys.readFile(path, encoding);
      }
    }
  } : ts3;
  return {
    ...createFSBackedSystem(vfs, root4, cachedTs, tsLibDirectory),
    // To work with non-hoisted packages structure
    realpath(path) {
      var _a, _b;
      if (vfs.has(path))
        return path;
      return ((_b = (_a = cachedTs.sys).realpath) == null ? void 0 : _b.call(_a, path)) || path;
    }
  };
}
function diagnosticCategoryToErrorLevel(e) {
  switch (e) {
    case 0:
      return "warning";
    case 1:
      return "error";
    case 2:
      return "suggestion";
    case 3:
      return "message";
    default:
      return void 0;
  }
}

// node_modules/twoslash/dist/index.mjs
var cwd = typeof process !== "undefined" && typeof process.cwd === "function" ? process.cwd() : "";
function createTwoslasher2(opts) {
  return createTwoslasher({
    vfsRoot: cwd,
    tsModule: import_typescript.default,
    ...opts
  });
}

// node_modules/twoslash-vue/dist/index.mjs
var import_language_core = __toESM(require_language_core2(), 1);
var import_typescript2 = __toESM(require_typescript(), 1);
function createTwoslasher3(createOptions = {}) {
  const twoslasherBase = createTwoslasher2(createOptions);
  const cache = twoslasherBase.getCacheMap();
  const tsOptionDeclarations = import_typescript2.default.optionDeclarations;
  function getVueLanguage(compilerOptions, vueCompilerOptions) {
    if (!cache)
      return getLanguage();
    const key2 = `vue:${getObjectHash([compilerOptions, vueCompilerOptions])}`;
    if (!cache.has(key2)) {
      const env2 = getLanguage();
      cache.set(key2, env2);
      return env2;
    }
    return cache.get(key2);
    function getLanguage() {
      const resolvedVueOptions = (0, import_language_core.resolveVueCompilerOptions)(vueCompilerOptions);
      resolvedVueOptions.__setupedGlobalTypes = (0, import_language_core.setupGlobalTypes)(import_typescript2.default.sys.getCurrentDirectory(), resolvedVueOptions, import_typescript2.default.sys);
      const vueLanguagePlugin = (0, import_language_core.createVueLanguagePlugin)(import_typescript2.default, defaultCompilerOptions3, resolvedVueOptions, (id) => id);
      return (0, import_language_core.createLanguage)(
        [vueLanguagePlugin],
        new import_language_core.FileMap(import_typescript2.default.sys.useCaseSensitiveFileNames),
        () => {
        }
      );
    }
  }
  function twoslasher2(code3, extension2, options = {}) {
    var _a;
    if (extension2 !== "vue")
      return twoslasherBase(code3, extension2, options);
    const vueCompilerOptions = {
      ...createOptions.vueCompilerOptions,
      ...options.vueCompilerOptions
    };
    const compilerOptions = {
      ...defaultCompilerOptions3,
      ...options.compilerOptions
    };
    const handbookOptions = {
      ...defaultHandbookOptions,
      noErrorsCutted: true,
      ...options.handbookOptions
    };
    const sourceMeta = {
      removals: [],
      positionCompletions: [],
      positionQueries: [],
      positionHighlights: [],
      flagNotations: []
    };
    const {
      customTags = createOptions.customTags || []
    } = options;
    const pc = createPositionConverter2(code3);
    findQueryMarkers(code3, sourceMeta, pc);
    const flagNotations = findFlagNotations(code3, customTags, tsOptionDeclarations);
    for (const flag of flagNotations) {
      switch (flag.type) {
        case "unknown":
          continue;
        case "compilerOptions":
          compilerOptions[flag.name] = flag.value;
          break;
        case "handbookOptions":
          handbookOptions[flag.name] = flag.value;
          break;
      }
      sourceMeta.removals.push([flag.start, flag.end]);
    }
    let strippedCode = code3;
    for (const [start, end] of sourceMeta.removals) {
      strippedCode = strippedCode.slice(0, start) + strippedCode.slice(start, end).replace(/\S/g, " ") + strippedCode.slice(end);
    }
    const lang = getVueLanguage(compilerOptions, vueCompilerOptions);
    const sourceScript = lang.scripts.set("index.vue", import_typescript2.default.ScriptSnapshot.fromString(strippedCode));
    const fileCompiled = get(sourceScript.generated.embeddedCodes.values(), 2);
    const compiled = fileCompiled.snapshot.getText(0, fileCompiled.snapshot.getLength());
    const map = (0, import_language_core.defaultMapperFactory)(fileCompiled.mappings);
    function getLastGeneratedOffset(pos) {
      var _a2;
      const offsets = [...map.toGeneratedLocation(pos)];
      if (!offsets.length)
        return void 0;
      return (_a2 = offsets[offsets.length - 1]) == null ? void 0 : _a2[0];
    }
    const result = twoslasherBase(compiled, "tsx", {
      ...options,
      compilerOptions: {
        jsx: 1,
        jsxImportSource: "vue",
        noImplicitAny: false,
        ...compilerOptions
      },
      handbookOptions: {
        ...handbookOptions,
        keepNotations: true
      },
      shouldGetHoverInfo(id) {
        return !id.startsWith("__VLS");
      },
      positionCompletions: sourceMeta.positionCompletions.map((p2) => getLastGeneratedOffset(p2)),
      positionQueries: sourceMeta.positionQueries.map((p2) => {
        var _a2;
        return (_a2 = get(map.toGeneratedLocation(p2), 0)) == null ? void 0 : _a2[0];
      }).filter(isNotNull),
      positionHighlights: sourceMeta.positionHighlights.map(([start, end]) => {
        var _a2, _b;
        return [
          (_a2 = get(map.toGeneratedLocation(start), 0)) == null ? void 0 : _a2[0],
          (_b = get(map.toGeneratedLocation(end), 0)) == null ? void 0 : _b[0]
        ];
      }).filter((x) => x[0] != null && x[1] != null)
    });
    if (createOptions.debugShowGeneratedCode)
      return result;
    const mappedNodes = result.nodes.map((q) => {
      var _a2;
      if ("text" in q && q.text === "any")
        return void 0;
      const startMap = get(map.toSourceLocation(q.start), 0);
      if (!startMap)
        return void 0;
      const start = startMap[0];
      let end = (_a2 = get(map.toSourceLocation(q.start + q.length), 0)) == null ? void 0 : _a2[0];
      if (end == null && startMap[1].sourceOffsets[0] === startMap[0])
        end = startMap[1].sourceOffsets[1];
      if (end == null || start < 0 || end < 0 || start > end)
        return void 0;
      return Object.assign(q, {
        ...q,
        target: code3.slice(start, end),
        start: startMap[0],
        length: end - start
      });
    }).filter(isNotNull);
    const mappedRemovals = [
      ...sourceMeta.removals,
      ...result.meta.removals.map((r4) => {
        var _a2, _b, _c;
        const start = ((_a2 = get(map.toSourceLocation(r4[0]), 0)) == null ? void 0 : _a2[0]) ?? ((_b = code3.match(new RegExp("(?<=<script[\\s\\S]*>\\s)"))) == null ? void 0 : _b.index);
        const end = (_c = get(map.toSourceLocation(r4[1]), 0)) == null ? void 0 : _c[0];
        if (start == null || end == null || start < 0 || end < 0 || start >= end)
          return void 0;
        return [start, end];
      }).filter(isNotNull)
    ];
    if (!((_a = options.handbookOptions) == null ? void 0 : _a.keepNotations)) {
      const removed = removeCodeRanges(code3, mappedRemovals, mappedNodes);
      result.code = removed.code;
      result.meta.removals = removed.removals;
      result.nodes = resolveNodePositions(removed.nodes, result.code);
    } else {
      result.meta.removals = mappedRemovals;
    }
    result.nodes = result.nodes.filter((n, idx) => {
      const next = result.nodes[idx + 1];
      if (!next)
        return true;
      if (next.type === n.type && next.start === n.start)
        return false;
      return true;
    });
    result.meta.extension = "vue";
    return result;
  }
  twoslasher2.getCacheMap = twoslasherBase.getCacheMap;
  return twoslasher2;
}
function isNotNull(x) {
  return x != null;
}
function get(iterator, index2) {
  for (const item of iterator) {
    if (index2-- === 0)
      return item;
  }
  return void 0;
}

// node_modules/devlop/lib/development.js
var AssertionError = class extends Error {
  /**
   * Create an assertion error.
   *
   * @param {string} message
   *   Message explaining error.
   * @param {unknown} actual
   *   Value.
   * @param {unknown} expected
   *   Baseline.
   * @param {string} operator
   *   Name of equality operation.
   * @param {boolean} generated
   *   Whether `message` is a custom message or not
   * @returns
   *   Instance.
   */
  // eslint-disable-next-line max-params
  constructor(message, actual, expected, operator, generated) {
    super(message);
    __publicField(
      this,
      "name",
      /** @type {const} */
      "Assertion"
    );
    __publicField(
      this,
      "code",
      /** @type {const} */
      "ERR_ASSERTION"
    );
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.actual = actual;
    this.expected = expected;
    this.generated = generated;
    this.operator = operator;
  }
};
function ok(value, message) {
  assert2(
    Boolean(value),
    false,
    true,
    "ok",
    "Expected value to be truthy",
    message
  );
}
function assert2(bool, actual, expected, operator, defaultMessage, userMessage) {
  if (!bool) {
    throw userMessage instanceof Error ? userMessage : new AssertionError(
      userMessage || defaultMessage,
      actual,
      expected,
      operator,
      !userMessage
    );
  }
}

// node_modules/mdast-util-to-string/lib/index.js
var emptyOptions2 = {};
function toString(value, options) {
  const settings = options || emptyOptions2;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one2(value, includeImageAlt, includeHtml);
}
function one2(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all2(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all2(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all2(values2, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values2.length) {
    result[index2] = one2(values2[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}

// node_modules/decode-named-character-reference/index.dom.js
var element2 = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element2.innerHTML = characterReference2;
  const character = element2.textContent;
  if (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    character.charCodeAt(character.length - 1) === 59 && value !== "semi"
  ) {
    return false;
  }
  return character === characterReference2 ? false : character;
}

// node_modules/micromark-util-symbol/lib/codes.js
var codes = (
  /** @type {const} */
  {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    // `\t`
    lf: 10,
    // `\n`
    vt: 11,
    // `\v`
    ff: 12,
    // `\f`
    cr: 13,
    // `\r`
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    // `!`
    quotationMark: 34,
    // `"`
    numberSign: 35,
    // `#`
    dollarSign: 36,
    // `$`
    percentSign: 37,
    // `%`
    ampersand: 38,
    // `&`
    apostrophe: 39,
    // `'`
    leftParenthesis: 40,
    // `(`
    rightParenthesis: 41,
    // `)`
    asterisk: 42,
    // `*`
    plusSign: 43,
    // `+`
    comma: 44,
    // `,`
    dash: 45,
    // `-`
    dot: 46,
    // `.`
    slash: 47,
    // `/`
    digit0: 48,
    // `0`
    digit1: 49,
    // `1`
    digit2: 50,
    // `2`
    digit3: 51,
    // `3`
    digit4: 52,
    // `4`
    digit5: 53,
    // `5`
    digit6: 54,
    // `6`
    digit7: 55,
    // `7`
    digit8: 56,
    // `8`
    digit9: 57,
    // `9`
    colon: 58,
    // `:`
    semicolon: 59,
    // `;`
    lessThan: 60,
    // `<`
    equalsTo: 61,
    // `=`
    greaterThan: 62,
    // `>`
    questionMark: 63,
    // `?`
    atSign: 64,
    // `@`
    uppercaseA: 65,
    // `A`
    uppercaseB: 66,
    // `B`
    uppercaseC: 67,
    // `C`
    uppercaseD: 68,
    // `D`
    uppercaseE: 69,
    // `E`
    uppercaseF: 70,
    // `F`
    uppercaseG: 71,
    // `G`
    uppercaseH: 72,
    // `H`
    uppercaseI: 73,
    // `I`
    uppercaseJ: 74,
    // `J`
    uppercaseK: 75,
    // `K`
    uppercaseL: 76,
    // `L`
    uppercaseM: 77,
    // `M`
    uppercaseN: 78,
    // `N`
    uppercaseO: 79,
    // `O`
    uppercaseP: 80,
    // `P`
    uppercaseQ: 81,
    // `Q`
    uppercaseR: 82,
    // `R`
    uppercaseS: 83,
    // `S`
    uppercaseT: 84,
    // `T`
    uppercaseU: 85,
    // `U`
    uppercaseV: 86,
    // `V`
    uppercaseW: 87,
    // `W`
    uppercaseX: 88,
    // `X`
    uppercaseY: 89,
    // `Y`
    uppercaseZ: 90,
    // `Z`
    leftSquareBracket: 91,
    // `[`
    backslash: 92,
    // `\`
    rightSquareBracket: 93,
    // `]`
    caret: 94,
    // `^`
    underscore: 95,
    // `_`
    graveAccent: 96,
    // `` ` ``
    lowercaseA: 97,
    // `a`
    lowercaseB: 98,
    // `b`
    lowercaseC: 99,
    // `c`
    lowercaseD: 100,
    // `d`
    lowercaseE: 101,
    // `e`
    lowercaseF: 102,
    // `f`
    lowercaseG: 103,
    // `g`
    lowercaseH: 104,
    // `h`
    lowercaseI: 105,
    // `i`
    lowercaseJ: 106,
    // `j`
    lowercaseK: 107,
    // `k`
    lowercaseL: 108,
    // `l`
    lowercaseM: 109,
    // `m`
    lowercaseN: 110,
    // `n`
    lowercaseO: 111,
    // `o`
    lowercaseP: 112,
    // `p`
    lowercaseQ: 113,
    // `q`
    lowercaseR: 114,
    // `r`
    lowercaseS: 115,
    // `s`
    lowercaseT: 116,
    // `t`
    lowercaseU: 117,
    // `u`
    lowercaseV: 118,
    // `v`
    lowercaseW: 119,
    // `w`
    lowercaseX: 120,
    // `x`
    lowercaseY: 121,
    // `y`
    lowercaseZ: 122,
    // `z`
    leftCurlyBrace: 123,
    // `{`
    verticalBar: 124,
    // `|`
    rightCurlyBrace: 125,
    // `}`
    tilde: 126,
    // `~`
    del: 127,
    // Unicode Specials block.
    byteOrderMarker: 65279,
    // Unicode Specials block.
    replacementCharacter: 65533
    // `�`
  }
);

// node_modules/micromark-util-symbol/lib/constants.js
var constants2 = (
  /** @type {const} */
  {
    attentionSideAfter: 2,
    // Symbol to mark an attention sequence as after content: `a*`
    attentionSideBefore: 1,
    // Symbol to mark an attention sequence as before content: `*a`
    atxHeadingOpeningFenceSizeMax: 6,
    // 6 number signs is fine, 7 isn’t.
    autolinkDomainSizeMax: 63,
    // 63 characters is fine, 64 is too many.
    autolinkSchemeSizeMax: 32,
    // 32 characters is fine, 33 is too many.
    cdataOpeningString: "CDATA[",
    // And preceded by `<![`.
    characterGroupPunctuation: 2,
    // Symbol used to indicate a character is punctuation
    characterGroupWhitespace: 1,
    // Symbol used to indicate a character is whitespace
    characterReferenceDecimalSizeMax: 7,
    // `&#9999999;`.
    characterReferenceHexadecimalSizeMax: 6,
    // `&#xff9999;`.
    characterReferenceNamedSizeMax: 31,
    // `&CounterClockwiseContourIntegral;`.
    codeFencedSequenceSizeMin: 3,
    // At least 3 ticks or tildes are needed.
    contentTypeContent: "content",
    contentTypeDocument: "document",
    contentTypeFlow: "flow",
    contentTypeString: "string",
    contentTypeText: "text",
    hardBreakPrefixSizeMin: 2,
    // At least 2 trailing spaces are needed.
    htmlBasic: 6,
    // Symbol for `<div`
    htmlCdata: 5,
    // Symbol for `<![CDATA[]]>`
    htmlComment: 2,
    // Symbol for `<!---->`
    htmlComplete: 7,
    // Symbol for `<x>`
    htmlDeclaration: 4,
    // Symbol for `<!doctype>`
    htmlInstruction: 3,
    // Symbol for `<?php?>`
    htmlRawSizeMax: 8,
    // Length of `textarea`.
    htmlRaw: 1,
    // Symbol for `<script>`
    linkResourceDestinationBalanceMax: 32,
    // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
    linkReferenceSizeMax: 999,
    // See: <https://spec.commonmark.org/0.30/#link-label>
    listItemValueSizeMax: 10,
    // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
    numericBaseDecimal: 10,
    numericBaseHexadecimal: 16,
    tabSize: 4,
    // Tabs have a hard-coded size of 4, per CommonMark.
    thematicBreakMarkerCountMin: 3,
    // At least 3 asterisks, dashes, or underscores are needed.
    v8MaxSafeChunkSize: 1e4
    // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
  }
);

// node_modules/micromark-util-symbol/lib/types.js
var types = (
  /** @type {const} */
  {
    // Generic type for data, such as in a title, a destination, etc.
    data: "data",
    // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
    // Such as, between a fenced code fence and an info string.
    whitespace: "whitespace",
    // Generic type for line endings (line feed, carriage return, carriage return +
    // line feed).
    lineEnding: "lineEnding",
    // A line ending, but ending a blank line.
    lineEndingBlank: "lineEndingBlank",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
    // line.
    linePrefix: "linePrefix",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
    // line.
    lineSuffix: "lineSuffix",
    // Whole ATX heading:
    //
    // ```markdown
    // #
    // ## Alpha
    // ### Bravo ###
    // ```
    //
    // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
    atxHeading: "atxHeading",
    // Sequence of number signs in an ATX heading (`###`).
    atxHeadingSequence: "atxHeadingSequence",
    // Content in an ATX heading (`alpha`).
    // Includes text.
    atxHeadingText: "atxHeadingText",
    // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
    // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
    autolink: "autolink",
    // Email autolink w/o markers (`admin@example.com`)
    autolinkEmail: "autolinkEmail",
    // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
    autolinkMarker: "autolinkMarker",
    // Protocol autolink w/o markers (`https://example.com`)
    autolinkProtocol: "autolinkProtocol",
    // A whole character escape (`\-`).
    // Includes `escapeMarker` and `characterEscapeValue`.
    characterEscape: "characterEscape",
    // The escaped character (`-`).
    characterEscapeValue: "characterEscapeValue",
    // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
    // Includes `characterReferenceMarker`, an optional
    // `characterReferenceMarkerNumeric`, in which case an optional
    // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
    characterReference: "characterReference",
    // The start or end marker (`&` or `;`).
    characterReferenceMarker: "characterReferenceMarker",
    // Mark reference as numeric (`#`).
    characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
    // Mark reference as numeric (`x` or `X`).
    characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
    // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
    characterReferenceValue: "characterReferenceValue",
    // Whole fenced code:
    //
    // ````markdown
    // ```js
    // alert(1)
    // ```
    // ````
    codeFenced: "codeFenced",
    // A fenced code fence, including whitespace, sequence, info, and meta
    // (` ```js `).
    codeFencedFence: "codeFencedFence",
    // Sequence of grave accent or tilde characters (` ``` `) in a fence.
    codeFencedFenceSequence: "codeFencedFenceSequence",
    // Info word (`js`) in a fence.
    // Includes string.
    codeFencedFenceInfo: "codeFencedFenceInfo",
    // Meta words (`highlight="1"`) in a fence.
    // Includes string.
    codeFencedFenceMeta: "codeFencedFenceMeta",
    // A line of code.
    codeFlowValue: "codeFlowValue",
    // Whole indented code:
    //
    // ```markdown
    //     alert(1)
    // ```
    //
    // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
    codeIndented: "codeIndented",
    // A text code (``` `alpha` ```).
    // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
    // `codeTextPadding`.
    codeText: "codeText",
    codeTextData: "codeTextData",
    // A space or line ending right after or before a tick.
    codeTextPadding: "codeTextPadding",
    // A text code fence (` `` `).
    codeTextSequence: "codeTextSequence",
    // Whole content:
    //
    // ```markdown
    // [a]: b
    // c
    // =
    // d
    // ```
    //
    // Includes `paragraph` and `definition`.
    content: "content",
    // Whole definition:
    //
    // ```markdown
    // [micromark]: https://github.com/micromark/micromark
    // ```
    //
    // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
    // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
    definition: "definition",
    // Destination of a definition (`https://github.com/micromark/micromark` or
    // `<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
    definitionDestination: "definitionDestination",
    // Enclosed destination of a definition
    // (`<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteralMarker` and optionally
    // `definitionDestinationString`.
    definitionDestinationLiteral: "definitionDestinationLiteral",
    // Markers of an enclosed definition destination (`<` or `>`).
    definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
    // Unenclosed destination of a definition
    // (`https://github.com/micromark/micromark`).
    // Includes `definitionDestinationString`.
    definitionDestinationRaw: "definitionDestinationRaw",
    // Text in an destination (`https://github.com/micromark/micromark`).
    // Includes string.
    definitionDestinationString: "definitionDestinationString",
    // Label of a definition (`[micromark]`).
    // Includes `definitionLabelMarker` and `definitionLabelString`.
    definitionLabel: "definitionLabel",
    // Markers of a definition label (`[` or `]`).
    definitionLabelMarker: "definitionLabelMarker",
    // Value of a definition label (`micromark`).
    // Includes string.
    definitionLabelString: "definitionLabelString",
    // Marker between a label and a destination (`:`).
    definitionMarker: "definitionMarker",
    // Title of a definition (`"x"`, `'y'`, or `(z)`).
    // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
    definitionTitle: "definitionTitle",
    // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
    definitionTitleMarker: "definitionTitleMarker",
    // Data without markers in a title (`z`).
    // Includes string.
    definitionTitleString: "definitionTitleString",
    // Emphasis (`*alpha*`).
    // Includes `emphasisSequence` and `emphasisText`.
    emphasis: "emphasis",
    // Sequence of emphasis markers (`*` or `_`).
    emphasisSequence: "emphasisSequence",
    // Emphasis text (`alpha`).
    // Includes text.
    emphasisText: "emphasisText",
    // The character escape marker (`\`).
    escapeMarker: "escapeMarker",
    // A hard break created with a backslash (`\\n`).
    // Note: does not include the line ending.
    hardBreakEscape: "hardBreakEscape",
    // A hard break created with trailing spaces (`  \n`).
    // Does not include the line ending.
    hardBreakTrailing: "hardBreakTrailing",
    // Flow HTML:
    //
    // ```markdown
    // <div
    // ```
    //
    // Inlcudes `lineEnding`, `htmlFlowData`.
    htmlFlow: "htmlFlow",
    htmlFlowData: "htmlFlowData",
    // HTML in text (the tag in `a <i> b`).
    // Includes `lineEnding`, `htmlTextData`.
    htmlText: "htmlText",
    htmlTextData: "htmlTextData",
    // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
    // `![alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    image: "image",
    // Whole link label (`[*alpha*]`).
    // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
    label: "label",
    // Text in an label (`*alpha*`).
    // Includes text.
    labelText: "labelText",
    // Start a link label (`[`).
    // Includes a `labelMarker`.
    labelLink: "labelLink",
    // Start an image label (`![`).
    // Includes `labelImageMarker` and `labelMarker`.
    labelImage: "labelImage",
    // Marker of a label (`[` or `]`).
    labelMarker: "labelMarker",
    // Marker to start an image (`!`).
    labelImageMarker: "labelImageMarker",
    // End a label (`]`).
    // Includes `labelMarker`.
    labelEnd: "labelEnd",
    // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    link: "link",
    // Whole paragraph:
    //
    // ```markdown
    // alpha
    // bravo.
    // ```
    //
    // Includes text.
    paragraph: "paragraph",
    // A reference (`[alpha]` or `[]`).
    // Includes `referenceMarker` and an optional `referenceString`.
    reference: "reference",
    // A reference marker (`[` or `]`).
    referenceMarker: "referenceMarker",
    // Reference text (`alpha`).
    // Includes string.
    referenceString: "referenceString",
    // A resource (`(https://example.com "alpha")`).
    // Includes `resourceMarker`, an optional `resourceDestination` with an optional
    // `whitespace` and `resourceTitle`.
    resource: "resource",
    // A resource destination (`https://example.com`).
    // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
    resourceDestination: "resourceDestination",
    // A literal resource destination (`<https://example.com>`).
    // Includes `resourceDestinationLiteralMarker` and optionally
    // `resourceDestinationString`.
    resourceDestinationLiteral: "resourceDestinationLiteral",
    // A resource destination marker (`<` or `>`).
    resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
    // A raw resource destination (`https://example.com`).
    // Includes `resourceDestinationString`.
    resourceDestinationRaw: "resourceDestinationRaw",
    // Resource destination text (`https://example.com`).
    // Includes string.
    resourceDestinationString: "resourceDestinationString",
    // A resource marker (`(` or `)`).
    resourceMarker: "resourceMarker",
    // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
    // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
    resourceTitle: "resourceTitle",
    // A resource title marker (`"`, `'`, `(`, or `)`).
    resourceTitleMarker: "resourceTitleMarker",
    // Resource destination title (`alpha`).
    // Includes string.
    resourceTitleString: "resourceTitleString",
    // Whole setext heading:
    //
    // ```markdown
    // alpha
    // bravo
    // =====
    // ```
    //
    // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
    // `setextHeadingLine`.
    setextHeading: "setextHeading",
    // Content in a setext heading (`alpha\nbravo`).
    // Includes text.
    setextHeadingText: "setextHeadingText",
    // Underline in a setext heading, including whitespace suffix (`==`).
    // Includes `setextHeadingLineSequence`.
    setextHeadingLine: "setextHeadingLine",
    // Sequence of equals or dash characters in underline in a setext heading (`-`).
    setextHeadingLineSequence: "setextHeadingLineSequence",
    // Strong (`**alpha**`).
    // Includes `strongSequence` and `strongText`.
    strong: "strong",
    // Sequence of strong markers (`**` or `__`).
    strongSequence: "strongSequence",
    // Strong text (`alpha`).
    // Includes text.
    strongText: "strongText",
    // Whole thematic break:
    //
    // ```markdown
    // * * *
    // ```
    //
    // Includes `thematicBreakSequence` and `whitespace`.
    thematicBreak: "thematicBreak",
    // A sequence of one or more thematic break markers (`***`).
    thematicBreakSequence: "thematicBreakSequence",
    // Whole block quote:
    //
    // ```markdown
    // > a
    // >
    // > b
    // ```
    //
    // Includes `blockQuotePrefix` and flow.
    blockQuote: "blockQuote",
    // The `>` or `> ` of a block quote.
    blockQuotePrefix: "blockQuotePrefix",
    // The `>` of a block quote prefix.
    blockQuoteMarker: "blockQuoteMarker",
    // The optional ` ` of a block quote prefix.
    blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
    // Whole ordered list:
    //
    // ```markdown
    // 1. a
    //    b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listOrdered: "listOrdered",
    // Whole unordered list:
    //
    // ```markdown
    // - a
    //   b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listUnordered: "listUnordered",
    // The indent of further list item lines.
    listItemIndent: "listItemIndent",
    // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
    listItemMarker: "listItemMarker",
    // The thing that starts a list item, such as `1. `.
    // Includes `listItemValue` if ordered, `listItemMarker`, and
    // `listItemPrefixWhitespace` (unless followed by a line ending).
    listItemPrefix: "listItemPrefix",
    // The whitespace after a marker.
    listItemPrefixWhitespace: "listItemPrefixWhitespace",
    // The numerical value of an ordered item.
    listItemValue: "listItemValue",
    // Internal types used for subtokenizers, compiled away
    chunkDocument: "chunkDocument",
    chunkContent: "chunkContent",
    chunkFlow: "chunkFlow",
    chunkText: "chunkText",
    chunkString: "chunkString"
  }
);

// node_modules/micromark-util-symbol/lib/values.js
var values = (
  /** @type {const} */
  {
    ht: "	",
    lf: "\n",
    cr: "\r",
    space: " ",
    exclamationMark: "!",
    quotationMark: '"',
    numberSign: "#",
    dollarSign: "$",
    percentSign: "%",
    ampersand: "&",
    apostrophe: "'",
    leftParenthesis: "(",
    rightParenthesis: ")",
    asterisk: "*",
    plusSign: "+",
    comma: ",",
    dash: "-",
    dot: ".",
    slash: "/",
    digit0: "0",
    digit1: "1",
    digit2: "2",
    digit3: "3",
    digit4: "4",
    digit5: "5",
    digit6: "6",
    digit7: "7",
    digit8: "8",
    digit9: "9",
    colon: ":",
    semicolon: ";",
    lessThan: "<",
    equalsTo: "=",
    greaterThan: ">",
    questionMark: "?",
    atSign: "@",
    uppercaseA: "A",
    uppercaseB: "B",
    uppercaseC: "C",
    uppercaseD: "D",
    uppercaseE: "E",
    uppercaseF: "F",
    uppercaseG: "G",
    uppercaseH: "H",
    uppercaseI: "I",
    uppercaseJ: "J",
    uppercaseK: "K",
    uppercaseL: "L",
    uppercaseM: "M",
    uppercaseN: "N",
    uppercaseO: "O",
    uppercaseP: "P",
    uppercaseQ: "Q",
    uppercaseR: "R",
    uppercaseS: "S",
    uppercaseT: "T",
    uppercaseU: "U",
    uppercaseV: "V",
    uppercaseW: "W",
    uppercaseX: "X",
    uppercaseY: "Y",
    uppercaseZ: "Z",
    leftSquareBracket: "[",
    backslash: "\\",
    rightSquareBracket: "]",
    caret: "^",
    underscore: "_",
    graveAccent: "`",
    lowercaseA: "a",
    lowercaseB: "b",
    lowercaseC: "c",
    lowercaseD: "d",
    lowercaseE: "e",
    lowercaseF: "f",
    lowercaseG: "g",
    lowercaseH: "h",
    lowercaseI: "i",
    lowercaseJ: "j",
    lowercaseK: "k",
    lowercaseL: "l",
    lowercaseM: "m",
    lowercaseN: "n",
    lowercaseO: "o",
    lowercaseP: "p",
    lowercaseQ: "q",
    lowercaseR: "r",
    lowercaseS: "s",
    lowercaseT: "t",
    lowercaseU: "u",
    lowercaseV: "v",
    lowercaseW: "w",
    lowercaseX: "x",
    lowercaseY: "y",
    lowercaseZ: "z",
    leftCurlyBrace: "{",
    verticalBar: "|",
    rightCurlyBrace: "}",
    tilde: "~",
    replacementCharacter: "�"
  }
);

// node_modules/micromark-util-chunked/dev/index.js
function splice(list4, start, remove2, items) {
  const end = list4.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove2 = remove2 > 0 ? remove2 : 0;
  if (items.length < constants2.v8MaxSafeChunkSize) {
    parameters = Array.from(items);
    parameters.unshift(start, remove2);
    list4.splice(...parameters);
  } else {
    if (remove2) list4.splice(start, remove2);
    while (chunkStart < items.length) {
      parameters = items.slice(
        chunkStart,
        chunkStart + constants2.v8MaxSafeChunkSize
      );
      parameters.unshift(start, 0);
      list4.splice(...parameters);
      chunkStart += constants2.v8MaxSafeChunkSize;
      start += constants2.v8MaxSafeChunkSize;
    }
  }
}
function push(list4, items) {
  if (list4.length > 0) {
    splice(list4, list4.length, 0, items);
    return list4;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty2 = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all3 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all3, extensions[index2]);
  }
  return all3;
}
function syntaxExtension(all3, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty2.call(all3, hook) ? all3[hook] : void 0;
    const left = maybe || (all3[hook] = {});
    const right = extension2[hook];
    let code3;
    if (right) {
      for (code3 in right) {
        if (!hasOwnProperty2.call(left, code3)) left[code3] = [];
        const value = right[code3];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code3],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list4) {
  let index2 = -1;
  const before = [];
  while (++index2 < list4.length) {
    ;
    (list4[index2].add === "after" ? existing : before).push(list4[index2]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-decode-numeric-character-reference/dev/index.js
function decodeNumericCharacterReference(value, base) {
  const code3 = Number.parseInt(value, base);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code3 < codes.ht || code3 === codes.vt || code3 > codes.cr && code3 < codes.space || // Control character (DEL) of C0, and C1 controls.
    code3 > codes.tilde && code3 < 160 || // Lone high surrogates and low surrogates.
    code3 > 55295 && code3 < 57344 || // Noncharacters.
    code3 > 64975 && code3 < 65008 || /* eslint-disable no-bitwise */
    (code3 & 65535) === 65535 || (code3 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code3 > 1114111
  ) {
    return values.replacementCharacter;
  }
  return String.fromCodePoint(code3);
}

// node_modules/micromark-util-normalize-identifier/dev/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, values.space).replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark-util-character/dev/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code3) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code3 !== null && (code3 < codes.space || code3 === codes.del)
  );
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code3) {
  return code3 !== null && code3 < codes.horizontalTab;
}
function markdownLineEndingOrSpace(code3) {
  return code3 !== null && (code3 < codes.nul || code3 === codes.space);
}
function markdownSpace(code3) {
  return code3 === codes.horizontalTab || code3 === codes.virtualSpace || code3 === codes.space;
}
var unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code3) {
    return code3 !== null && code3 > -1 && regex.test(String.fromCharCode(code3));
  }
}

// node_modules/micromark-util-sanitize-uri/dev/index.js
function normalizeUri(value) {
  const result = [];
  let index2 = -1;
  let start = 0;
  let skip = 0;
  while (++index2 < value.length) {
    const code3 = value.charCodeAt(index2);
    let replace2 = "";
    if (code3 === codes.percentSign && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
      skip = 2;
    } else if (code3 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code3))) {
        replace2 = String.fromCharCode(code3);
      }
    } else if (code3 > 55295 && code3 < 57344) {
      const next = value.charCodeAt(index2 + 1);
      if (code3 < 56320 && next > 56319 && next < 57344) {
        replace2 = String.fromCharCode(code3, next);
        skip = 1;
      } else {
        replace2 = values.replacementCharacter;
      }
    } else {
      replace2 = String.fromCharCode(code3);
    }
    if (replace2) {
      result.push(value.slice(start, index2), encodeURIComponent(replace2));
      start = index2 + skip + 1;
      replace2 = "";
    }
    if (skip) {
      index2 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start);
}

// node_modules/micromark/dev/lib/compile.js
var hasOwnProperty3 = {}.hasOwnProperty;

// node_modules/micromark-factory-space/dev/index.js
function factorySpace(effects, ok3, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code3) {
    if (markdownSpace(code3)) {
      effects.enter(type);
      return prefix(code3);
    }
    return ok3(code3);
  }
  function prefix(code3) {
    if (markdownSpace(code3) && size++ < limit) {
      effects.consume(code3);
      return prefix;
    }
    effects.exit(type);
    return ok3(code3);
  }
}

// node_modules/micromark/dev/lib/initialize/content.js
var content = { tokenize: initializeContent };
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous3;
  return contentStart;
  function afterContentStartConstruct(code3) {
    ok(
      code3 === codes.eof || markdownLineEnding(code3),
      "expected eol or eof"
    );
    if (code3 === codes.eof) {
      effects.consume(code3);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return factorySpace(effects, contentStart, types.linePrefix);
  }
  function paragraphInitial(code3) {
    ok(
      code3 !== codes.eof && !markdownLineEnding(code3),
      "expected anything other than a line ending or EOF"
    );
    effects.enter(types.paragraph);
    return lineStart(code3);
  }
  function lineStart(code3) {
    const token2 = effects.enter(types.chunkText, {
      contentType: constants2.contentTypeText,
      previous: previous3
    });
    if (previous3) {
      previous3.next = token2;
    }
    previous3 = token2;
    return data(code3);
  }
  function data(code3) {
    if (code3 === codes.eof) {
      effects.exit(types.chunkText);
      effects.exit(types.paragraph);
      effects.consume(code3);
      return;
    }
    if (markdownLineEnding(code3)) {
      effects.consume(code3);
      effects.exit(types.chunkText);
      return lineStart;
    }
    effects.consume(code3);
    return data;
  }
}

// node_modules/micromark/dev/lib/initialize/document.js
var document2 = { tokenize: initializeDocument };
var containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
  const self2 = this;
  const stack2 = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code3) {
    if (continued < stack2.length) {
      const item = stack2[continued];
      self2.containerState = item[1];
      ok(
        item[0].continuation,
        "expected `continuation` to be defined on container construct"
      );
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code3);
    }
    return checkNewContainers(code3);
  }
  function documentContinue(code3) {
    ok(
      self2.containerState,
      "expected `containerState` to be defined after continuation"
    );
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point4;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          point4 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      ok(point4, "could not find previous flow chunk");
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = { ...point4 };
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
      return checkNewContainers(code3);
    }
    return start(code3);
  }
  function checkNewContainers(code3) {
    if (continued === stack2.length) {
      if (!childFlow) {
        return documentContinued(code3);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code3);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code3);
  }
  function thereIsANewContainer(code3) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code3);
  }
  function thereIsNoNewContainer(code3) {
    self2.parser.lazy[self2.now().line] = continued !== stack2.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code3);
  }
  function documentContinued(code3) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code3);
  }
  function containerContinue(code3) {
    ok(
      self2.currentConstruct,
      "expected `currentConstruct` to be defined on tokenizer"
    );
    ok(
      self2.containerState,
      "expected `containerState` to be defined on tokenizer"
    );
    continued++;
    stack2.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code3);
  }
  function flowStart(code3) {
    if (code3 === codes.eof) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code3);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter(types.chunkFlow, {
      _tokenizer: childFlow,
      contentType: constants2.contentTypeFlow,
      previous: childToken
    });
    return flowContinue(code3);
  }
  function flowContinue(code3) {
    if (code3 === codes.eof) {
      writeToChild(effects.exit(types.chunkFlow), true);
      exitContainers(0);
      effects.consume(code3);
      return;
    }
    if (markdownLineEnding(code3)) {
      effects.consume(code3);
      writeToChild(effects.exit(types.chunkFlow));
      continued = 0;
      self2.interrupt = void 0;
      return start;
    }
    effects.consume(code3);
    return flowContinue;
  }
  function writeToChild(token2, endOfFile) {
    ok(childFlow, "expected `childFlow` to be defined when continuing");
    const stream = self2.sliceStream(token2);
    if (endOfFile) stream.push(null);
    token2.previous = childToken;
    if (childToken) childToken.next = token2;
    childToken = token2;
    childFlow.defineSkip(token2.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token2.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (
          // The token starts before the line ending…
          childFlow.events[index2][1].start.offset < lineStartOffset && // …and either is not ended yet…
          (!childFlow.events[index2][1].end || // …or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen2;
      let point4;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          if (seen2) {
            point4 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen2 = true;
        }
      }
      ok(point4, "could not find previous flow chunk");
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = { ...point4 };
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack2.length;
    while (index2-- > size) {
      const entry = stack2[index2];
      self2.containerState = entry[1];
      ok(
        entry[0].exit,
        "expected `exit` to be defined on container construct"
      );
      entry[0].exit.call(self2, effects);
    }
    stack2.length = size;
  }
  function closeFlow() {
    ok(
      self2.containerState,
      "expected `containerState` to be defined when closing flow"
    );
    ok(childFlow, "expected `childFlow` to be defined when closing it");
    childFlow.write([codes.eof]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  ok(
    this.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok3, nok),
    types.linePrefix,
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants2.tabSize
  );
}

// node_modules/micromark-util-classify-character/dev/index.js
function classifyCharacter(code3) {
  if (code3 === codes.eof || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
    return constants2.characterGroupWhitespace;
  }
  if (unicodePunctuation(code3)) {
    return constants2.characterGroupPunctuation;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/micromark-core-commonmark/dev/lib/attention.js
var attention = {
  name: "attention",
  resolveAll: resolveAllAttention,
  tokenize: tokenizeAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text6;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = { ...events[open][1].end };
          const end = { ...events[index2][1].start };
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start,
            end: { ...events[open][1].end }
          };
          closingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start: { ...events[index2][1].start },
            end
          };
          text6 = {
            type: use > 1 ? types.strongText : types.emphasisText,
            start: { ...events[open][1].end },
            end: { ...events[index2][1].start }
          };
          group = {
            type: use > 1 ? types.strong : types.emphasis,
            start: { ...openingSequence.start },
            end: { ...closingSequence.end }
          };
          events[open][1].end = { ...openingSequence.start };
          events[index2][1].start = { ...closingSequence.end };
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text6, context]
          ]);
          ok(
            context.parser.constructs.insideSpan.null,
            "expected `insideSpan` to be populated"
          );
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index2),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text6, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous3 = this.previous;
  const before = classifyCharacter(previous3);
  let marker;
  return start;
  function start(code3) {
    ok(
      code3 === codes.asterisk || code3 === codes.underscore,
      "expected asterisk or underscore"
    );
    marker = code3;
    effects.enter("attentionSequence");
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      return inside;
    }
    const token2 = effects.exit("attentionSequence");
    const after = classifyCharacter(code3);
    ok(attentionMarkers2, "expected `attentionMarkers` to be populated");
    const open = !after || after === constants2.characterGroupPunctuation && before || attentionMarkers2.includes(code3);
    const close = !before || before === constants2.characterGroupPunctuation && after || attentionMarkers2.includes(previous3);
    token2._open = Boolean(
      marker === codes.asterisk ? open : open && (before || !close)
    );
    token2._close = Boolean(
      marker === codes.asterisk ? close : close && (after || !open)
    );
    return ok3(code3);
  }
}
function movePoint(point4, offset) {
  point4.column += offset;
  point4.offset += offset;
  point4._bufferIndex += offset;
}

// node_modules/micromark-core-commonmark/dev/lib/autolink.js
var autolink = { name: "autolink", tokenize: tokenizeAutolink };
function tokenizeAutolink(effects, ok3, nok) {
  let size = 0;
  return start;
  function start(code3) {
    ok(code3 === codes.lessThan, "expected `<`");
    effects.enter(types.autolink);
    effects.enter(types.autolinkMarker);
    effects.consume(code3);
    effects.exit(types.autolinkMarker);
    effects.enter(types.autolinkProtocol);
    return open;
  }
  function open(code3) {
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return schemeOrEmailAtext;
    }
    if (code3 === codes.atSign) {
      return nok(code3);
    }
    return emailAtext(code3);
  }
  function schemeOrEmailAtext(code3) {
    if (code3 === codes.plusSign || code3 === codes.dash || code3 === codes.dot || asciiAlphanumeric(code3)) {
      size = 1;
      return schemeInsideOrEmailAtext(code3);
    }
    return emailAtext(code3);
  }
  function schemeInsideOrEmailAtext(code3) {
    if (code3 === codes.colon) {
      effects.consume(code3);
      size = 0;
      return urlInside;
    }
    if ((code3 === codes.plusSign || code3 === codes.dash || code3 === codes.dot || asciiAlphanumeric(code3)) && size++ < constants2.autolinkSchemeSizeMax) {
      effects.consume(code3);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code3);
  }
  function urlInside(code3) {
    if (code3 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol);
      effects.enter(types.autolinkMarker);
      effects.consume(code3);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    if (code3 === codes.eof || code3 === codes.space || code3 === codes.lessThan || asciiControl(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return urlInside;
  }
  function emailAtext(code3) {
    if (code3 === codes.atSign) {
      effects.consume(code3);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code3)) {
      effects.consume(code3);
      return emailAtext;
    }
    return nok(code3);
  }
  function emailAtSignOrDot(code3) {
    return asciiAlphanumeric(code3) ? emailLabel(code3) : nok(code3);
  }
  function emailLabel(code3) {
    if (code3 === codes.dot) {
      effects.consume(code3);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code3 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol).type = types.autolinkEmail;
      effects.enter(types.autolinkMarker);
      effects.consume(code3);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    return emailValue(code3);
  }
  function emailValue(code3) {
    if ((code3 === codes.dash || asciiAlphanumeric(code3)) && size++ < constants2.autolinkDomainSizeMax) {
      const next = code3 === codes.dash ? emailValue : emailLabel;
      effects.consume(code3);
      return next;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/blank-line.js
var blankLine = { partial: true, tokenize: tokenizeBlankLine };
function tokenizeBlankLine(effects, ok3, nok) {
  return start;
  function start(code3) {
    return markdownSpace(code3) ? factorySpace(effects, after, types.linePrefix)(code3) : after(code3);
  }
  function after(code3) {
    return code3 === codes.eof || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/block-quote.js
var blockQuote = {
  continuation: { tokenize: tokenizeBlockQuoteContinuation },
  exit,
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code3) {
    if (code3 === codes.greaterThan) {
      const state = self2.containerState;
      ok(state, "expected `containerState` to be defined in container");
      if (!state.open) {
        effects.enter(types.blockQuote, { _container: true });
        state.open = true;
      }
      effects.enter(types.blockQuotePrefix);
      effects.enter(types.blockQuoteMarker);
      effects.consume(code3);
      effects.exit(types.blockQuoteMarker);
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    if (markdownSpace(code3)) {
      effects.enter(types.blockQuotePrefixWhitespace);
      effects.consume(code3);
      effects.exit(types.blockQuotePrefixWhitespace);
      effects.exit(types.blockQuotePrefix);
      return ok3;
    }
    effects.exit(types.blockQuotePrefix);
    return ok3(code3);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self2 = this;
  return contStart;
  function contStart(code3) {
    if (markdownSpace(code3)) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      return factorySpace(
        effects,
        contBefore,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants2.tabSize
      )(code3);
    }
    return contBefore(code3);
  }
  function contBefore(code3) {
    return effects.attempt(blockQuote, ok3, nok)(code3);
  }
}
function exit(effects) {
  effects.exit(types.blockQuote);
}

// node_modules/micromark-core-commonmark/dev/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start;
  function start(code3) {
    ok(code3 === codes.backslash, "expected `\\`");
    effects.enter(types.characterEscape);
    effects.enter(types.escapeMarker);
    effects.consume(code3);
    effects.exit(types.escapeMarker);
    return inside;
  }
  function inside(code3) {
    if (asciiPunctuation(code3)) {
      effects.enter(types.characterEscapeValue);
      effects.consume(code3);
      effects.exit(types.characterEscapeValue);
      effects.exit(types.characterEscape);
      return ok3;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  const self2 = this;
  let size = 0;
  let max;
  let test;
  return start;
  function start(code3) {
    ok(code3 === codes.ampersand, "expected `&`");
    effects.enter(types.characterReference);
    effects.enter(types.characterReferenceMarker);
    effects.consume(code3);
    effects.exit(types.characterReferenceMarker);
    return open;
  }
  function open(code3) {
    if (code3 === codes.numberSign) {
      effects.enter(types.characterReferenceMarkerNumeric);
      effects.consume(code3);
      effects.exit(types.characterReferenceMarkerNumeric);
      return numeric;
    }
    effects.enter(types.characterReferenceValue);
    max = constants2.characterReferenceNamedSizeMax;
    test = asciiAlphanumeric;
    return value(code3);
  }
  function numeric(code3) {
    if (code3 === codes.uppercaseX || code3 === codes.lowercaseX) {
      effects.enter(types.characterReferenceMarkerHexadecimal);
      effects.consume(code3);
      effects.exit(types.characterReferenceMarkerHexadecimal);
      effects.enter(types.characterReferenceValue);
      max = constants2.characterReferenceHexadecimalSizeMax;
      test = asciiHexDigit;
      return value;
    }
    effects.enter(types.characterReferenceValue);
    max = constants2.characterReferenceDecimalSizeMax;
    test = asciiDigit;
    return value(code3);
  }
  function value(code3) {
    if (code3 === codes.semicolon && size) {
      const token2 = effects.exit(types.characterReferenceValue);
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token2))) {
        return nok(code3);
      }
      effects.enter(types.characterReferenceMarker);
      effects.consume(code3);
      effects.exit(types.characterReferenceMarker);
      effects.exit(types.characterReference);
      return ok3;
    }
    if (test(code3) && size++ < max) {
      effects.consume(code3);
      return value;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-fenced.js
var nonLazyContinuation = {
  partial: true,
  tokenize: tokenizeNonLazyContinuation
};
var codeFenced = {
  concrete: true,
  name: "codeFenced",
  tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(effects, ok3, nok) {
  const self2 = this;
  const closeStart = { partial: true, tokenize: tokenizeCloseStart };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code3) {
    return beforeSequenceOpen(code3);
  }
  function beforeSequenceOpen(code3) {
    ok(
      code3 === codes.graveAccent || code3 === codes.tilde,
      "expected `` ` `` or `~`"
    );
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code3;
    effects.enter(types.codeFenced);
    effects.enter(types.codeFencedFence);
    effects.enter(types.codeFencedFenceSequence);
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === marker) {
      sizeOpen++;
      effects.consume(code3);
      return sequenceOpen;
    }
    if (sizeOpen < constants2.codeFencedSequenceSizeMin) {
      return nok(code3);
    }
    effects.exit(types.codeFencedFenceSequence);
    return markdownSpace(code3) ? factorySpace(effects, infoBefore, types.whitespace)(code3) : infoBefore(code3);
  }
  function infoBefore(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.codeFencedFence);
      return self2.interrupt ? ok3(code3) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code3);
    }
    effects.enter(types.codeFencedFenceInfo);
    effects.enter(types.chunkString, { contentType: constants2.contentTypeString });
    return info(code3);
  }
  function info(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return infoBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return factorySpace(effects, metaBefore, types.whitespace)(code3);
    }
    if (code3 === codes.graveAccent && code3 === marker) {
      return nok(code3);
    }
    effects.consume(code3);
    return info;
  }
  function metaBefore(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return infoBefore(code3);
    }
    effects.enter(types.codeFencedFenceMeta);
    effects.enter(types.chunkString, { contentType: constants2.contentTypeString });
    return meta(code3);
  }
  function meta(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceMeta);
      return infoBefore(code3);
    }
    if (code3 === codes.graveAccent && code3 === marker) {
      return nok(code3);
    }
    effects.consume(code3);
    return meta;
  }
  function atNonLazyBreak(code3) {
    ok(markdownLineEnding(code3), "expected eol");
    return effects.attempt(closeStart, after, contentBefore)(code3);
  }
  function contentBefore(code3) {
    ok(markdownLineEnding(code3), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return contentStart;
  }
  function contentStart(code3) {
    return initialPrefix > 0 && markdownSpace(code3) ? factorySpace(
      effects,
      beforeContentChunk,
      types.linePrefix,
      initialPrefix + 1
    )(code3) : beforeContentChunk(code3);
  }
  function beforeContentChunk(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code3);
    }
    effects.enter(types.codeFlowValue);
    return contentChunk(code3);
  }
  function contentChunk(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.codeFlowValue);
      return beforeContentChunk(code3);
    }
    effects.consume(code3);
    return contentChunk;
  }
  function after(code3) {
    effects.exit(types.codeFenced);
    return ok3(code3);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code3) {
      ok(markdownLineEnding(code3), "expected eol");
      effects2.enter(types.lineEnding);
      effects2.consume(code3);
      effects2.exit(types.lineEnding);
      return start2;
    }
    function start2(code3) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      effects2.enter(types.codeFencedFence);
      return markdownSpace(code3) ? factorySpace(
        effects2,
        beforeSequenceClose,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants2.tabSize
      )(code3) : beforeSequenceClose(code3);
    }
    function beforeSequenceClose(code3) {
      if (code3 === marker) {
        effects2.enter(types.codeFencedFenceSequence);
        return sequenceClose(code3);
      }
      return nok2(code3);
    }
    function sequenceClose(code3) {
      if (code3 === marker) {
        size++;
        effects2.consume(code3);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit(types.codeFencedFenceSequence);
        return markdownSpace(code3) ? factorySpace(effects2, sequenceCloseAfter, types.whitespace)(code3) : sequenceCloseAfter(code3);
      }
      return nok2(code3);
    }
    function sequenceCloseAfter(code3) {
      if (code3 === codes.eof || markdownLineEnding(code3)) {
        effects2.exit(types.codeFencedFence);
        return ok4(code3);
      }
      return nok2(code3);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    ok(markdownLineEnding(code3), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return lineStart;
  }
  function lineStart(code3) {
    return self2.parser.lazy[self2.now().line] ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = { partial: true, tokenize: tokenizeFurtherStart };
function tokenizeCodeIndented(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code3) {
    ok(markdownSpace(code3));
    effects.enter(types.codeIndented);
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants2.tabSize + 1
    )(code3);
  }
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants2.tabSize ? atBreak(code3) : nok(code3);
  }
  function atBreak(code3) {
    if (code3 === codes.eof) {
      return after(code3);
    }
    if (markdownLineEnding(code3)) {
      return effects.attempt(furtherStart, atBreak, after)(code3);
    }
    effects.enter(types.codeFlowValue);
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.codeFlowValue);
      return atBreak(code3);
    }
    effects.consume(code3);
    return inside;
  }
  function after(code3) {
    effects.exit(types.codeIndented);
    return ok3(code3);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code3) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return furtherStart2;
    }
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants2.tabSize + 1
    )(code3);
  }
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants2.tabSize ? ok3(code3) : markdownLineEnding(code3) ? furtherStart2(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-text.js
var codeText = {
  name: "codeText",
  previous,
  resolve: resolveCodeText,
  tokenize: tokenizeCodeText
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === types.codeTextData) {
        events[headEnterIndex][1].type = types.codeTextPadding;
        events[tailExitIndex][1].type = types.codeTextPadding;
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== types.lineEnding) {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === types.lineEnding) {
      events[enter][1].type = types.codeTextData;
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code3) {
  return code3 !== codes.graveAccent || this.events[this.events.length - 1][1].type === types.characterEscape;
}
function tokenizeCodeText(effects, ok3, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size;
  let token2;
  return start;
  function start(code3) {
    ok(code3 === codes.graveAccent, "expected `` ` ``");
    ok(previous.call(self2, self2.previous), "expected correct previous");
    effects.enter(types.codeText);
    effects.enter(types.codeTextSequence);
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === codes.graveAccent) {
      effects.consume(code3);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit(types.codeTextSequence);
    return between(code3);
  }
  function between(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === codes.space) {
      effects.enter("space");
      effects.consume(code3);
      effects.exit("space");
      return between;
    }
    if (code3 === codes.graveAccent) {
      token2 = effects.enter(types.codeTextSequence);
      size = 0;
      return sequenceClose(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return between;
    }
    effects.enter(types.codeTextData);
    return data(code3);
  }
  function data(code3) {
    if (code3 === codes.eof || code3 === codes.space || code3 === codes.graveAccent || markdownLineEnding(code3)) {
      effects.exit(types.codeTextData);
      return between(code3);
    }
    effects.consume(code3);
    return data;
  }
  function sequenceClose(code3) {
    if (code3 === codes.graveAccent) {
      effects.consume(code3);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit(types.codeTextSequence);
      effects.exit(types.codeText);
      return ok3(code3);
    }
    token2.type = types.codeTextData;
    return data(code3);
  }
}

// node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js
var SpliceBuffer = class {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(initial) {
    this.left = initial ? [...initial] : [];
    this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(index2) {
    if (index2 < 0 || index2 >= this.left.length + this.right.length) {
      throw new RangeError(
        "Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"
      );
    }
    if (index2 < this.left.length) return this.left[index2];
    return this.right[this.right.length - index2 + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    this.setCursor(0);
    return this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(start, end) {
    const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
    if (stop < this.left.length) {
      return this.left.slice(start, stop);
    }
    if (start > this.left.length) {
      return this.right.slice(
        this.right.length - stop + this.left.length,
        this.right.length - start + this.left.length
      ).reverse();
    }
    return this.left.slice(start).concat(
      this.right.slice(this.right.length - stop + this.left.length).reverse()
    );
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(start, deleteCount, items) {
    const count = deleteCount || 0;
    this.setCursor(Math.trunc(start));
    const removed = this.right.splice(
      this.right.length - count,
      Number.POSITIVE_INFINITY
    );
    if (items) chunkedPush(this.left, items);
    return removed.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    this.setCursor(Number.POSITIVE_INFINITY);
    return this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(item) {
    this.setCursor(Number.POSITIVE_INFINITY);
    this.left.push(item);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(items) {
    this.setCursor(Number.POSITIVE_INFINITY);
    chunkedPush(this.left, items);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(item) {
    this.setCursor(0);
    this.right.push(item);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(items) {
    this.setCursor(0);
    chunkedPush(this.right, items.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n) {
    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0)
      return;
    if (n < this.left.length) {
      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);
      chunkedPush(this.right, removed.reverse());
    } else {
      const removed = this.right.splice(
        this.left.length + this.right.length - n,
        Number.POSITIVE_INFINITY
      );
      chunkedPush(this.left, removed.reverse());
    }
  }
};
function chunkedPush(list4, right) {
  let chunkStart = 0;
  if (right.length < constants2.v8MaxSafeChunkSize) {
    list4.push(...right);
  } else {
    while (chunkStart < right.length) {
      list4.push(
        ...right.slice(chunkStart, chunkStart + constants2.v8MaxSafeChunkSize)
      );
      chunkStart += constants2.v8MaxSafeChunkSize;
    }
  }
}

// node_modules/micromark-util-subtokenize/dev/index.js
function subtokenize(eventsArray) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  const events = new SpliceBuffer(eventsArray);
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events.get(index2);
    if (index2 && event[1].type === types.chunkFlow && events.get(index2 - 1)[1].type === types.listItemPrefix) {
      ok(event[1]._tokenizer, "expected `_tokenizer` on subtokens");
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.lineEndingBlank) {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.content) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === types.content) {
            break;
          }
          if (subevents[otherIndex][1].type === types.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events.get(otherIndex);
        if (otherEvent[1].type === types.lineEnding || otherEvent[1].type === types.lineEndingBlank) {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events.get(lineIndex)[1].type = types.lineEndingBlank;
            }
            otherEvent[1].type = types.lineEnding;
            lineIndex = otherIndex;
          }
        } else if (otherEvent[1].type === types.linePrefix || otherEvent[1].type === types.listItemIndent) {
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = { ...events.get(lineIndex)[1].start };
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        events.splice(lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
  return !more;
}
function subcontent(events, eventIndex) {
  const token2 = events.get(eventIndex)[1];
  const context = events.get(eventIndex)[2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  ok(token2.contentType, "expected `contentType` on subtokens");
  let tokenizer2 = token2._tokenizer;
  if (!tokenizer2) {
    tokenizer2 = context.parser[token2.contentType](token2.start);
    if (token2._contentTypeTextTrailing) {
      tokenizer2._contentTypeTextTrailing = true;
    }
  }
  const childEvents = tokenizer2.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous3;
  let index2 = -1;
  let current = token2;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events.get(++startPosition)[1] !== current) {
    }
    ok(
      !previous3 || current.previous === previous3,
      "expected previous to match"
    );
    ok(!previous3 || previous3.next === current, "expected next to match");
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(codes.eof);
      }
      if (previous3) {
        tokenizer2.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer2._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer2.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer2._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous3 = current;
    current = current.next;
  }
  current = token2;
  while (++index2 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
    ) {
      ok(current, "expected a current token");
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer2.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
    ok(!current.next, "expected no next token");
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    ok(start2 !== void 0, "expected a start position when splicing");
    jumps.push([start2, start2 + slice.length - 1]);
    events.splice(start2, 2, slice);
  }
  jumps.reverse();
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/dev/lib/content.js
var content2 = { resolve: resolveContent, tokenize: tokenizeContent };
var continuationConstruct = { partial: true, tokenize: tokenizeContinuation };
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  let previous3;
  return chunkStart;
  function chunkStart(code3) {
    ok(
      code3 !== codes.eof && !markdownLineEnding(code3),
      "expected no eof or eol"
    );
    effects.enter(types.content);
    previous3 = effects.enter(types.chunkContent, {
      contentType: constants2.contentTypeContent
    });
    return chunkInside(code3);
  }
  function chunkInside(code3) {
    if (code3 === codes.eof) {
      return contentEnd(code3);
    }
    if (markdownLineEnding(code3)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code3);
    }
    effects.consume(code3);
    return chunkInside;
  }
  function contentEnd(code3) {
    effects.exit(types.chunkContent);
    effects.exit(types.content);
    return ok3(code3);
  }
  function contentContinue(code3) {
    ok(markdownLineEnding(code3), "expected eol");
    effects.consume(code3);
    effects.exit(types.chunkContent);
    ok(previous3, "expected previous token");
    previous3.next = effects.enter(types.chunkContent, {
      contentType: constants2.contentTypeContent,
      previous: previous3
    });
    previous3 = previous3.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code3) {
    ok(markdownLineEnding(code3), "expected a line ending");
    effects.exit(types.chunkContent);
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return factorySpace(effects, prefixed, types.linePrefix);
  }
  function prefixed(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return nok(code3);
    }
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants2.tabSize) {
      return ok3(code3);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code3);
  }
}

// node_modules/micromark-factory-destination/dev/index.js
function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code3) {
    if (code3 === codes.lessThan) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code3);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code3 === codes.eof || code3 === codes.space || code3 === codes.rightParenthesis || asciiControl(code3)) {
      return nok(code3);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants2.contentTypeString });
    return raw2(code3);
  }
  function enclosedBefore(code3) {
    if (code3 === codes.greaterThan) {
      effects.enter(literalMarkerType);
      effects.consume(code3);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants2.contentTypeString });
    return enclosed(code3);
  }
  function enclosed(code3) {
    if (code3 === codes.greaterThan) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      return enclosedBefore(code3);
    }
    if (code3 === codes.eof || code3 === codes.lessThan || markdownLineEnding(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return code3 === codes.backslash ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code3) {
    if (code3 === codes.lessThan || code3 === codes.greaterThan || code3 === codes.backslash) {
      effects.consume(code3);
      return enclosed;
    }
    return enclosed(code3);
  }
  function raw2(code3) {
    if (!balance && (code3 === codes.eof || code3 === codes.rightParenthesis || markdownLineEndingOrSpace(code3))) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok3(code3);
    }
    if (balance < limit && code3 === codes.leftParenthesis) {
      effects.consume(code3);
      balance++;
      return raw2;
    }
    if (code3 === codes.rightParenthesis) {
      effects.consume(code3);
      balance--;
      return raw2;
    }
    if (code3 === codes.eof || code3 === codes.space || code3 === codes.leftParenthesis || asciiControl(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return code3 === codes.backslash ? rawEscape : raw2;
  }
  function rawEscape(code3) {
    if (code3 === codes.leftParenthesis || code3 === codes.rightParenthesis || code3 === codes.backslash) {
      effects.consume(code3);
      return raw2;
    }
    return raw2(code3);
  }
}

// node_modules/micromark-factory-label/dev/index.js
function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let seen2;
  return start;
  function start(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code3);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code3) {
    if (size > constants2.linkReferenceSizeMax || code3 === codes.eof || code3 === codes.leftSquareBracket || code3 === codes.rightSquareBracket && !seen2 || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code3 === codes.caret && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code3);
    }
    if (code3 === codes.rightSquareBracket) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return atBreak;
    }
    effects.enter(types.chunkString, { contentType: constants2.contentTypeString });
    return labelInside(code3);
  }
  function labelInside(code3) {
    if (code3 === codes.eof || code3 === codes.leftSquareBracket || code3 === codes.rightSquareBracket || markdownLineEnding(code3) || size++ > constants2.linkReferenceSizeMax) {
      effects.exit(types.chunkString);
      return atBreak(code3);
    }
    effects.consume(code3);
    if (!seen2) seen2 = !markdownSpace(code3);
    return code3 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code3) {
    if (code3 === codes.leftSquareBracket || code3 === codes.backslash || code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      size++;
      return labelInside;
    }
    return labelInside(code3);
  }
}

// node_modules/micromark-factory-title/dev/index.js
function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code3) {
    if (code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.leftParenthesis) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      marker = code3 === codes.leftParenthesis ? codes.rightParenthesis : code3;
      return begin;
    }
    return nok(code3);
  }
  function begin(code3) {
    if (code3 === marker) {
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code3);
  }
  function atBreak(code3) {
    if (code3 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return factorySpace(effects, atBreak, types.linePrefix);
    }
    effects.enter(types.chunkString, { contentType: constants2.contentTypeString });
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker || code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.chunkString);
      return atBreak(code3);
    }
    effects.consume(code3);
    return code3 === codes.backslash ? escape : inside;
  }
  function escape(code3) {
    if (code3 === marker || code3 === codes.backslash) {
      effects.consume(code3);
      return inside;
    }
    return inside(code3);
  }
}

// node_modules/micromark-factory-whitespace/dev/index.js
function factoryWhitespace(effects, ok3) {
  let seen2;
  return start;
  function start(code3) {
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      seen2 = true;
      return start;
    }
    if (markdownSpace(code3)) {
      return factorySpace(
        effects,
        start,
        seen2 ? types.linePrefix : types.lineSuffix
      )(code3);
    }
    return ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/definition.js
var definition = { name: "definition", tokenize: tokenizeDefinition };
var titleBefore = { partial: true, tokenize: tokenizeTitleBefore };
function tokenizeDefinition(effects, ok3, nok) {
  const self2 = this;
  let identifier;
  return start;
  function start(code3) {
    effects.enter(types.definition);
    return before(code3);
  }
  function before(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      types.definitionLabel,
      types.definitionLabelMarker,
      types.definitionLabelString
    )(code3);
  }
  function labelAfter(code3) {
    identifier = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code3 === codes.colon) {
      effects.enter(types.definitionMarker);
      effects.consume(code3);
      effects.exit(types.definitionMarker);
      return markerAfter;
    }
    return nok(code3);
  }
  function markerAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, destinationBefore)(code3) : destinationBefore(code3);
  }
  function destinationBefore(code3) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      types.definitionDestination,
      types.definitionDestinationLiteral,
      types.definitionDestinationLiteralMarker,
      types.definitionDestinationRaw,
      types.definitionDestinationString
    )(code3);
  }
  function destinationAfter(code3) {
    return effects.attempt(titleBefore, after, after)(code3);
  }
  function after(code3) {
    return markdownSpace(code3) ? factorySpace(effects, afterWhitespace, types.whitespace)(code3) : afterWhitespace(code3);
  }
  function afterWhitespace(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.definition);
      self2.parser.defined.push(identifier);
      return ok3(code3);
    }
    return nok(code3);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, beforeMarker)(code3) : nok(code3);
  }
  function beforeMarker(code3) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      types.definitionTitle,
      types.definitionTitleMarker,
      types.definitionTitleString
    )(code3);
  }
  function titleAfter(code3) {
    return markdownSpace(code3) ? factorySpace(
      effects,
      titleAfterOptionalWhitespace,
      types.whitespace
    )(code3) : titleAfterOptionalWhitespace(code3);
  }
  function titleAfterOptionalWhitespace(code3) {
    return code3 === codes.eof || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start;
  function start(code3) {
    ok(code3 === codes.backslash, "expected `\\`");
    effects.enter(types.hardBreakEscape);
    effects.consume(code3);
    return after;
  }
  function after(code3) {
    if (markdownLineEnding(code3)) {
      effects.exit(types.hardBreakEscape);
      return ok3(code3);
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  resolve: resolveHeadingAtx,
  tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text6;
  if (events[contentStart][1].type === types.whitespace) {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types.whitespace) {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === types.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types.whitespace)) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: types.atxHeadingText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text6 = {
      type: types.chunkText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: constants2.contentTypeText
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text6, context],
      ["exit", text6, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size = 0;
  return start;
  function start(code3) {
    effects.enter(types.atxHeading);
    return before(code3);
  }
  function before(code3) {
    ok(code3 === codes.numberSign, "expected `#`");
    effects.enter(types.atxHeadingSequence);
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === codes.numberSign && size++ < constants2.atxHeadingOpeningFenceSizeMax) {
      effects.consume(code3);
      return sequenceOpen;
    }
    if (code3 === codes.eof || markdownLineEndingOrSpace(code3)) {
      effects.exit(types.atxHeadingSequence);
      return atBreak(code3);
    }
    return nok(code3);
  }
  function atBreak(code3) {
    if (code3 === codes.numberSign) {
      effects.enter(types.atxHeadingSequence);
      return sequenceFurther(code3);
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.atxHeading);
      return ok3(code3);
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, atBreak, types.whitespace)(code3);
    }
    effects.enter(types.atxHeadingText);
    return data(code3);
  }
  function sequenceFurther(code3) {
    if (code3 === codes.numberSign) {
      effects.consume(code3);
      return sequenceFurther;
    }
    effects.exit(types.atxHeadingSequence);
    return atBreak(code3);
  }
  function data(code3) {
    if (code3 === codes.eof || code3 === codes.numberSign || markdownLineEndingOrSpace(code3)) {
      effects.exit(types.atxHeadingText);
      return atBreak(code3);
    }
    effects.consume(code3);
    return data;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/dev/lib/html-flow.js
var htmlFlow = {
  concrete: true,
  name: "htmlFlow",
  resolveTo: resolveToHtmlFlow,
  tokenize: tokenizeHtmlFlow
};
var blankLineBefore = { partial: true, tokenize: tokenizeBlankLineBefore };
var nonLazyContinuationStart = {
  partial: true,
  tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === types.htmlFlow) {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === types.linePrefix) {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index2;
  let markerB;
  return start;
  function start(code3) {
    return before(code3);
  }
  function before(code3) {
    ok(code3 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlFlow);
    effects.enter(types.htmlFlowData);
    effects.consume(code3);
    return open;
  }
  function open(code3) {
    if (code3 === codes.exclamationMark) {
      effects.consume(code3);
      return declarationOpen;
    }
    if (code3 === codes.slash) {
      effects.consume(code3);
      closingTag = true;
      return tagCloseStart;
    }
    if (code3 === codes.questionMark) {
      effects.consume(code3);
      marker = constants2.htmlInstruction;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code3)) {
      ok(code3 !== null);
      effects.consume(code3);
      buffer = String.fromCharCode(code3);
      return tagName;
    }
    return nok(code3);
  }
  function declarationOpen(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      marker = constants2.htmlComment;
      return commentOpenInside;
    }
    if (code3 === codes.leftSquareBracket) {
      effects.consume(code3);
      marker = constants2.htmlCdata;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      marker = constants2.htmlDeclaration;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code3);
  }
  function commentOpenInside(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code3);
  }
  function cdataOpenInside(code3) {
    const value = constants2.cdataOpeningString;
    if (code3 === value.charCodeAt(index2++)) {
      effects.consume(code3);
      if (index2 === value.length) {
        return self2.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code3);
  }
  function tagCloseStart(code3) {
    if (asciiAlpha(code3)) {
      ok(code3 !== null);
      effects.consume(code3);
      buffer = String.fromCharCode(code3);
      return tagName;
    }
    return nok(code3);
  }
  function tagName(code3) {
    if (code3 === codes.eof || code3 === codes.slash || code3 === codes.greaterThan || markdownLineEndingOrSpace(code3)) {
      const slash = code3 === codes.slash;
      const name = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker = constants2.htmlRaw;
        return self2.interrupt ? ok3(code3) : continuation(code3);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = constants2.htmlBasic;
        if (slash) {
          effects.consume(code3);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok3(code3) : continuation(code3);
      }
      marker = constants2.htmlComplete;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code3) : closingTag ? completeClosingTagAfter(code3) : completeAttributeNameBefore(code3);
    }
    if (code3 === codes.dash || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      buffer += String.fromCharCode(code3);
      return tagName;
    }
    return nok(code3);
  }
  function basicSelfClosing(code3) {
    if (code3 === codes.greaterThan) {
      effects.consume(code3);
      return self2.interrupt ? ok3 : continuation;
    }
    return nok(code3);
  }
  function completeClosingTagAfter(code3) {
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeClosingTagAfter;
    }
    return completeEnd(code3);
  }
  function completeAttributeNameBefore(code3) {
    if (code3 === codes.slash) {
      effects.consume(code3);
      return completeEnd;
    }
    if (code3 === codes.colon || code3 === codes.underscore || asciiAlpha(code3)) {
      effects.consume(code3);
      return completeAttributeName;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeNameBefore;
    }
    return completeEnd(code3);
  }
  function completeAttributeName(code3) {
    if (code3 === codes.dash || code3 === codes.dot || code3 === codes.colon || code3 === codes.underscore || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code3);
  }
  function completeAttributeNameAfter(code3) {
    if (code3 === codes.equalsTo) {
      effects.consume(code3);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code3);
  }
  function completeAttributeValueBefore(code3) {
    if (code3 === codes.eof || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.graveAccent) {
      return nok(code3);
    }
    if (code3 === codes.quotationMark || code3 === codes.apostrophe) {
      effects.consume(code3);
      markerB = code3;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code3);
  }
  function completeAttributeValueQuoted(code3) {
    if (code3 === markerB) {
      effects.consume(code3);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code3) {
    if (code3 === codes.eof || code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.slash || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.graveAccent || markdownLineEndingOrSpace(code3)) {
      return completeAttributeNameAfter(code3);
    }
    effects.consume(code3);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code3) {
    if (code3 === codes.slash || code3 === codes.greaterThan || markdownSpace(code3)) {
      return completeAttributeNameBefore(code3);
    }
    return nok(code3);
  }
  function completeEnd(code3) {
    if (code3 === codes.greaterThan) {
      effects.consume(code3);
      return completeAfter;
    }
    return nok(code3);
  }
  function completeAfter(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return continuation(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAfter;
    }
    return nok(code3);
  }
  function continuation(code3) {
    if (code3 === codes.dash && marker === constants2.htmlComment) {
      effects.consume(code3);
      return continuationCommentInside;
    }
    if (code3 === codes.lessThan && marker === constants2.htmlRaw) {
      effects.consume(code3);
      return continuationRawTagOpen;
    }
    if (code3 === codes.greaterThan && marker === constants2.htmlDeclaration) {
      effects.consume(code3);
      return continuationClose;
    }
    if (code3 === codes.questionMark && marker === constants2.htmlInstruction) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    if (code3 === codes.rightSquareBracket && marker === constants2.htmlCdata) {
      effects.consume(code3);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code3) && (marker === constants2.htmlBasic || marker === constants2.htmlComplete)) {
      effects.exit(types.htmlFlowData);
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code3);
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.htmlFlowData);
      return continuationStart(code3);
    }
    effects.consume(code3);
    return continuation;
  }
  function continuationStart(code3) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code3);
  }
  function continuationStartNonLazy(code3) {
    ok(markdownLineEnding(code3));
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return continuationBefore;
  }
  function continuationBefore(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return continuationStart(code3);
    }
    effects.enter(types.htmlFlowData);
    return continuation(code3);
  }
  function continuationCommentInside(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationRawTagOpen(code3) {
    if (code3 === codes.slash) {
      effects.consume(code3);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code3);
  }
  function continuationRawEndTag(code3) {
    if (code3 === codes.greaterThan) {
      const name = buffer.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code3);
        return continuationClose;
      }
      return continuation(code3);
    }
    if (asciiAlpha(code3) && buffer.length < constants2.htmlRawSizeMax) {
      ok(code3 !== null);
      effects.consume(code3);
      buffer += String.fromCharCode(code3);
      return continuationRawEndTag;
    }
    return continuation(code3);
  }
  function continuationCdataInside(code3) {
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationDeclarationInside(code3) {
    if (code3 === codes.greaterThan) {
      effects.consume(code3);
      return continuationClose;
    }
    if (code3 === codes.dash && marker === constants2.htmlComment) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationClose(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.htmlFlowData);
      return continuationAfter(code3);
    }
    effects.consume(code3);
    return continuationClose;
  }
  function continuationAfter(code3) {
    effects.exit(types.htmlFlow);
    return ok3(code3);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code3) {
    if (markdownLineEnding(code3)) {
      effects.enter(types.lineEnding);
      effects.consume(code3);
      effects.exit(types.lineEnding);
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    return self2.parser.lazy[self2.now().line] ? nok(code3) : ok3(code3);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start;
  function start(code3) {
    ok(markdownLineEnding(code3), "expected a line ending");
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return effects.attempt(blankLine, ok3, nok);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/html-text.js
var htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
function tokenizeHtmlText(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start;
  function start(code3) {
    ok(code3 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlText);
    effects.enter(types.htmlTextData);
    effects.consume(code3);
    return open;
  }
  function open(code3) {
    if (code3 === codes.exclamationMark) {
      effects.consume(code3);
      return declarationOpen;
    }
    if (code3 === codes.slash) {
      effects.consume(code3);
      return tagCloseStart;
    }
    if (code3 === codes.questionMark) {
      effects.consume(code3);
      return instruction;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return tagOpen;
    }
    return nok(code3);
  }
  function declarationOpen(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentOpenInside;
    }
    if (code3 === codes.leftSquareBracket) {
      effects.consume(code3);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return declaration;
    }
    return nok(code3);
  }
  function commentOpenInside(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentEnd;
    }
    return nok(code3);
  }
  function comment2(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = comment2;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return comment2;
  }
  function commentClose(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return commentEnd;
    }
    return comment2(code3);
  }
  function commentEnd(code3) {
    return code3 === codes.greaterThan ? end(code3) : code3 === codes.dash ? commentClose(code3) : comment2(code3);
  }
  function cdataOpenInside(code3) {
    const value = constants2.cdataOpeningString;
    if (code3 === value.charCodeAt(index2++)) {
      effects.consume(code3);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code3);
  }
  function cdata(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return cdataClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = cdata;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return cdata;
  }
  function cdataClose(code3) {
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return cdataEnd;
    }
    return cdata(code3);
  }
  function cdataEnd(code3) {
    if (code3 === codes.greaterThan) {
      return end(code3);
    }
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return cdataEnd;
    }
    return cdata(code3);
  }
  function declaration(code3) {
    if (code3 === codes.eof || code3 === codes.greaterThan) {
      return end(code3);
    }
    if (markdownLineEnding(code3)) {
      returnState = declaration;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return declaration;
  }
  function instruction(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === codes.questionMark) {
      effects.consume(code3);
      return instructionClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = instruction;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return instruction;
  }
  function instructionClose(code3) {
    return code3 === codes.greaterThan ? end(code3) : instruction(code3);
  }
  function tagCloseStart(code3) {
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return tagClose;
    }
    return nok(code3);
  }
  function tagClose(code3) {
    if (code3 === codes.dash || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagClose;
    }
    return tagCloseBetween(code3);
  }
  function tagCloseBetween(code3) {
    if (markdownLineEnding(code3)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagCloseBetween;
    }
    return end(code3);
  }
  function tagOpen(code3) {
    if (code3 === codes.dash || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagOpen;
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    return nok(code3);
  }
  function tagOpenBetween(code3) {
    if (code3 === codes.slash) {
      effects.consume(code3);
      return end;
    }
    if (code3 === codes.colon || code3 === codes.underscore || asciiAlpha(code3)) {
      effects.consume(code3);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenBetween;
    }
    return end(code3);
  }
  function tagOpenAttributeName(code3) {
    if (code3 === codes.dash || code3 === codes.dot || code3 === codes.colon || code3 === codes.underscore || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code3);
  }
  function tagOpenAttributeNameAfter(code3) {
    if (code3 === codes.equalsTo) {
      effects.consume(code3);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code3);
  }
  function tagOpenAttributeValueBefore(code3) {
    if (code3 === codes.eof || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.graveAccent) {
      return nok(code3);
    }
    if (code3 === codes.quotationMark || code3 === codes.apostrophe) {
      effects.consume(code3);
      marker = code3;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code3);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code3) {
    if (code3 === codes.eof || code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.lessThan || code3 === codes.equalsTo || code3 === codes.graveAccent) {
      return nok(code3);
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    effects.consume(code3);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code3) {
    if (code3 === codes.slash || code3 === codes.greaterThan || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    return nok(code3);
  }
  function end(code3) {
    if (code3 === codes.greaterThan) {
      effects.consume(code3);
      effects.exit(types.htmlTextData);
      effects.exit(types.htmlText);
      return ok3;
    }
    return nok(code3);
  }
  function lineEndingBefore(code3) {
    ok(returnState, "expected return state");
    ok(markdownLineEnding(code3), "expected eol");
    effects.exit(types.htmlTextData);
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return lineEndingAfter;
  }
  function lineEndingAfter(code3) {
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return markdownSpace(code3) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants2.tabSize
    )(code3) : lineEndingAfterPrefix(code3);
  }
  function lineEndingAfterPrefix(code3) {
    effects.enter(types.htmlTextData);
    return returnState(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  resolveAll: resolveAllLabelEnd,
  resolveTo: resolveToLabelEnd,
  tokenize: tokenizeLabelEnd
};
var resourceConstruct = { tokenize: tokenizeResource };
var referenceFullConstruct = { tokenize: tokenizeReferenceFull };
var referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events) {
  let index2 = -1;
  const newEvents = [];
  while (++index2 < events.length) {
    const token2 = events[index2][1];
    newEvents.push(events[index2]);
    if (token2.type === types.labelImage || token2.type === types.labelLink || token2.type === types.labelEnd) {
      const offset = token2.type === types.labelImage ? 4 : 2;
      token2.type = types.data;
      index2 += offset;
    }
  }
  if (events.length !== newEvents.length) {
    splice(events, 0, events.length, newEvents);
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token2;
  let open;
  let close;
  let media;
  while (index2--) {
    token2 = events[index2][1];
    if (open) {
      if (token2.type === types.link || token2.type === types.labelLink && token2._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token2.type === types.labelLink) {
        token2._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token2.type === types.labelImage || token2.type === types.labelLink) && !token2._balanced) {
        open = index2;
        if (token2.type !== types.labelLink) {
          offset = 2;
          break;
        }
      }
    } else if (token2.type === types.labelEnd) {
      close = index2;
    }
  }
  ok(open !== void 0, "`open` is supposed to be found");
  ok(close !== void 0, "`close` is supposed to be found");
  const group = {
    type: events[open][1].type === types.labelLink ? types.link : types.image,
    start: { ...events[open][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  const label = {
    type: types.label,
    start: { ...events[open][1].start },
    end: { ...events[close][1].end }
  };
  const text6 = {
    type: types.labelText,
    start: { ...events[open + offset + 2][1].end },
    end: { ...events[close - 2][1].start }
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text6, context]]);
  ok(
    context.parser.constructs.insideSpan.null,
    "expected `insideSpan.null` to be populated"
  );
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text6, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === types.labelImage || self2.events[index2][1].type === types.labelLink) && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start;
  function start(code3) {
    ok(code3 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart) {
      return nok(code3);
    }
    if (labelStart._inactive) {
      return labelEndNok(code3);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
      )
    );
    effects.enter(types.labelEnd);
    effects.enter(types.labelMarker);
    effects.consume(code3);
    effects.exit(types.labelMarker);
    effects.exit(types.labelEnd);
    return after;
  }
  function after(code3) {
    if (code3 === codes.leftParenthesis) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code3);
    }
    if (code3 === codes.leftSquareBracket) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code3);
    }
    return defined ? labelEndOk(code3) : labelEndNok(code3);
  }
  function referenceNotFull(code3) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code3);
  }
  function labelEndOk(code3) {
    return ok3(code3);
  }
  function labelEndNok(code3) {
    labelStart._balanced = true;
    return nok(code3);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code3) {
    ok(code3 === codes.leftParenthesis, "expected left paren");
    effects.enter(types.resource);
    effects.enter(types.resourceMarker);
    effects.consume(code3);
    effects.exit(types.resourceMarker);
    return resourceBefore;
  }
  function resourceBefore(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceOpen)(code3) : resourceOpen(code3);
  }
  function resourceOpen(code3) {
    if (code3 === codes.rightParenthesis) {
      return resourceEnd(code3);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      types.resourceDestination,
      types.resourceDestinationLiteral,
      types.resourceDestinationLiteralMarker,
      types.resourceDestinationRaw,
      types.resourceDestinationString,
      constants2.linkResourceDestinationBalanceMax
    )(code3);
  }
  function resourceDestinationAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceBetween)(code3) : resourceEnd(code3);
  }
  function resourceDestinationMissing(code3) {
    return nok(code3);
  }
  function resourceBetween(code3) {
    if (code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.leftParenthesis) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        types.resourceTitle,
        types.resourceTitleMarker,
        types.resourceTitleString
      )(code3);
    }
    return resourceEnd(code3);
  }
  function resourceTitleAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceEnd)(code3) : resourceEnd(code3);
  }
  function resourceEnd(code3) {
    if (code3 === codes.rightParenthesis) {
      effects.enter(types.resourceMarker);
      effects.consume(code3);
      effects.exit(types.resourceMarker);
      effects.exit(types.resource);
      return ok3;
    }
    return nok(code3);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code3) {
    ok(code3 === codes.leftSquareBracket, "expected left bracket");
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      types.reference,
      types.referenceMarker,
      types.referenceString
    )(code3);
  }
  function referenceFullAfter(code3) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok3(code3) : nok(code3);
  }
  function referenceFullMissing(code3) {
    return nok(code3);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code3) {
    ok(code3 === codes.leftSquareBracket, "expected left bracket");
    effects.enter(types.reference);
    effects.enter(types.referenceMarker);
    effects.consume(code3);
    effects.exit(types.referenceMarker);
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code3) {
    if (code3 === codes.rightSquareBracket) {
      effects.enter(types.referenceMarker);
      effects.consume(code3);
      effects.exit(types.referenceMarker);
      effects.exit(types.reference);
      return ok3;
    }
    return nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code3) {
    ok(code3 === codes.exclamationMark, "expected `!`");
    effects.enter(types.labelImage);
    effects.enter(types.labelImageMarker);
    effects.consume(code3);
    effects.exit(types.labelImageMarker);
    return open;
  }
  function open(code3) {
    if (code3 === codes.leftSquareBracket) {
      effects.enter(types.labelMarker);
      effects.consume(code3);
      effects.exit(types.labelMarker);
      effects.exit(types.labelImage);
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    return code3 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    effects.enter(types.labelLink);
    effects.enter(types.labelMarker);
    effects.consume(code3);
    effects.exit(types.labelMarker);
    effects.exit(types.labelLink);
    return after;
  }
  function after(code3) {
    return code3 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code3) : ok3(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/line-ending.js
var lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
function tokenizeLineEnding(effects, ok3) {
  return start;
  function start(code3) {
    ok(markdownLineEnding(code3), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    return factorySpace(effects, ok3, types.linePrefix);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code3) {
    effects.enter(types.thematicBreak);
    return before(code3);
  }
  function before(code3) {
    ok(
      code3 === codes.asterisk || code3 === codes.dash || code3 === codes.underscore,
      "expected `*`, `-`, or `_`"
    );
    marker = code3;
    return atBreak(code3);
  }
  function atBreak(code3) {
    if (code3 === marker) {
      effects.enter(types.thematicBreakSequence);
      return sequence(code3);
    }
    if (size >= constants2.thematicBreakMarkerCountMin && (code3 === codes.eof || markdownLineEnding(code3))) {
      effects.exit(types.thematicBreak);
      return ok3(code3);
    }
    return nok(code3);
  }
  function sequence(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      size++;
      return sequence;
    }
    effects.exit(types.thematicBreakSequence);
    return markdownSpace(code3) ? factorySpace(effects, atBreak, types.whitespace)(code3) : atBreak(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/list.js
var list = {
  continuation: { tokenize: tokenizeListContinuation },
  exit: tokenizeListEnd,
  name: "list",
  tokenize: tokenizeListStart
};
var listItemPrefixWhitespaceConstruct = {
  partial: true,
  tokenize: tokenizeListItemPrefixWhitespace
};
var indentConstruct = { partial: true, tokenize: tokenizeIndent };
function tokenizeListStart(effects, ok3, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code3) {
    ok(self2.containerState, "expected state");
    const kind = self2.containerState.type || (code3 === codes.asterisk || code3 === codes.plusSign || code3 === codes.dash ? types.listUnordered : types.listOrdered);
    if (kind === types.listUnordered ? !self2.containerState.marker || code3 === self2.containerState.marker : asciiDigit(code3)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, { _container: true });
      }
      if (kind === types.listUnordered) {
        effects.enter(types.listItemPrefix);
        return code3 === codes.asterisk || code3 === codes.dash ? effects.check(thematicBreak, nok, atMarker)(code3) : atMarker(code3);
      }
      if (!self2.interrupt || code3 === codes.digit1) {
        effects.enter(types.listItemPrefix);
        effects.enter(types.listItemValue);
        return inside(code3);
      }
    }
    return nok(code3);
  }
  function inside(code3) {
    ok(self2.containerState, "expected state");
    if (asciiDigit(code3) && ++size < constants2.listItemValueSizeMax) {
      effects.consume(code3);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code3 === self2.containerState.marker : code3 === codes.rightParenthesis || code3 === codes.dot)) {
      effects.exit(types.listItemValue);
      return atMarker(code3);
    }
    return nok(code3);
  }
  function atMarker(code3) {
    ok(self2.containerState, "expected state");
    ok(code3 !== codes.eof, "eof (`null`) is not a marker");
    effects.enter(types.listItemMarker);
    effects.consume(code3);
    effects.exit(types.listItemMarker);
    self2.containerState.marker = self2.containerState.marker || code3;
    return effects.check(
      blankLine,
      // Can’t be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code3) {
    ok(self2.containerState, "expected state");
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code3);
  }
  function otherPrefix(code3) {
    if (markdownSpace(code3)) {
      effects.enter(types.listItemPrefixWhitespace);
      effects.consume(code3);
      effects.exit(types.listItemPrefixWhitespace);
      return endOfPrefix;
    }
    return nok(code3);
  }
  function endOfPrefix(code3) {
    ok(self2.containerState, "expected state");
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit(types.listItemPrefix), true).length;
    return ok3(code3);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code3) {
    ok(self2.containerState, "expected state");
    ok(typeof self2.containerState.size === "number", "expected size");
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok3,
      types.listItemIndent,
      self2.containerState.size + 1
    )(code3);
  }
  function notBlank(code3) {
    ok(self2.containerState, "expected state");
    if (self2.containerState.furtherBlankLines || !markdownSpace(code3)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code3);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code3);
  }
  function notInCurrentItem(code3) {
    ok(self2.containerState, "expected state");
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return factorySpace(
      effects,
      effects.attempt(list, ok3, nok),
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants2.tabSize
    )(code3);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  ok(typeof self2.containerState.size === "number", "expected size");
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemIndent,
    self2.containerState.size + 1
  );
  function afterPrefix(code3) {
    ok(self2.containerState, "expected state");
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.listItemIndent && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code3) : nok(code3);
  }
}
function tokenizeListEnd(effects) {
  ok(this.containerState, "expected state");
  ok(typeof this.containerState.type === "string", "expected type");
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self2 = this;
  ok(
    self2.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemPrefixWhitespace,
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants2.tabSize + 1
  );
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code3) && tail && tail[1].type === types.listItemPrefixWhitespace ? ok3(code3) : nok(code3);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  resolveTo: resolveToSetextUnderline,
  tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text6;
  let definition3;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === types.content) {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === types.paragraph) {
        text6 = index2;
      }
    } else {
      if (events[index2][1].type === types.content) {
        events.splice(index2, 1);
      }
      if (!definition3 && events[index2][1].type === types.definition) {
        definition3 = index2;
      }
    }
  }
  ok(text6 !== void 0, "expected a `text` index to be found");
  ok(content3 !== void 0, "expected a `text` index to be found");
  ok(events[content3][2] === context, "enter context should be same");
  ok(
    events[events.length - 1][2] === context,
    "enter context should be same"
  );
  const heading3 = {
    type: types.setextHeading,
    start: { ...events[content3][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  events[text6][1].type = types.setextHeadingText;
  if (definition3) {
    events.splice(text6, 0, ["enter", heading3, context]);
    events.splice(definition3 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = { ...events[definition3][1].end };
  } else {
    events[content3][1] = heading3;
  }
  events.push(["exit", heading3, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self2 = this;
  let marker;
  return start;
  function start(code3) {
    let index2 = self2.events.length;
    let paragraph3;
    ok(
      code3 === codes.dash || code3 === codes.equalsTo,
      "expected `=` or `-`"
    );
    while (index2--) {
      if (self2.events[index2][1].type !== types.lineEnding && self2.events[index2][1].type !== types.linePrefix && self2.events[index2][1].type !== types.content) {
        paragraph3 = self2.events[index2][1].type === types.paragraph;
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph3)) {
      effects.enter(types.setextHeadingLine);
      marker = code3;
      return before(code3);
    }
    return nok(code3);
  }
  function before(code3) {
    effects.enter(types.setextHeadingLineSequence);
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      return inside;
    }
    effects.exit(types.setextHeadingLineSequence);
    return markdownSpace(code3) ? factorySpace(effects, after, types.lineSuffix)(code3) : after(code3);
  }
  function after(code3) {
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit(types.setextHeadingLine);
      return ok3(code3);
    }
    return nok(code3);
  }
}

// node_modules/micromark/dev/lib/initialize/flow.js
var flow = { tokenize: initializeFlow };
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content2, afterConstruct)
        ),
        types.linePrefix
      )
    )
  );
  return initial;
  function atBlankEnding(code3) {
    ok(
      code3 === codes.eof || markdownLineEnding(code3),
      "expected eol or eof"
    );
    if (code3 === codes.eof) {
      effects.consume(code3);
      return;
    }
    effects.enter(types.lineEndingBlank);
    effects.consume(code3);
    effects.exit(types.lineEndingBlank);
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code3) {
    ok(
      code3 === codes.eof || markdownLineEnding(code3),
      "expected eol or eof"
    );
    if (code3 === codes.eof) {
      effects.consume(code3);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code3);
    effects.exit(types.lineEnding);
    self2.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/micromark/dev/lib/initialize/text.js
var resolver = { resolveAll: createResolver() };
var string2 = initializeFactory("string");
var text2 = initializeFactory("text");
function initializeFactory(field) {
  return {
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    ),
    tokenize: initializeText
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text6 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code3) {
      return atBreak(code3) ? text6(code3) : notText(code3);
    }
    function notText(code3) {
      if (code3 === codes.eof) {
        effects.consume(code3);
        return;
      }
      effects.enter(types.data);
      effects.consume(code3);
      return data;
    }
    function data(code3) {
      if (atBreak(code3)) {
        effects.exit(types.data);
        return text6(code3);
      }
      effects.consume(code3);
      return data;
    }
    function atBreak(code3) {
      if (code3 === codes.eof) {
        return true;
      }
      const list4 = constructs2[code3];
      let index2 = -1;
      if (list4) {
        ok(Array.isArray(list4), "expected `disable.null` to be populated");
        while (++index2 < list4.length) {
          const item = list4[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === types.data) {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== types.data) {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === types.lineEnding) && events[eventIndex - 1][1].type === types.data) {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === codes.horizontalTab) {
          tabs = true;
          size++;
        } else if (chunk === codes.virtualSpace) {
        } else {
          index2++;
          break;
        }
      }
      if (context._contentTypeTextTrailing && eventIndex === events.length) {
        size = 0;
      }
      if (size) {
        const token2 = {
          type: eventIndex === events.length || tabs || size < constants2.hardBreakPrefixSizeMin ? types.lineSuffix : types.hardBreakTrailing,
          start: {
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex,
            _index: data.start._index + index2,
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size
          },
          end: { ...data.end }
        };
        data.end = { ...token2.start };
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token2);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token2, context],
            ["exit", token2, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/dev/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string3,
  text: () => text3
});
var document3 = {
  [codes.asterisk]: list,
  [codes.plusSign]: list,
  [codes.dash]: list,
  [codes.digit0]: list,
  [codes.digit1]: list,
  [codes.digit2]: list,
  [codes.digit3]: list,
  [codes.digit4]: list,
  [codes.digit5]: list,
  [codes.digit6]: list,
  [codes.digit7]: list,
  [codes.digit8]: list,
  [codes.digit9]: list,
  [codes.greaterThan]: blockQuote
};
var contentInitial = {
  [codes.leftSquareBracket]: definition
};
var flowInitial = {
  [codes.horizontalTab]: codeIndented,
  [codes.virtualSpace]: codeIndented,
  [codes.space]: codeIndented
};
var flow2 = {
  [codes.numberSign]: headingAtx,
  [codes.asterisk]: thematicBreak,
  [codes.dash]: [setextUnderline, thematicBreak],
  [codes.lessThan]: htmlFlow,
  [codes.equalsTo]: setextUnderline,
  [codes.underscore]: thematicBreak,
  [codes.graveAccent]: codeFenced,
  [codes.tilde]: codeFenced
};
var string3 = {
  [codes.ampersand]: characterReference,
  [codes.backslash]: characterEscape
};
var text3 = {
  [codes.carriageReturn]: lineEnding,
  [codes.lineFeed]: lineEnding,
  [codes.carriageReturnLineFeed]: lineEnding,
  [codes.exclamationMark]: labelStartImage,
  [codes.ampersand]: characterReference,
  [codes.asterisk]: attention,
  [codes.lessThan]: [autolink, htmlText],
  [codes.leftSquareBracket]: labelStartLink,
  [codes.backslash]: [hardBreakEscape, characterEscape],
  [codes.rightSquareBracket]: labelEnd,
  [codes.underscore]: attention,
  [codes.graveAccent]: codeText
};
var insideSpan = { null: [attention, resolver] };
var attentionMarkers = { null: [codes.asterisk, codes.underscore] };
var disable = { null: [] };

// node_modules/micromark/dev/lib/create-tokenizer.js
var import_debug = __toESM(require_browser(), 1);
var debug = (0, import_debug.default)("micromark");
function createTokenizer(parser, initialize, from) {
  let point4 = {
    _bufferIndex: -1,
    _index: 0,
    line: from && from.line || 1,
    column: from && from.column || 1,
    offset: from && from.offset || 0
  };
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack2 = [];
  let consumed = true;
  const effects = {
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    consume,
    enter,
    exit: exit3,
    interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
  };
  const context = {
    code: codes.eof,
    containerState: {},
    defineSkip,
    events: [],
    now,
    parser,
    previous: codes.eof,
    sliceSerialize,
    sliceStream,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main2();
    if (chunks[chunks.length - 1] !== codes.eof) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token2, expandTabs) {
    return serializeChunks(sliceStream(token2), expandTabs);
  }
  function sliceStream(token2) {
    return sliceChunks(chunks, token2);
  }
  function now() {
    const { _bufferIndex, _index, line, column, offset } = point4;
    return { _bufferIndex, _index, line, column, offset };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
    debug("position: define skip: `%j`", point4);
  }
  function main2() {
    let chunkIndex;
    while (point4._index < chunks.length) {
      const chunk = chunks[point4._index];
      if (typeof chunk === "string") {
        chunkIndex = point4._index;
        if (point4._bufferIndex < 0) {
          point4._bufferIndex = 0;
        }
        while (point4._index === chunkIndex && point4._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point4._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code3) {
    ok(consumed === true, "expected character to be consumed");
    consumed = void 0;
    debug("main: passing `%s` to %s", code3, state && state.name);
    expectedCode = code3;
    ok(typeof state === "function", "expected state");
    state = state(code3);
  }
  function consume(code3) {
    ok(code3 === expectedCode, "expected given code to equal expected code");
    debug("consume: `%s`", code3);
    ok(
      consumed === void 0,
      "expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used"
    );
    ok(
      code3 === null ? context.events.length === 0 || context.events[context.events.length - 1][0] === "exit" : context.events[context.events.length - 1][0] === "enter",
      "expected last token to be open"
    );
    if (markdownLineEnding(code3)) {
      point4.line++;
      point4.column = 1;
      point4.offset += code3 === codes.carriageReturnLineFeed ? 2 : 1;
      accountForPotentialSkip();
      debug("position: after eol: `%j`", point4);
    } else if (code3 !== codes.virtualSpace) {
      point4.column++;
      point4.offset++;
    }
    if (point4._bufferIndex < 0) {
      point4._index++;
    } else {
      point4._bufferIndex++;
      if (point4._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
      // strings.
      /** @type {string} */
      chunks[point4._index].length) {
        point4._bufferIndex = -1;
        point4._index++;
      }
    }
    context.previous = code3;
    consumed = true;
  }
  function enter(type, fields) {
    const token2 = fields || {};
    token2.type = type;
    token2.start = now();
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    debug("enter: `%s`", type);
    context.events.push(["enter", token2, context]);
    stack2.push(token2);
    return token2;
  }
  function exit3(type) {
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    const token2 = stack2.pop();
    ok(token2, "cannot close w/o open tokens");
    token2.end = now();
    ok(type === token2.type, "expected exit token to match current token");
    ok(
      !(token2.start._index === token2.end._index && token2.start._bufferIndex === token2.end._bufferIndex),
      "expected non-empty token (`" + type + "`)"
    );
    debug("exit: `%s`", token2.type);
    context.events.push(["exit", token2, context]);
    return token2;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // Looks like a construct.
        handleListOfConstructs([
          /** @type {Construct} */
          constructs2
        ])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map) {
        return start;
        function start(code3) {
          const left = code3 !== null && map[code3];
          const all3 = code3 !== null && map.null;
          const list4 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(left) ? left : left ? [left] : [],
            ...Array.isArray(all3) ? all3 : all3 ? [all3] : []
          ];
          return handleListOfConstructs(list4)(code3);
        }
      }
      function handleListOfConstructs(list4) {
        listOfConstructs = list4;
        constructIndex = 0;
        if (list4.length === 0) {
          ok(bogusState, "expected `bogusState` to be given");
          return bogusState;
        }
        return handleConstruct(list4[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code3) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          ok(
            context.parser.constructs.disable.null,
            "expected `disable.null` to be populated"
          );
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code3);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code3);
        }
      }
      function ok3(code3) {
        ok(code3 === expectedCode, "expected code");
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code3) {
        ok(code3 === expectedCode, "expected code");
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from2,
        context.events.length - from2,
        construct.resolve(context.events.slice(from2), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
    ok(
      construct.partial || context.events.length === 0 || context.events[context.events.length - 1][0] === "exit",
      "expected last token to end"
    );
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack2);
    return { from: startEventsIndex, restore };
    function restore() {
      point4 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack2 = startStack;
      accountForPotentialSkip();
      debug("position: restore: `%j`", point4);
    }
  }
  function accountForPotentialSkip() {
    if (point4.line in columnStart && point4.column < 2) {
      point4.column = columnStart[point4.line];
      point4.offset += columnStart[point4.line] - 1;
    }
  }
}
function sliceChunks(chunks, token2) {
  const startIndex = token2.start._index;
  const startBufferIndex = token2.start._bufferIndex;
  const endIndex = token2.end._index;
  const endBufferIndex = token2.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    ok(endBufferIndex > -1, "expected non-negative end buffer index");
    ok(startBufferIndex > -1, "expected non-negative start buffer index");
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head2 = view[0];
      if (typeof head2 === "string") {
        view[0] = head2.slice(startBufferIndex);
      } else {
        ok(startBufferIndex === 0, "expected `startBufferIndex` to be `0`");
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value = values.cr;
          break;
        }
        case codes.lineFeed: {
          value = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value = expandTabs ? values.space : values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (!expandTabs && atTab) continue;
          value = values.space;
          break;
        }
        default: {
          ok(typeof chunk === "number", "expected number");
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value);
  }
  return result.join("");
}

// node_modules/micromark/dev/lib/parse.js
function parse2(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([constructs_exports, ...settings.extensions || []])
  );
  const parser = {
    constructs: constructs2,
    content: create2(content),
    defined: [],
    document: create2(document2),
    flow: create2(flow),
    lazy: {},
    string: create2(string2),
    text: create2(text2)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// node_modules/micromark/dev/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/micromark/dev/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code3;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value.charCodeAt(0) === codes.byteOrderMarker) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code3 = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code3 === codes.lf && startPosition === endPosition && atCarriageReturn) {
        chunks.push(codes.carriageReturnLineFeed);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(codes.carriageReturn);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code3) {
          case codes.nul: {
            chunks.push(codes.replacementCharacter);
            column++;
            break;
          }
          case codes.ht: {
            next = Math.ceil(column / constants2.tabSize) * constants2.tabSize;
            chunks.push(codes.horizontalTab);
            while (column++ < next) chunks.push(codes.virtualSpace);
            break;
          }
          case codes.lf: {
            chunks.push(codes.lineFeed);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(codes.carriageReturn);
      if (buffer) chunks.push(buffer);
      chunks.push(codes.eof);
    }
    return chunks;
  }
}

// node_modules/micromark-util-decode-string/dev/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head2 = $2.charCodeAt(0);
  if (head2 === codes.numberSign) {
    const head3 = $2.charCodeAt(1);
    const hex = head3 === codes.lowercaseX || head3 === codes.uppercaseX;
    return decodeNumericCharacterReference(
      $2.slice(hex ? 2 : 1),
      hex ? constants2.numericBaseHexadecimal : constants2.numericBaseDecimal
    );
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point4) {
  return index(point4 && point4.line) + ":" + index(point4 && point4.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}

// node_modules/mdast-util-from-markdown/dev/lib/index.js
var own4 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(
    postprocess(
      parse2(options).document().write(preprocess()(value, encoding, true))
    )
  );
}
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link3),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading3),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition3),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis3),
      hardBreakEscape: opener(hardBreak3),
      hardBreakTrailing: opener(hardBreak3),
      htmlFlow: opener(html7, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html7, buffer),
      htmlTextData: onenterdata,
      image: opener(image3),
      label: buffer,
      link: opener(link3),
      listItem: opener(listItem3),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list4, onenterlistordered),
      listUnordered: opener(list4),
      paragraph: opener(paragraph3),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading3),
      strong: opener(strong3),
      thematicBreak: opener(thematicBreak4)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile3;
  function compile3(events) {
    let tree = { type: "root", children: [] };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit3,
      buffer,
      resume,
      data
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === types.listOrdered || events[index2][1].type === types.listUnordered) {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          ok(typeof tail === "number", "expected list ot be open");
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own4.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(
          Object.assign(
            { sliceSerialize: events[index2][2].sliceSerialize },
            context
          ),
          events[index2][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError2;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point2(
        events.length > 0 ? events[0][1].start : { line: 1, column: 1, offset: 0 }
      ),
      end: point2(
        events.length > 0 ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
      )
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem4;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      switch (event[1].type) {
        case types.listUnordered:
        case types.listOrdered:
        case types.blockQuote: {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case types.lineEndingBlank: {
          if (event[0] === "enter") {
            if (listItem4 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index2;
            }
            atMarker = void 0;
          }
          break;
        }
        case types.linePrefix:
        case types.listItemValue:
        case types.listItemMarker:
        case types.listItemPrefix:
        case types.listItemPrefixWhitespace: {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === types.listItemPrefix || containerBalance === -1 && event[0] === "exit" && (event[1].type === types.listUnordered || event[1].type === types.listOrdered)) {
        if (listItem4) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === types.lineEnding || tailEvent[1].type === types.lineEndingBlank) {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = types.lineEndingBlank;
                listSpread = true;
              }
              tailEvent[1].type = types.lineEnding;
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === types.linePrefix || tailEvent[1].type === types.blockQuotePrefix || tailEvent[1].type === types.blockQuotePrefixWhitespace || tailEvent[1].type === types.blockQuoteMarker || tailEvent[1].type === types.listItemIndent) {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem4._spread = true;
          }
          listItem4.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index2, 0, ["exit", listItem4, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === types.listItemPrefix) {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          listItem4 = item;
          events.splice(index2, 0, ["enter", item, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function opener(create2, and) {
    return open;
    function open(token2) {
      enter.call(this, create2(token2), token2);
      if (and) and.call(this, token2);
    }
  }
  function buffer() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter(node2, token2, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    ok(parent, "expected `parent`");
    ok("children" in parent, "expected `parent`");
    const siblings2 = parent.children;
    siblings2.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token2, errorHandler || void 0]);
    node2.position = {
      start: point2(token2.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and) {
    return close;
    function close(token2) {
      if (and) and.call(this, token2);
      exit3.call(this, token2);
    }
  }
  function exit3(token2, onExitError) {
    const node2 = this.stack.pop();
    ok(node2, "expected `node`");
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token2.type + "` (" + stringifyPosition({ start: token2.start, end: token2.end }) + "): it’s not open"
      );
    } else if (open[0].type !== token2.type) {
      if (onExitError) {
        onExitError.call(this, token2, open[0]);
      } else {
        const handler = open[1] || defaultOnError2;
        handler.call(this, token2, open[0]);
      }
    }
    ok(node2.type !== "fragment", "unexpected fragment `exit`ed");
    ok(node2.position, "expected `position` to be defined");
    node2.position.end = point2(token2.end);
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token2) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ok(ancestor, "expected nodes on stack");
      ok(ancestor.type === "list", "expected list on stack");
      ancestor.start = Number.parseInt(
        this.sliceSerialize(token2),
        constants2.numericBaseDecimal
      );
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside) return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token2) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.url = data2;
  }
  function onexitatxheadingsequence(token2) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    if (!node2.depth) {
      const depth = this.sliceSerialize(token2).length;
      ok(
        depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6,
        "expected `depth` between `1` and `6`"
      );
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token2) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    node2.depth = this.sliceSerialize(token2).codePointAt(0) === codes.equalsTo ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token2) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok("children" in node2, "expected parent on stack");
    const siblings2 = node2.children;
    let tail = siblings2[siblings2.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text6();
      tail.position = {
        start: point2(token2.start),
        // @ts-expect-error: we’ll add `end` later.
        end: void 0
      };
      siblings2.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token2) {
    const tail = this.stack.pop();
    ok(tail, "expected a `node` to be on the stack");
    ok("value" in tail, "expected a `literal` to be on the stack");
    ok(tail.position, "expected `node` to have an open position");
    tail.value += this.sliceSerialize(token2);
    tail.position.end = point2(token2.end);
  }
  function onexitlineending(token2) {
    const context = this.stack[this.stack.length - 1];
    ok(context, "expected `node`");
    if (this.data.atHardBreak) {
      ok("children" in context, "expected `parent`");
      const tail = context.children[context.children.length - 1];
      ok(tail.position, "expected tail to have a starting position");
      tail.position.end = point2(token2.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token2);
      onexitdata.call(this, token2);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "inlineCode", "expected inline code on stack");
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image", "expected image on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token2) {
    const string4 = this.sliceSerialize(token2);
    const ancestor = this.stack[this.stack.length - 2];
    ok(ancestor, "expected ancestor on stack");
    ok(
      ancestor.type === "image" || ancestor.type === "link",
      "expected image or link on stack"
    );
    ancestor.label = decodeString(string4);
    ancestor.identifier = normalizeIdentifier(string4).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    ok(fragment, "expected node on stack");
    ok(fragment.type === "fragment", "expected fragment on stack");
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token2) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image reference or link reference on stack"
    );
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token2) {
    ok(
      token2.type === "characterReferenceMarkerNumeric" || token2.type === "characterReferenceMarkerHexadecimal"
    );
    this.data.characterReferenceType = token2.type;
  }
  function onexitcharacterreferencevalue(token2) {
    const data2 = this.sliceSerialize(token2);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data2,
        type === types.characterReferenceMarkerNumeric ? constants2.numericBaseDecimal : constants2.numericBaseHexadecimal
      );
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data2);
      ok(result !== false, "expected reference to decode");
      value = result;
    }
    const tail = this.stack[this.stack.length - 1];
    ok(tail, "expected `node`");
    ok("value" in tail, "expected `node.value`");
    tail.value += value;
  }
  function onexitcharacterreference(token2) {
    const tail = this.stack.pop();
    ok(tail, "expected `node`");
    ok(tail.position, "expected `node.position`");
    tail.position.end = point2(token2.end);
  }
  function onexitautolinkprotocol(token2) {
    onexitdata.call(this, token2);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = this.sliceSerialize(token2);
  }
  function onexitautolinkemail(token2) {
    onexitdata.call(this, token2);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = "mailto:" + this.sliceSerialize(token2);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition3() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis3() {
    return { type: "emphasis", children: [] };
  }
  function heading3() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak3() {
    return { type: "break" };
  }
  function html7() {
    return { type: "html", value: "" };
  }
  function image3() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link3() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list4(token2) {
    return {
      type: "list",
      ordered: token2.type === "listOrdered",
      start: null,
      spread: token2._spread,
      children: []
    };
  }
  function listItem3(token2) {
    return {
      type: "listItem",
      spread: token2._spread,
      checked: null,
      children: []
    };
  }
  function paragraph3() {
    return { type: "paragraph", children: [] };
  }
  function strong3() {
    return { type: "strong", children: [] };
  }
  function text6() {
    return { type: "text", value: "" };
  }
  function thematicBreak4() {
    return { type: "thematicBreak" };
  }
}
function point2(d) {
  return { line: d.line, column: d.column, offset: d.offset };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key2;
  for (key2 in extension2) {
    if (own4.call(extension2, key2)) {
      switch (key2) {
        case "canContainEols": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key2];
          if (right) {
            Object.assign(combined[key2], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError2(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({ start: left.start, end: left.end }) + "): a different token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is still open"
    );
  }
}

// node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string4) {
  if (typeof string4 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string4.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/unist-util-is/lib/index.js
var convert = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok2;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters)) return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all3);
  function all3(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key2;
    for (key2 in check) {
      if (nodeAsRecord[key2] !== checkAsRecord[key2]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok2() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// node_modules/unist-util-visit-parents/lib/color.js
function color(d) {
  return d;
}

// node_modules/unist-util-visit-parents/lib/index.js
var empty2 = [];
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
function visitParents(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is2 = convert(check);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index2, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty2;
      let subresult;
      let offset;
      let grandparents;
      if (!test || is2(node2, index2, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty2 : [value];
}

// node_modules/mdast-util-find-and-replace/lib/index.js
function findAndReplace(tree, list4, options) {
  const settings = options || {};
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(list4);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  function visitor(node2, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      const siblings2 = grandparent ? grandparent.children : void 0;
      if (ignored(
        parent,
        siblings2 ? siblings2.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node2, parents);
    }
  }
  function handler(node2, parents) {
    const parent = parents[parents.length - 1];
    const find2 = pairs[pairIndex][0];
    const replace2 = pairs[pairIndex][1];
    let start = 0;
    const siblings2 = parent.children;
    const index2 = siblings2.indexOf(node2);
    let change = false;
    let nodes = [];
    find2.lastIndex = 0;
    let match = find2.exec(node2.value);
    while (match) {
      const position3 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node2]
      };
      let value = replace2(...match, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : void 0;
      }
      if (value === false) {
        find2.lastIndex = position3 + 1;
      } else {
        if (start !== position3) {
          nodes.push({
            type: "text",
            value: node2.value.slice(start, position3)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start = position3 + match[0].length;
        change = true;
      }
      if (!find2.global) {
        break;
      }
      match = find2.exec(node2.value);
    }
    if (change) {
      if (start < node2.value.length) {
        nodes.push({ type: "text", value: node2.value.slice(start) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node2];
    }
    return index2 + nodes.length;
  }
}
function toPairs(tupleOrList) {
  const result = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list4 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index2 = -1;
  while (++index2 < list4.length) {
    const tuple = list4[index2];
    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
  }
  return result;
}
function toExpression(find2) {
  return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : function() {
    return replace2;
  };
}

// node_modules/mdast-util-gfm-autolink-literal/lib/index.js
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function enterLiteralAutolink(token2) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token2);
}
function enterLiteralAutolinkValue(token2) {
  this.config.enter.autolinkProtocol.call(this, token2);
}
function exitLiteralAutolinkHttp(token2) {
  this.config.exit.autolinkProtocol.call(this, token2);
}
function exitLiteralAutolinkWww(token2) {
  this.config.exit.data.call(this, token2);
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "link");
  node2.url = "http://" + this.sliceSerialize(token2);
}
function exitLiteralAutolinkEmail(token2) {
  this.config.exit.autolinkEmail.call(this, token2);
}
function exitLiteralAutolink(token2) {
  this.exit(token2);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_, protocol, domain, path, match) {
  let prefix = "";
  if (!previous2(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain = protocol + domain;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain)) {
    return false;
  }
  const parts = splitUrl(domain + path);
  if (!parts[0]) return false;
  const result = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_, atext, label, match) {
  if (
    // Not an expected previous character.
    !previous2(match, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label)
  ) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain) {
  const parts = domain.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail = trailExec[0];
  let closingParenIndex = trail.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail.slice(0, closingParenIndex + 1);
    trail = trail.slice(closingParenIndex + 1);
    closingParenIndex = trail.indexOf(")");
    closingParens++;
  }
  return [url, trail];
}
function previous2(match, email) {
  const code3 = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace(code3) || unicodePunctuation(code3)) && // If it’s an email, the previous character should not be a slash.
  (!email || code3 !== 47);
}

// node_modules/mdast-util-gfm-footnote/lib/index.js
footnoteReference.peek = footnoteReferencePeek;
function enterFootnoteCallString() {
  this.buffer();
}
function enterFootnoteCall(token2) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token2);
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function enterFootnoteDefinition(token2) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    token2
  );
}
function exitFootnoteCallString(token2) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "footnoteReference");
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token2)
  ).toLowerCase();
  node2.label = label;
}
function exitFootnoteCall(token2) {
  this.exit(token2);
}
function exitFootnoteDefinitionLabelString(token2) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "footnoteDefinition");
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token2)
  ).toLowerCase();
  node2.label = label;
}
function exitFootnoteDefinition(token2) {
  this.exit(token2);
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteReference(node2, _, state, info) {
  const tracker = state.createTracker(info);
  let value = tracker.move("[^");
  const exit3 = state.enter("footnoteReference");
  const subexit = state.enter("reference");
  value += tracker.move(
    state.safe(state.associationId(node2), { after: "]", before: value })
  );
  subexit();
  exit3();
  value += tracker.move("]");
  return value;
}
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteCallString: enterFootnoteCallString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: enterFootnoteDefinition
    },
    exit: {
      gfmFootnoteCallString: exitFootnoteCallString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: exitFootnoteDefinition
    }
  };
}

// node_modules/mdast-util-gfm-strikethrough/lib/index.js
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function enterStrikethrough(token2) {
  this.enter({ type: "delete", children: [] }, token2);
}
function exitStrikethrough(token2) {
  this.exit(token2);
}
function handleDelete(node2, _, state, info) {
  const tracker = state.createTracker(info);
  const exit3 = state.enter("strikethrough");
  let value = tracker.move("~~");
  value += state.containerPhrasing(node2, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit3();
  return value;
}
function peekDelete() {
  return "~";
}

// node_modules/mdast-util-to-markdown/lib/configure.js
var own5 = {}.hasOwnProperty;

// node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js
function encodeCharacterReference(code3) {
  return "&#x" + code3.toString(16).toUpperCase() + ";";
}

// node_modules/mdast-util-to-markdown/lib/util/encode-info.js
function encodeInfo(outside, inside, marker) {
  const outsideKind = classifyCharacter(outside);
  const insideKind = classifyCharacter(inside);
  if (outsideKind === void 0) {
    return insideKind === void 0 ? (
      // Letter inside:
      // we have to encode *both* letters for `_` as it is looser.
      // it already forms for `*` (and GFMs `~`).
      marker === "_" ? { inside: true, outside: true } : { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (letter, whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: encode outer (letter)
      { inside: false, outside: true }
    );
  }
  if (outsideKind === 1) {
    return insideKind === void 0 ? (
      // Letter inside: already forms.
      { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: already forms.
      { inside: false, outside: false }
    );
  }
  return insideKind === void 0 ? (
    // Letter inside: already forms.
    { inside: false, outside: false }
  ) : insideKind === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: true, outside: false }
  ) : (
    // Punctuation inside: already forms.
    { inside: false, outside: false }
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
emphasis.peek = emphasisPeek;
function emphasis(node2, _, state, info) {
  const marker = checkEmphasis(state);
  const exit3 = state.enter("emphasis");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker);
  let between = tracker.move(
    state.containerPhrasing(node2, {
      after: marker,
      before,
      ...tracker.current()
    })
  );
  const betweenHead = between.charCodeAt(0);
  const open = encodeInfo(
    info.before.charCodeAt(info.before.length - 1),
    betweenHead,
    marker
  );
  if (open.inside) {
    between = encodeCharacterReference(betweenHead) + between.slice(1);
  }
  const betweenTail = between.charCodeAt(between.length - 1);
  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close.inside) {
    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker);
  exit3();
  state.attentionEncodeSurroundingInfo = {
    after: close.outside,
    before: open.outside
  };
  return before + between + after;
}
function emphasisPeek(_, _1, state) {
  return state.options.emphasis || "*";
}

// node_modules/unist-util-visit/lib/index.js
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index2 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index2, parent);
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/html.js
html5.peek = htmlPeek;
function html5(node2) {
  return node2.value || "";
}
function htmlPeek() {
  return "<";
}

// node_modules/mdast-util-to-markdown/lib/handle/image.js
image.peek = imagePeek;
function image(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit3 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  value += tracker.move(
    state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function imagePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
imageReference.peek = imageReferencePeek;
function imageReference(node2, _, state, info) {
  const type = node2.referenceType;
  const exit3 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  const alt = state.safe(node2.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack2 = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack2;
  exit3();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
inlineCode.peek = inlineCodePeek;
function inlineCode(node2, _, state) {
  let value = node2.value || "";
  let sequence = "`";
  let index2 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    const expression = state.compilePattern(pattern);
    let match;
    if (!pattern.atBreak) continue;
    while (match = expression.exec(value)) {
      let position3 = match.index;
      if (value.charCodeAt(position3) === 10 && value.charCodeAt(position3 - 1) === 13) {
        position3--;
      }
      value = value.slice(0, position3) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}

// node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
function formatLinkAsAutolink(node2, state) {
  const raw2 = toString(node2);
  return Boolean(
    !state.options.resourceLink && // If there’s a url…
    node2.url && // And there’s a no title…
    !node2.title && // And the content of `node` is a single text node…
    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content…
    (raw2 === node2.url || "mailto:" + raw2 === node2.url) && // And that starts w/ a protocol…
    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesn’t contain ASCII control codes (character escapes and
    // references don’t work), space, or angle brackets…
    !/[\0- <>\u007F]/.test(node2.url)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/link.js
link.peek = linkPeek;
function link(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info);
  let exit3;
  let subexit;
  if (formatLinkAsAutolink(node2, state)) {
    const stack2 = state.stack;
    state.stack = [];
    exit3 = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit3();
    state.stack = stack2;
    return value2;
  }
  exit3 = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function linkPeek(node2, _, state) {
  return formatLinkAsAutolink(node2, state) ? "<" : "[";
}

// node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
linkReference.peek = linkReferencePeek;
function linkReference(node2, _, state, info) {
  const type = node2.referenceType;
  const exit3 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  const text6 = state.containerPhrasing(node2, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text6 + "][");
  subexit();
  const stack2 = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack2;
  exit3();
  if (type === "full" || !text6 || text6 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}

// node_modules/mdast-util-phrasing/lib/index.js
var phrasing = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  convert([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);

// node_modules/mdast-util-to-markdown/lib/util/check-strong.js
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/strong.js
strong.peek = strongPeek;
function strong(node2, _, state, info) {
  const marker = checkStrong(state);
  const exit3 = state.enter("strong");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker + marker);
  let between = tracker.move(
    state.containerPhrasing(node2, {
      after: marker,
      before,
      ...tracker.current()
    })
  );
  const betweenHead = between.charCodeAt(0);
  const open = encodeInfo(
    info.before.charCodeAt(info.before.length - 1),
    betweenHead,
    marker
  );
  if (open.inside) {
    between = encodeCharacterReference(betweenHead) + between.slice(1);
  }
  const betweenTail = between.charCodeAt(between.length - 1);
  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close.inside) {
    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker + marker);
  exit3();
  state.attentionEncodeSurroundingInfo = {
    after: close.outside,
    before: open.outside
  };
  return before + between + after;
}
function strongPeek(_, _1, state) {
  return state.options.strong || "*";
}

// node_modules/mdast-util-gfm-table/lib/index.js
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit2,
      tableHeader: exit2,
      tableRow: exit2
    }
  };
}
function enterTable(token2) {
  const align = token2._align;
  ok(align, "expected `_align` on table");
  this.enter(
    {
      type: "table",
      align: align.map(function(d) {
        return d === "none" ? null : d;
      }),
      children: []
    },
    token2
  );
  this.data.inTable = true;
}
function exitTable(token2) {
  this.exit(token2);
  this.data.inTable = void 0;
}
function enterRow(token2) {
  this.enter({ type: "tableRow", children: [] }, token2);
}
function exit2(token2) {
  this.exit(token2);
}
function enterCell(token2) {
  this.enter({ type: "tableCell", children: [] }, token2);
}
function exitCodeText(token2) {
  let value = this.resume();
  if (this.data.inTable) {
    value = value.replace(/\\([\\|])/g, replace);
  }
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "inlineCode");
  node2.value = value;
  this.exit(token2);
}
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}

// node_modules/mdast-util-gfm-task-list-item/lib/index.js
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function exitCheck(token2) {
  const node2 = this.stack[this.stack.length - 2];
  ok(node2.type === "listItem");
  node2.checked = token2.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token2) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "paragraph");
    const head2 = node2.children[0];
    if (head2 && head2.type === "text") {
      const siblings2 = parent.children;
      let index2 = -1;
      let firstParaghraph;
      while (++index2 < siblings2.length) {
        const sibling = siblings2[index2];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head2.value = head2.value.slice(1);
        if (head2.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head2.position && typeof head2.position.start.offset === "number") {
          head2.position.start.column++;
          head2.position.start.offset++;
          node2.position.start = Object.assign({}, head2.position.start);
        }
      }
    }
  }
  this.exit(token2);
}

// node_modules/mdast-util-gfm/lib/index.js
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown()
  ];
}

// node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
function blockquote2(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/break.js
function hardBreak2(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}

// node_modules/mdast-util-to-hast/lib/handlers/code.js
function code2(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const properties = {};
  if (node2.lang) {
    properties.className = ["language-" + node2.lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}

// node_modules/mdast-util-to-hast/lib/handlers/delete.js
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
function emphasis2(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
function footnoteReference2(state, node2) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const id = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id.toLowerCase());
  const index2 = state.footnoteOrder.indexOf(id);
  let counter;
  let reuseCounter = state.footnoteCounts.get(id);
  if (reuseCounter === void 0) {
    reuseCounter = 0;
    state.footnoteOrder.push(id);
    counter = state.footnoteOrder.length;
  } else {
    counter = index2 + 1;
  }
  reuseCounter += 1;
  state.footnoteCounts.set(id, reuseCounter);
  const link3 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + clobberPrefix + "fn-" + safeId,
      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link3);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link3]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}

// node_modules/mdast-util-to-hast/lib/handlers/heading.js
function heading2(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/html.js
function html6(state, node2) {
  if (state.options.allowDangerousHtml) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return void 0;
}

// node_modules/mdast-util-to-hast/lib/revert.js
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return [{ type: "text", value: "![" + node2.alt + suffix }];
  }
  const contents = state.all(node2);
  const head2 = contents[0];
  if (head2 && head2.type === "text") {
    head2.value = "[" + head2.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}

// node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
function imageReference2(state, node2) {
  const id = String(node2.identifier).toUpperCase();
  const definition3 = state.definitionById.get(id);
  if (!definition3) {
    return revert(state, node2);
  }
  const properties = { src: normalizeUri(definition3.url || ""), alt: node2.alt };
  if (definition3.title !== null && definition3.title !== void 0) {
    properties.title = definition3.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/image.js
function image2(state, node2) {
  const properties = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
function inlineCode2(state, node2) {
  const text6 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text6);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text6]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
function linkReference2(state, node2) {
  const id = String(node2.identifier).toUpperCase();
  const definition3 = state.definitionById.get(id);
  if (!definition3) {
    return revert(state, node2);
  }
  const properties = { href: normalizeUri(definition3.url || "") };
  if (definition3.title !== null && definition3.title !== void 0) {
    properties.title = definition3.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/link.js
function link2(state, node2) {
  const properties = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/list-item.js
function listItem2(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head2 = results[0];
    let paragraph3;
    if (head2 && head2.type === "element" && head2.tagName === "p") {
      paragraph3 = head2;
    } else {
      paragraph3 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph3);
    }
    if (paragraph3.children.length > 0) {
      paragraph3.children.unshift({ type: "text", value: " " });
    }
    paragraph3.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties.className = ["task-list-item"];
  }
  let index2 = -1;
  while (++index2 < results.length) {
    const child = results[index2];
    if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties, children };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index2 = -1;
    while (!loose && ++index2 < children.length) {
      loose = listItemLoose(children[index2]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread = node2.spread;
  return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
}

// node_modules/mdast-util-to-hast/lib/handlers/list.js
function list3(state, node2) {
  const properties = {};
  const results = state.all(node2);
  let index2 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties.start = node2.start;
  }
  while (++index2 < results.length) {
    const child = results[index2];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
function paragraph2(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/root.js
function root3(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/strong.js
function strong2(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/unist-util-position/lib/index.js
var pointEnd = point3("end");
var pointStart = point3("start");
function point3(type) {
  return point4;
  function point4(node2) {
    const point5 = node2 && node2.position && node2.position[type] || {};
    if (typeof point5.line === "number" && point5.line > 0 && typeof point5.column === "number" && point5.column > 0) {
      return {
        line: point5.line,
        column: point5.column,
        offset: typeof point5.offset === "number" && point5.offset > -1 ? point5.offset : void 0
      };
    }
  }
}
function position2(node2) {
  const start = pointStart(node2);
  const end = pointEnd(node2);
  if (start && end) {
    return { start, end };
  }
}

// node_modules/mdast-util-to-hast/lib/handlers/table.js
function table(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head2 = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head2);
    tableContent.push(head2);
  }
  if (rows.length > 0) {
    const body3 = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start = pointStart(node2.children[1]);
    const end = pointEnd(node2.children[node2.children.length - 1]);
    if (start && end) body3.position = { start, end };
    tableContent.push(body3);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-row.js
function tableRow(state, node2, parent) {
  const siblings2 = parent ? parent.children : void 0;
  const rowIndex = siblings2 ? siblings2.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells2 = [];
  while (++cellIndex < length) {
    const cell = node2.children[cellIndex];
    const properties = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties, children: [] };
    if (cell) {
      result2.children = state.all(cell);
      state.patch(cell, result2);
      result2 = state.applyData(cell, result2);
    }
    cells2.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells2, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/trim-lines/index.js
var tab = 9;
var space = 32;
function trimLines(value) {
  const source = String(value);
  const search2 = /\r?\n|\r/g;
  let match = search2.exec(source);
  let last = 0;
  const lines = [];
  while (match) {
    lines.push(
      trimLine(source.slice(last, match.index), last > 0, true),
      match[0]
    );
    last = match.index + match[0].length;
    match = search2.exec(source);
  }
  lines.push(trimLine(source.slice(last), last > 0, false));
  return lines.join("");
}
function trimLine(value, start, end) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start) {
    let code3 = value.codePointAt(startIndex);
    while (code3 === tab || code3 === space) {
      startIndex++;
      code3 = value.codePointAt(startIndex);
    }
  }
  if (end) {
    let code3 = value.codePointAt(endIndex - 1);
    while (code3 === tab || code3 === space) {
      endIndex--;
      code3 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}

// node_modules/mdast-util-to-hast/lib/handlers/text.js
function text5(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
function thematicBreak3(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/index.js
var handlers = {
  blockquote: blockquote2,
  break: hardBreak2,
  code: code2,
  delete: strikethrough,
  emphasis: emphasis2,
  footnoteReference: footnoteReference2,
  heading: heading2,
  html: html6,
  imageReference: imageReference2,
  image: image2,
  inlineCode: inlineCode2,
  linkReference: linkReference2,
  link: link2,
  listItem: listItem2,
  list: list3,
  paragraph: paragraph2,
  // @ts-expect-error: root is different, but hard to type.
  root: root3,
  strong: strong2,
  table,
  tableCell,
  tableRow,
  text: text5,
  thematicBreak: thematicBreak3,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return void 0;
}

// node_modules/@ungap/structured-clone/esm/types.js
var VOID = -1;
var PRIMITIVE = 0;
var ARRAY = 1;
var OBJECT = 2;
var DATE = 3;
var REGEXP = 4;
var MAP = 5;
var SET = 6;
var ERROR = 7;
var BIGINT = 8;

// node_modules/@ungap/structured-clone/esm/deserialize.js
var env = typeof self === "object" ? self : globalThis;
var deserializer = ($, _) => {
  const as = (out, index2) => {
    $.set(index2, out);
    return out;
  };
  const unpair = (index2) => {
    if ($.has(index2))
      return $.get(index2);
    const [type, value] = _[index2];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as(value, index2);
      case ARRAY: {
        const arr = as([], index2);
        for (const index3 of value)
          arr.push(unpair(index3));
        return arr;
      }
      case OBJECT: {
        const object = as({}, index2);
        for (const [key2, index3] of value)
          object[unpair(key2)] = unpair(index3);
        return object;
      }
      case DATE:
        return as(new Date(value), index2);
      case REGEXP: {
        const { source, flags } = value;
        return as(new RegExp(source, flags), index2);
      }
      case MAP: {
        const map = as(/* @__PURE__ */ new Map(), index2);
        for (const [key2, index3] of value)
          map.set(unpair(key2), unpair(index3));
        return map;
      }
      case SET: {
        const set = as(/* @__PURE__ */ new Set(), index2);
        for (const index3 of value)
          set.add(unpair(index3));
        return set;
      }
      case ERROR: {
        const { name, message } = value;
        return as(new env[name](message), index2);
      }
      case BIGINT:
        return as(BigInt(value), index2);
      case "BigInt":
        return as(Object(BigInt(value)), index2);
      case "ArrayBuffer":
        return as(new Uint8Array(value).buffer, value);
      case "DataView": {
        const { buffer } = new Uint8Array(value);
        return as(new DataView(buffer), value);
      }
    }
    return as(new env[type](value), index2);
  };
  return unpair;
};
var deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);

// node_modules/@ungap/structured-clone/esm/serialize.js
var EMPTY = "";
var { toString: toString2 } = {};
var { keys } = Object;
var typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString2.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
    case "DataView":
      return [ARRAY, asString];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
var shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
var serializer = (strict, json, $, _) => {
  const as = (out, value) => {
    const index2 = _.push(out) - 1;
    $.set(value, index2);
    return index2;
  };
  const pair = (value) => {
    if ($.has(value))
      return $.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as([VOID], value);
        }
        return as([TYPE, entry], value);
      }
      case ARRAY: {
        if (type) {
          let spread = value;
          if (type === "DataView") {
            spread = new Uint8Array(value.buffer);
          } else if (type === "ArrayBuffer") {
            spread = new Uint8Array(value);
          }
          return as([type, [...spread]], value);
        }
        const arr = [];
        const index2 = as([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index2;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case "BigInt":
              return as([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as([type, value.valueOf()], value);
          }
        }
        if (json && "toJSON" in value)
          return pair(value.toJSON());
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const key2 of keys(value)) {
          if (strict || !shouldSkip(typeOf(value[key2])))
            entries.push([pair(key2), pair(value[key2])]);
        }
        return index2;
      }
      case DATE:
        return as([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source, flags } = value;
        return as([TYPE, { source, flags }], value);
      }
      case MAP: {
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const [key2, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key2)) || shouldSkip(typeOf(entry))))
            entries.push([pair(key2), pair(entry)]);
        }
        return index2;
      }
      case SET: {
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries.push(pair(entry));
        }
        return index2;
      }
    }
    const { message } = value;
    return as([TYPE, { name: type, message }], value);
  };
  return pair;
};
var serialize = (value, { json, lossy } = {}) => {
  const _ = [];
  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;
};

// node_modules/@ungap/structured-clone/esm/index.js
var esm_default = typeof structuredClone === "function" ? (
  /* c8 ignore start */
  (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize(any, options)) : structuredClone(any)
) : (any, options) => deserialize(serialize(any, options));

// node_modules/mdast-util-to-hast/lib/footer.js
function defaultFootnoteBackContent(_, rereferenceIndex) {
  const result = [{ type: "text", value: "↩" }];
  if (rereferenceIndex > 1) {
    result.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(rereferenceIndex) }]
    });
  }
  return result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
  const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
  const footnoteLabel = state.options.footnoteLabel || "Footnotes";
  const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
  const footnoteLabelProperties = state.options.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  const listItems = [];
  let referenceIndex = -1;
  while (++referenceIndex < state.footnoteOrder.length) {
    const definition3 = state.footnoteById.get(
      state.footnoteOrder[referenceIndex]
    );
    if (!definition3) {
      continue;
    }
    const content3 = state.all(definition3);
    const id = String(definition3.identifier).toUpperCase();
    const safeId = normalizeUri(id.toLowerCase());
    let rereferenceIndex = 0;
    const backReferences = [];
    const counts = state.footnoteCounts.get(id);
    while (counts !== void 0 && ++rereferenceIndex <= counts) {
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
      if (typeof children === "string") {
        children = { type: "text", value: children };
      }
      backReferences.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(children) ? children : [children]
      });
    }
    const tail = content3[content3.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content3.push(...backReferences);
    }
    const listItem3 = {
      type: "element",
      tagName: "li",
      properties: { id: clobberPrefix + "fn-" + safeId },
      children: state.wrap(content3, true)
    };
    state.patch(definition3, listItem3);
    listItems.push(listItem3);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: footnoteLabelTagName,
        properties: {
          ...esm_default(footnoteLabelProperties),
          id: "footnote-label"
        },
        children: [{ type: "text", value: footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}

// node_modules/mdast-util-to-hast/lib/state.js
var own6 = {}.hasOwnProperty;
var emptyOptions3 = {};
function createState(tree, options) {
  const settings = options || emptyOptions3;
  const definitionById = /* @__PURE__ */ new Map();
  const footnoteById = /* @__PURE__ */ new Map();
  const footnoteCounts = /* @__PURE__ */ new Map();
  const handlers2 = { ...handlers, ...settings.handlers };
  const state = {
    all: all3,
    applyData,
    definitionById,
    footnoteById,
    footnoteCounts,
    footnoteOrder: [],
    handlers: handlers2,
    one: one3,
    options: settings,
    patch,
    wrap
  };
  visit(tree, function(node2) {
    if (node2.type === "definition" || node2.type === "footnoteDefinition") {
      const map = node2.type === "definition" ? definitionById : footnoteById;
      const id = String(node2.identifier).toUpperCase();
      if (!map.has(id)) {
        map.set(id, node2);
      }
    }
  });
  return state;
  function one3(node2, parent) {
    const type = node2.type;
    const handle3 = state.handlers[type];
    if (own6.call(state.handlers, type) && handle3) {
      return handle3(state, node2, parent);
    }
    if (state.options.passThrough && state.options.passThrough.includes(type)) {
      if ("children" in node2) {
        const { children, ...shallow } = node2;
        const result = esm_default(shallow);
        result.children = state.all(node2);
        return result;
      }
      return esm_default(node2);
    }
    const unknown2 = state.options.unknownHandler || defaultUnknownHandler;
    return unknown2(state, node2, parent);
  }
  function all3(parent) {
    const values2 = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index2 = -1;
      while (++index2 < nodes.length) {
        const result = state.one(nodes[index2], parent);
        if (result) {
          if (index2 && nodes[index2 - 1].type === "break") {
            if (!Array.isArray(result) && result.type === "text") {
              result.value = trimMarkdownSpaceStart(result.value);
            }
            if (!Array.isArray(result) && result.type === "element") {
              const head2 = result.children[0];
              if (head2 && head2.type === "text") {
                head2.value = trimMarkdownSpaceStart(head2.value);
              }
            }
          }
          if (Array.isArray(result)) {
            values2.push(...result);
          } else {
            values2.push(result);
          }
        }
      }
    }
    return values2;
  }
}
function patch(from, to) {
  if (from.position) to.position = position2(from);
}
function applyData(from, to) {
  let result = to;
  if (from && from.data) {
    const hName = from.data.hName;
    const hChildren = from.data.hChildren;
    const hProperties = from.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        const children = "children" in result ? result.children : [result];
        result = { type: "element", tagName: hName, properties: {}, children };
      }
    }
    if (result.type === "element" && hProperties) {
      Object.assign(result.properties, esm_default(hProperties));
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {};
  const result = "value" in node2 && !(own6.call(data, "hProperties") || own6.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap(nodes, loose) {
  const result = [];
  let index2 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index2 < nodes.length) {
    if (index2) result.push({ type: "text", value: "\n" });
    result.push(nodes[index2]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}
function trimMarkdownSpaceStart(value) {
  let index2 = 0;
  let code3 = value.charCodeAt(index2);
  while (code3 === 9 || code3 === 32) {
    index2++;
    code3 = value.charCodeAt(index2);
  }
  return value.slice(index2);
}

// node_modules/mdast-util-to-hast/lib/index.js
function toHast(tree, options) {
  const state = createState(tree, options);
  const node2 = state.one(tree, void 0);
  const foot = footer(state);
  const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
  if (foot) {
    ok("children" in result);
    result.children.push({ type: "text", value: "\n" }, foot);
  }
  return result;
}

// node_modules/@shikijs/vitepress-twoslash/dist/index.mjs
function rendererFloatingVue(options = {}) {
  const {
    classCopyIgnore = "vp-copy-ignore",
    classFloatingPanel = "twoslash-floating",
    classCode = "vp-code",
    classMarkdown = "vp-doc",
    floatingVueTheme = "twoslash",
    floatingVueThemeQuery = "twoslash-query",
    floatingVueThemeCompletion = "twoslash-completion"
  } = options.floatingVue || {};
  const {
    errorRendering = "line"
  } = options;
  const hoverBasicProps = {
    "class": "twoslash-hover",
    "popper-class": ["shiki", classFloatingPanel, classCopyIgnore, classCode].join(" "),
    "theme": floatingVueTheme
  };
  const rich = rendererRich({
    classExtra: classCopyIgnore,
    ...options,
    renderMarkdown,
    renderMarkdownInline,
    hast: {
      hoverToken: {
        tagName: "v-menu",
        properties: hoverBasicProps
      },
      hoverCompose: compose,
      queryToken: {
        tagName: "v-menu",
        properties: {
          ...hoverBasicProps,
          ":shown": "true",
          "theme": floatingVueThemeQuery
        }
      },
      queryCompose: compose,
      popupDocs: {
        class: `twoslash-popup-docs ${classMarkdown}`
      },
      popupDocsTags: {
        class: `twoslash-popup-docs twoslash-popup-docs-tags ${classMarkdown}`
      },
      popupError: {
        class: `twoslash-popup-error ${classMarkdown}`
      },
      errorToken: errorRendering === "line" ? void 0 : {
        tagName: "v-menu",
        properties: {
          ...hoverBasicProps,
          class: "twoslash-error twoslash-error-hover"
        }
      },
      errorCompose: compose,
      completionCompose({ popup, cursor }) {
        return [
          {
            type: "element",
            tagName: "v-menu",
            properties: {
              "popper-class": ["shiki twoslash-completion", classCopyIgnore, classFloatingPanel],
              "theme": floatingVueThemeCompletion,
              ":shown": "true"
            },
            children: [
              cursor,
              {
                type: "element",
                tagName: "template",
                properties: {
                  "v-slot:popper": "{}"
                },
                content: {
                  type: "root",
                  children: [vPre(popup)]
                }
              }
            ]
          }
        ];
      }
    }
  });
  return rich;
}
function vPre(el) {
  if (el.type === "element") {
    el.properties = el.properties || {};
    el.properties["v-pre"] = "";
  }
  return el;
}
function renderMarkdown(md) {
  const mdast = fromMarkdown(
    md.replace(/\{@link ([^}]*)\}/g, "$1"),
    // replace jsdoc links
    { mdastExtensions: [gfmFromMarkdown()] }
  );
  return toHast(
    mdast,
    {
      handlers: {
        code: (state, node2) => {
          const lang = node2.lang || "";
          if (lang) {
            return {
              type: "element",
              tagName: "code",
              properties: {},
              children: this.codeToHast(
                node2.value,
                {
                  ...this.options,
                  transformers: [],
                  lang,
                  structure: node2.value.trim().includes("\n") ? "classic" : "inline"
                }
              ).children
            };
          }
          return handlers.code(state, node2);
        }
      }
    }
  ).children;
}
function renderMarkdownInline(md, context) {
  if (context === "tag:param")
    md = md.replace(/^([\w$-]+)/, "`$1` ");
  const children = renderMarkdown.call(this, md);
  if (children.length === 1 && children[0].type === "element" && children[0].tagName === "p")
    return children[0].children;
  return children;
}
function compose(parts) {
  return [
    {
      type: "element",
      tagName: "span",
      properties: {},
      children: [parts.token]
    },
    {
      type: "element",
      tagName: "template",
      properties: {
        "v-slot:popper": "{}"
      },
      content: {
        type: "root",
        children: [vPre(parts.popup)]
      },
      children: []
    }
  ];
}
function transformerTwoslash(options = {}) {
  var _a;
  const {
    explicitTrigger = true,
    typesCache
  } = options;
  const onError = (error2, code3) => {
    var _a2;
    const isCI = typeof process !== "undefined" && ((_a2 = process == null ? void 0 : process.env) == null ? void 0 : _a2.CI);
    const isDev = typeof process !== "undefined" && true;
    const shouldThrow = (options.throws || isCI || !isDev) && options.throws !== false;
    console.error(`

--------
Twoslash error in code:
--------
${code3.split(/\n/g).slice(0, 15).join("\n").trim()}
--------
`);
    if (shouldThrow)
      throw error2;
    else
      console.error(error2);
    removeTwoslashNotations(code3);
  };
  const defaultTwoslasher = createTwoslasher3(options.twoslashOptions);
  let twoslasher2 = defaultTwoslasher;
  if (typesCache) {
    twoslasher2 = (code3, extension2, options2) => {
      const cached = typesCache.read(code3);
      if (cached)
        return cached;
      const twoslashResult = defaultTwoslasher(code3, extension2, options2);
      typesCache.write(code3, twoslashResult);
      return twoslashResult;
    };
    twoslasher2.getCacheMap = defaultTwoslasher.getCacheMap;
  }
  const twoslash = createTransformerFactory(twoslasher2)({
    langs: ["ts", "tsx", "js", "jsx", "json", "vue"],
    renderer: rendererFloatingVue(options),
    onTwoslashError: onError,
    onShikiError: onError,
    ...options,
    explicitTrigger
  });
  const trigger = explicitTrigger instanceof RegExp ? explicitTrigger : /\btwoslash\b/;
  (_a = typesCache == null ? void 0 : typesCache.init) == null ? void 0 : _a.call(typesCache);
  return {
    ...twoslash,
    name: "@shikijs/vitepress-twoslash",
    preprocess(code3, options2) {
      var _a2, _b, _c, _d, _e, _f;
      const cleanup = (_a2 = options2.transformers) == null ? void 0 : _a2.find((i) => i.name === "vitepress:clean-up");
      if (cleanup)
        (_b = options2.transformers) == null ? void 0 : _b.splice(options2.transformers.indexOf(cleanup), 1);
      if (!explicitTrigger || ((_d = (_c = options2.meta) == null ? void 0 : _c.__raw) == null ? void 0 : _d.match(trigger))) {
        const vPre2 = (_e = options2.transformers) == null ? void 0 : _e.find((i) => i.name === "vitepress:v-pre");
        if (vPre2)
          (_f = options2.transformers) == null ? void 0 : _f.splice(options2.transformers.indexOf(vPre2), 1);
      }
      return twoslash.preprocess.call(this, code3, options2);
    },
    postprocess(html7) {
      if (this.meta.twoslash)
        return html7.replace(/\{/g, "&#123;");
    }
  };
}
export {
  defaultHoverInfoProcessor,
  rendererFloatingVue,
  transformerTwoslash
};
/*! Bundled license information:

@vue/shared/dist/shared.esm-bundler.js:
  (**
  * @vue/shared v3.5.16
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*! #__NO_SIDE_EFFECTS__ *)

@vue/compiler-core/dist/compiler-core.esm-bundler.js:
  (**
  * @vue/compiler-core v3.5.16
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/compiler-dom/dist/compiler-dom.esm-bundler.js:
  (**
  * @vue/compiler-dom v3.5.16
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

he/he.js:
  (*! https://mths.be/he v1.2.0 by @mathias | MIT license *)
*/
//# sourceMappingURL=@slidev_cli___@slidev_client___@shikijs_vitepress-twoslash.js.map
